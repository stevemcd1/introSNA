[
  {
    "objectID": "Communities.html",
    "href": "Communities.html",
    "title": "4¬† Communities",
    "section": "",
    "text": "4.1 The Process\nWithin your network you may have subgroups. In a class of students, there are often smaller homework groups, study groups, friendship groups, etc.. What is the demographic composition of these groups? Do subgroups appear more in some settings compared to others? What happens to these groups over time? To answer these types of questions you need a specific analytic tool, community detection.\nAt its core, community detection is a method used to analyse the sub components(groups) of your graph. It literally detects whether there are smaller groups within a network that are more connected to each other than to others. Using mathematically informed algorithms, various community detection approaches produce measurements of how many sub groups there are in your graph and how cohesive those subgroups are.\nFor this tutorial let‚Äôs use the Grime collaboration network data. This dataset is taken from the Spotify profiles of Grime artists. Nodes are the artists themselves while the edges represent collaborations. First, you need to bring in the data from 2008 and clean up the graph a bit before we dive in. This network is directed, meaning that incoming collaborations represent featuring artists on a host‚Äôs profile. Outgoing collaborations reflect an artist appearing on another‚Äôs profile. However, for the sake of this tutorial, we will ignore this particular feature of the graph (you will read why) treating ties simply as ‚Äòcollaboration.‚Äô\nLet‚Äôs get familiar with how to perform community detection. In this section, I will be using the Louvain algorithm since it is one of the more commonly known and comprehensible. To do so, use the cluster_lourvain() command. Please note, your network may not work with Louvain because it only works with undirected networks (hence why I brought the Grime network in as undirected). In fact, only a few community detection algorithms work well with directed networks (e.g.¬†cluster_infomap() and cluster_edge_betweenness()).\nIt is strongly recommended that when you run the community detection that you put the information into an object. Then you can take a look at what is has in it.\nlouv &lt;- cluster_louvain(grime_08_clean)\nGreat, but now let‚Äôs focus on understanding what this actually means!",
    "crumbs": [
      "Analysis",
      "<span class='chapter-number'>4</span>¬† <span class='chapter-title'>Communities</span>"
    ]
  },
  {
    "objectID": "Communities.html#the-process",
    "href": "Communities.html#the-process",
    "title": "4¬† Communities",
    "section": "",
    "text": "4.1.1 Understanding the Metrics\nRemember the example of the homework/friendship groups that might exist among a class of students? Well, using this measure we can get an idea of how many of these subgroups exist in this network, and how ‚Äútightly knit‚Äù these groups really are.\n\nlouv\n\nIGRAPH clustering multi level, groups: 17, mod: 0.61\n+ groups:\n  $`1`\n  [1] \"Asher D\"        \"Scorcher\"       \"Flowdan\"        \"Tinchy Stryder\"\n  [5] \"Frisco\"         \"Kano\"           \"Wiley\"          \"Lauren Mason\"  \n  \n  $`2`\n  [1] \"Dizzee Rascal\"\n  \n  $`3`\n  [1] \"Lethal Bizzle\"\n  \n  + ... omitted several groups/vertices\n\n\nOur new object, louv, shows us that the algorithm has detected 17 subgroups (more on this later) and that the network has a modularity score of 0.61. Then, this lists the separate groups with all their memebers assigning each node a membership into one of the groups.\nModularity is a score of how separated, or modular, the network is indicating how cohesive the groups are compared to the whole network. Put simply, modularity measures the density of each group compared to the density inside the group. The statistic is measured from -1/2 to +1 with metrics closer to 1 indicating higher modularity. It is a measurement that compares what we expect to see if the graph were completely random with what is actually observed. Use modularity(). The modularity of this network is 0.61 (rounded) which indicates that the subgroups in this network are pretty distinct!\n\nmodularity(louv)\n\n[1] 0.6084184\n\n\nMeanwhile, membership is a vector showing which group each node is classed in. This will come in very handy for you if you want to export this information or use it for visualisations. Use membership().\n\nmembership(louv)\n\n        Asher D   Dizzee Rascal   Lethal Bizzle        Scorcher     Bless Beats \n              1               2               3               1               4 \n        Flowdan  Tinchy Stryder          Frisco            Kano     Treble Clef \n              1               1               1               1               5 \n        Shystie          Blacks         Badness         Chronik         Tempa T \n              6               7               7               7               7 \nNewham Generals          Skepta             JME            Chip             BBK \n              7               7               7               8               4 \nVirus Syndicate          Ghetts        Mercston        Double S        Griminal \n              9              10              11               8               8 \n        Ice Kid Nu Brand Flexxx       Wretch 32           Wiley  Bossman Birdie \n              8              12               8               1              13 \n    The Streets            Sway    Tinie Tempah           Giggs          Jammer \n             14              15              16              17               7 \n      Roll Deep          Devlin        P Money     Lauren Mason     Milli Major \n              4              10               8               1              13 \n\n\nThere are three main uses for these metrics. First, we can visualise the network indicating where the communities are and who is in each community. Second, you may wish to describe these communities a little more. Are some communities filled with popular people in the group? Are there more men than women in certain communities? If so, are these groups more successful? In the instance of Grime music, is there something specific about their music that distinguishes them from other groups that might inform who they collaborate with? Third, say you have networks over time, you might wish to measure the modularity of this network over time. Over time, does a network become more modular (indicating greater insulation among these subgroups).",
    "crumbs": [
      "Analysis",
      "<span class='chapter-number'>4</span>¬† <span class='chapter-title'>Communities</span>"
    ]
  },
  {
    "objectID": "Communities.html#visualising-communities",
    "href": "Communities.html#visualising-communities",
    "title": "4¬† Communities",
    "section": "4.2 Visualising Communities",
    "text": "4.2 Visualising Communities\nThere are two main ways to visualise communities in the network. First is to change the colours of the nodes to match the community they are in. To do this, you first set community membership as a node level characteristic in the graph. Then, using ggraph() we can change the node colours to reflect their group membership.\n\nV(grime_08_clean)$louv &lt;- membership(louv)\n\nggraph(grime_08_clean, layout = \"fr\") +  \n  geom_edge_link(color = \"grey\") +\n  geom_node_point(aes(color = as.factor(louv)), \n                  size = 5, show.legend = FALSE) +\n  geom_node_text(aes(label = louv), \n                 color = \"black\", size = 3, repel = FALSE) +\n  theme_void()\n\n\n\n\n\n\n\n\nSecond, you can use polygons to demonstrate the boundaries of the communities. To do this, you plot the clustering object alongside the graph object. Note, that this method is arguably the most desirable since colours aren‚Äôt always the easiest to distinguish.\n\nggraph(grime_08_clean, layout = \"fr\") +  \n  geom_edge_link(color = \"grey\") +\n  geom_node_point(aes(color = as.factor(louv)), \n                  size = 5, show.legend = FALSE) +\n  geom_node_text(aes(label = louv), \n                 color = \"black\", size = 3, repel = FALSE) +\n  geom_mark_hull(aes(x = x, y = y, group = louv, fill = as.factor(louv)), \n                 concavity = 5, expand = unit(3, \"mm\"), alpha = 0.25,\n                 show.legend = FALSE) +\n  theme_void()\n\n\n\n\n\n\n\n\nAnother thing to notice is that some of the isolates share colours with others in the network. This is because Rstudio only uses a set number of colours by default. It may be misleading in your report if you include isolates in your network since it appears as if they are in the same community. This is false!!! You may want to clean your network a bit more when presenting these visuals, then (more later).",
    "crumbs": [
      "Analysis",
      "<span class='chapter-number'>4</span>¬† <span class='chapter-title'>Communities</span>"
    ]
  },
  {
    "objectID": "Communities.html#analysing-the-communities.",
    "href": "Communities.html#analysing-the-communities.",
    "title": "4¬† Communities",
    "section": "4.3 Analysing the communities.",
    "text": "4.3 Analysing the communities.\nYou may wish to describe the nature of these communities. A basic example is just to take a look at their characteristics like average the nodal degree in each community to see if certain groups have higher degree than others (i.e.¬†are filled with more popular artists). In the following chunk, I make a data frame in an object called node data. This data frame has the membership from the louvain algorithm and the nodes‚Äô degree. Then, I present a variable (not saved in the dataframe) called mean_degree which presents the mean degree of each community.\n\nnode_data &lt;- data.frame(\n  deg = degree(grime_08_clean),\n  subgroup = louv$membership\n)\n\nnode_data %&gt;%\n     group_by(subgroup) %&gt;%\n     summarise(mean_degree = mean(deg, na.rm = TRUE))\n\n# A tibble: 17 √ó 2\n   subgroup mean_degree\n      &lt;dbl&gt;       &lt;dbl&gt;\n 1        1        2.12\n 2        2        0   \n 3        3        0   \n 4        4        1.67\n 5        5        0   \n 6        6        0   \n 7        7        2.12\n 8        8        2.17\n 9        9        0   \n10       10        1   \n11       11        0   \n12       12        0   \n13       13        1   \n14       14        0   \n15       15        0   \n16       16        0   \n17       17        0   \n\n\nWhat does this new table tell you about each community?\nYou can do many different descriptive analyses of these communities. Let‚Äôs say you have some node-level characteristics like their gender. you can examine the percentage of men/women in each community to see if gender may be associated with one group more than another.",
    "crumbs": [
      "Analysis",
      "<span class='chapter-number'>4</span>¬† <span class='chapter-title'>Communities</span>"
    ]
  },
  {
    "objectID": "Communities.html#clean-your-graph",
    "href": "Communities.html#clean-your-graph",
    "title": "4¬† Communities",
    "section": "4.4 Clean your graph",
    "text": "4.4 Clean your graph\nBefore we go any further and compare the modularity of Grime networks over time, one thing you need to think about when detecting communities in your graph is its structure/composition. How your graph is structured might strongly impact the findings you get from your community detection.\nIn 2008, there were a lot of Grime artists who did not collaborate with anyone else (isolates). If we were to run a community detection algorithm on the graph with all the isolates still in the graph, they would be included in the algorithms mathematics.\nFor example, let‚Äôs re-run the analysis using the Louvain algorithm without the isolates and you will see what a difference it makes visually. To do this, you will delete the isolates from the network and the plot it.\n\ngrime_isol &lt;-delete_vertices(grime_08_clean, which(degree(grime_08_clean)==0))\n\n\nggraph(grime_isol, layout = \"fr\") +  \n  geom_edge_link(color = \"grey\") +\n  geom_node_point(aes(color = \"firebrick1\", ), show.legend = FALSE, size = 5) +\n  theme_void()\n\n\n\n\n\n\n\n\nNow take the louvain on this network and take a look at it.\n\nlouv_isol &lt;- cluster_louvain(grime_isol)\n\nlouv_isol\n\nIGRAPH clustering multi level, groups: 6, mod: 0.61\n+ groups:\n  $`1`\n  [1] \"Asher D\"        \"Scorcher\"       \"Flowdan\"        \"Tinchy Stryder\"\n  [5] \"Frisco\"         \"Kano\"           \"Wiley\"          \"Lauren Mason\"  \n  \n  $`2`\n  [1] \"Bless Beats\" \"BBK\"         \"Roll Deep\"  \n  \n  $`3`\n  [1] \"Blacks\"          \"Badness\"         \"Chronik\"         \"Tempa T\"        \n  [5] \"Newham Generals\" \"Skepta\"          \"JME\"             \"Jammer\"         \n  + ... omitted several groups/vertices\n\n\nThe number of groups has reduced from 17 to 6. This shows that the first algorithm counted the isolates as groups. This becomes even more apparent when we plot the network.\nNotice, however, that modularity does not change.\n\nV(grime_isol)$louv &lt;- membership(louv_isol)\n\nggraph(grime_isol, layout = \"fr\") +  \n  geom_edge_link(color = \"grey\") +\n  geom_node_point(aes(color = as.factor(louv)), \n                  size = 5, show.legend = FALSE) +\n  geom_node_text(aes(label = louv), \n                 color = \"black\", size = 3, repel = FALSE) +\n  theme_void()\n\n\n\n\n\n\n\nggraph(grime_isol, layout = \"fr\") +  \n  geom_edge_link(color = \"grey\") +\n  geom_node_point(aes(color = as.factor(louv)), \n                  size = 5, show.legend = FALSE) +\n  geom_node_text(aes(label = louv), \n                 color = \"black\", size = 3, repel = FALSE) +\n  geom_mark_hull(aes(x = x, y = y, group = louv, fill = as.factor(louv)), concavity = 5, expand = unit(3, \"mm\"), alpha = 0.25,\n                 show.legend = FALSE) +\n  theme_void()\n\n\n\n\n\n\n\n\nNow we do not have the isolates in, it is a much less confusing (noisy) visualisation.",
    "crumbs": [
      "Analysis",
      "<span class='chapter-number'>4</span>¬† <span class='chapter-title'>Communities</span>"
    ]
  },
  {
    "objectID": "Communities.html#modularity-overtime",
    "href": "Communities.html#modularity-overtime",
    "title": "4¬† Communities",
    "section": "4.5 Modularity Overtime",
    "text": "4.5 Modularity Overtime\nYou might want to see if a group becomes more or less cohesive over time. In this case, do Grime artists segment into smaller groups as time goes on? One way to measure this, is to track the modularity of the network over time. To do this, let‚Äôs bring in two more years of these data and observe the changes in modularity over that period. Note, for the sake of cleaner visualisations, the isolates are cleaned in the following chunk.\n\ngrime_edge_list &lt;- load_data(\"GRIME_2010_Edge.csv\", header = TRUE)\ngrime_10 &lt;- graph_from_data_frame(d= grime_edge_list, directed = FALSE)\ngrime_10_clean &lt;- delete.edges(grime_10, E(grime_10)[which_loop(grime_10)])\ngrime_10_clean &lt;-delete_vertices(grime_10_clean, which(degree(grime_10_clean)==0))\n\n\ngrime_edge_list &lt;- load_data(\"GRIME_2012_Edge.csv\", header = TRUE)\ngrime_12 &lt;- graph_from_data_frame(d= grime_edge_list, directed = FALSE)\ngrime_12_clean &lt;- delete.edges(grime_12, E(grime_12)[which_loop(grime_12)])\ngrime_12_clean &lt;-delete_vertices(grime_12_clean, which(degree(grime_12_clean)==0))\n\nNow run louvain on these two new networks following the procedure you have followed so far to set the memberhsip as a node level characteristic.\n\nlouv_10 &lt;- cluster_louvain(grime_10_clean)\nV(grime_10_clean)$louv &lt;- membership(louv_10)\n\nlouv_12 &lt;- cluster_louvain(grime_12_clean)\nV(grime_12_clean)$louv &lt;- membership(louv_12)\n\nThen you can plot all three networks to take a look at the communities.\n\ng8 &lt;- ggraph(grime_isol, layout = \"fr\") +  \n  geom_edge_link(color = \"grey\") +\n  geom_node_point(aes(color = as.factor(louv)), \n                  size = 5, show.legend = FALSE) +\n  geom_node_text(aes(label = louv), \n                 color = \"black\", size = 3, repel = FALSE) +\n  geom_mark_hull(aes(x = x, y = y, group = louv, fill = as.factor(louv)), concavity = 5, expand = unit(3, \"mm\"), alpha = 0.25,\n                 show.legend = FALSE) +\nggtitle(paste(\"Modularity =\", round(louv$modularity, 1))) +\n  theme_void()\n\n\ng10 &lt;- ggraph(grime_10_clean, layout = \"fr\") +  \n  geom_edge_link(color = \"grey\") +\n  geom_node_point(aes(color = as.factor(louv)), \n                  size = 5, show.legend = FALSE) +\n  geom_node_text(aes(label = louv), \n                 color = \"black\", size = 3, repel = FALSE) +\n  geom_mark_hull(aes(x = x, y = y, group = louv, fill = as.factor(louv)), concavity = 5, expand = unit(3, \"mm\"), alpha = 0.25,\n                 show.legend = FALSE) +\nggtitle(paste(\"Modularity =\", round(louv_10$modularity, 1))) +\n  theme_void()\n\ng12 &lt;- ggraph(grime_12_clean, layout = \"fr\") +  \n  geom_edge_link(color = \"grey\") +\n  geom_node_point(aes(color = as.factor(louv)), \n                  size = 5, show.legend = FALSE) +\n  geom_node_text(aes(label = louv), \n                 color = \"black\", size = 3, repel = FALSE) +\n  geom_mark_hull(aes(x = x, y = y, group = louv, fill = as.factor(louv)), concavity = 5, expand = unit(3, \"mm\"), alpha = 0.25,\n                 show.legend = FALSE) +\nggtitle(paste(\"Modularity =\", round(louv_12$modularity, 1))) +\n  theme_void()\n\ng8 + g10 + g12\n\n\n\n\n\n\n\n\nTake a look at the modularity score and each community over time. What are some observations that you can make? The total number of nodes has clearly grown indicating that there are more artists collaborating with each other in the genre. At the same time, modularity and number of subgroups within the network remains relatively stable. This suggests that the new artists coming into the genre are joining these groups within the genre. Perhaps there are specific sub genres of Grime that new artists join.",
    "crumbs": [
      "Analysis",
      "<span class='chapter-number'>4</span>¬† <span class='chapter-title'>Communities</span>"
    ]
  },
  {
    "objectID": "Communities.html#comparing-algorithms",
    "href": "Communities.html#comparing-algorithms",
    "title": "4¬† Communities",
    "section": "4.6 Comparing algorithms",
    "text": "4.6 Comparing algorithms\nAs a researcher, you may want to try different algorithms to determine which tells the story of your network. This section shows you four different algorithms. The onus is on you to ensure you understand what the algorithms do and why they may produce slightly different results.\n\nwt &lt;- cluster_walktrap(grime_isol)\nV(grime_isol)$wt &lt;- membership(wt)\n\nle &lt;- cluster_leading_eigen(grime_isol)\nV(grime_isol)$le &lt;- membership(le)\n\nedge &lt;- cluster_edge_betweenness(grime_isol)\nV(grime_isol)$edge &lt;- membership(edge)\n\nset.seed(123)\ng8_louv &lt;- ggraph(grime_isol, layout = \"fr\") +  \n  geom_edge_link(color = \"grey\") +\n  geom_node_point(aes(color = as.factor(louv)), \n                  size = 5, show.legend = FALSE) +\n  geom_node_text(aes(label = louv), \n                 color = \"black\", size = 3, repel = FALSE) +\n  ggtitle(\"Louvain\") +\n  theme_void()\n\nset.seed(123)\ng8_wt &lt;- ggraph(grime_isol, layout = \"fr\") +  \n  geom_edge_link(color = \"grey\") +\n  geom_node_point(aes(color = as.factor(wt)), \n                  size = 5, show.legend = FALSE) +\n  geom_node_text(aes(label = wt), \n                 color = \"black\", size = 3, repel = FALSE) +\n  ggtitle(\"Walktrap\")+\n  theme_void()\n\nset.seed(123)\ng8_le &lt;- ggraph(grime_isol, layout = \"fr\") +  \n  geom_edge_link(color = \"grey\") +\n  geom_node_point(aes(color = as.factor(le)), \n                  size = 5, show.legend = FALSE) +\n  geom_node_text(aes(label = le), \n                 color = \"black\", size = 3, repel = FALSE) +\n  ggtitle(\"Leading Eidgen\") +\n  theme_void()\n\nset.seed(123)\ng8_edge &lt;- ggraph(grime_isol, layout = \"fr\") +  \n  geom_edge_link(color = \"grey\") +\n  geom_node_point(aes(color = as.factor(edge)), \n                  size = 5, show.legend = FALSE) +\n  geom_node_text(aes(label = edge), \n                 color = \"black\", size = 3, repel = FALSE) +\n  ggtitle(\"Edge Between\") +\n  theme_void()\n\ng8_louv + g8_wt + g8_le + g8_edge\n\n\n\n\n\n\n\n\nIn this case, you have complete consensus across multiple algorithms. This is rare, but should build confidence in your analysis.",
    "crumbs": [
      "Analysis",
      "<span class='chapter-number'>4</span>¬† <span class='chapter-title'>Communities</span>"
    ]
  },
  {
    "objectID": "summary.html",
    "href": "summary.html",
    "title": "10¬† Summary",
    "section": "",
    "text": "In summary, this book has no content whatsoever.\n\n1 + 1\n\n[1] 2",
    "crumbs": [
      "Conclusions",
      "<span class='chapter-number'>10</span>¬† <span class='chapter-title'>Summary</span>"
    ]
  },
  {
    "objectID": "Network Data.html",
    "href": "Network Data.html",
    "title": "1¬† Network Data",
    "section": "",
    "text": "1.1 One Mode Networks\nWhat does it mean for a network to be ‚Äòone mode?‚Äô If you have a one mode network then your network consists of nodes that are of the same type connected to each other by some kind of tie. The ‚Äòtype‚Äô or ‚Äòmode‚Äô of node refers to the unit of the node or what the node represents. Your network could represent people, countries, or organisations etc.. A one mode network, by definition, means that every node in your network of people are people. One mode network data are always stored as an edgelist or an adjacency matrix.",
    "crumbs": [
      "Orientation",
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Network Data</span>"
    ]
  },
  {
    "objectID": "Network Data.html#one-mode-networks",
    "href": "Network Data.html#one-mode-networks",
    "title": "1¬† Network Data",
    "section": "",
    "text": "1.1.1 Edgelists\nNetwork data may be stored as an edgelist. An edgelist is a very simple data structure that includes a list of relationships between the nodes in your network. An edgelist, at its most basic, has two columns, one for the sender and another for the receiver. If there is a connection between nodes in the network then they are listed in the columns. For example, A might say they are connected to B. If so, A would appear in the first column (the ‚ÄòFrom‚Äô column) and B would appear in the second column (the ‚ÄòTo‚Äô column). Data in an edgelist are are stored, therefore, as pairs (known as dyads). R treats each dyad as reflecting a tie.\nFollow the logic of the chunk below. In this chunk you create a vector called source with the names of those who are ‚Äúsending‚Äù the connection. Then another called ‚ÄúTarget‚Äù with the names of those who are ‚Äúreceiving‚Äù the connection. Note that the order of the names (the senders) in the object Source corresponds to the order of the names (the receivers). This is very important since this is supposed to represent the tie that exists between the individuals.\nLooking at the chunk below, then you start in the left and read to the right. Robert (first name in the Source object) is connected to Roland (first name in the Target object) and so on. Notice that the names sometimes repeat? This is because they have more than one connection in the network.\n\nSource &lt;- c(\"Robert\", \"George\", \"Albert\", \"Albert\", \"Henrietta\", \"Henrietta\", \"Roland\", \"Charles\") \n\nTarget &lt;- c(\"Roland\", \"Allison\", \"Henrietta\", \"Roland\", \"George\", \"Allison\", \"Charles\", \"Roland\")\n\nNow we have those two vectors made, we can construct an edgelist which is usually stored in a data frame. We use the data.frame() function to create a new object, edgelist, which compiles our network data into one table. One column, from, is made from our Source object. The other column, to, is made from the Target object.\n\nedgelist &lt;- data.frame(   \n  from = Source,   \n  to = Target)  \n\nprint(edgelist)\n\n       from        to\n1    Robert    Roland\n2    George   Allison\n3    Albert Henrietta\n4    Albert    Roland\n5 Henrietta    George\n6 Henrietta   Allison\n7    Roland   Charles\n8   Charles    Roland\n\n\nNow we can make a network out of this data frame using igraph‚Äôs graph_from_data_frame() function. Then, we can visualise it using the plot() function.\n\ng &lt;- graph_from_data_frame(edgelist)  \n\nset.seed(123) # helps R use the snae plot coordinates each time\nplot(g)\n\n\n\n\n\n\n\n\nYour first network!! Well done üòÅ\nOne final note about edgelists is that you might have more information about the edges than just who it is between. Let‚Äôs say you may have information about how frequently these individuals interact (5 times a week, once a week etc.), you can add a column to your edgelist reflecting that weight. You might also have categorical information about the edge (e.g.¬†is the tie is ‚Äòpositive‚Äô or ‚Äònegative‚Äô). Again, you can add a column. If there is any information about the connections between the individuals, you can add them to your edgelist.\n\n\n1.1.2 Adjacency Matrices\nThe second, perhaps less intuitive way, that network data are structured are as an adjacency matrix. Briefly put, a matrix is a two dimensional data set that is stored into rows and collumns. The rows (called i in network analysis) are the names of those who are ‚Äúsending.‚Äù The columns (called j in network analysis) are the names of those receiving. In a one mode network, the names of individuals in the rows mirror the names of those in the columns.\nSo, we have the names of those in the network in the rows and the columns, but where do the ties come from? In each cell of the matrix (the coordinates of the matrix) you signal if there is a tie between the people row and column of that matrix associated with that cell. A ‚Äò1‚Äô indicates a tie and a ‚Äò0‚Äô indicates no tie.\nTo demonstrate what this looks like, let‚Äôs reconstruct the same network from above but from an adjacency matrix. To do this, you can use a function from the igraph package called as_adjacency_matrix() (yes there is also a as_edgelist() function) which will convert our existing network object into an adjacency matrix.¬†Then we can take a look at it.\n\nmatrix &lt;- as_adjacency_matrix(g, sparse = FALSE)\n\nmatrix\n\n          Robert George Albert Henrietta Roland Charles Allison\nRobert         0      0      0         0      1       0       0\nGeorge         0      0      0         0      0       0       1\nAlbert         0      0      0         1      1       0       0\nHenrietta      0      1      0         0      0       0       1\nRoland         0      0      0         0      0       1       0\nCharles        0      0      0         0      1       0       0\nAllison        0      0      0         0      0       0       0\n\n\nSo, you will see the names of everyone in your network in both the rows and columns. Where there are ties between the people there are ones. Notice that there are coordinates in the matrix where the individual overlaps with themselves, this is called the ‚Äòdiagonal.‚Äô For example, Robert and Robert. A ‚Äò1‚Äô in that cell would indicate that Robert is connected to themselves (known as a selfloop). More often than not, this should be a ‚Äò0‚Äô since self loops are usually meaningless.\nNow, you can create a new network object (call it g2) using a slightly different function than before - graph_from_adjacency_matrix(). Note, if you pull data from a different source, say from a .csv, you need to ensure that R recognises it as a matrix. To do so, use as.matrix() before creating your network.\n\ng2 &lt;- graph_from_adjacency_matrix(matrix, diag = FALSE)\n\nset.seed(123)\nplot(g2)\n\n\n\n\n\n\n\n\nYour second network!!!! üòÅ\n\n\n1.1.3 Closing on One Mode Networks\nRight, you have now created two networks! Well, the same network twice, but let‚Äôs gloss over that. The main thing you need to take away from this section is that networks can be created from an edgelist or an adjacency matrix. When collecting or using network data, make sure you know whether you are working with an edgelist or an adjacency matrix.\nTo convert an edgelist into a network object using igraph you use graph_from_data_frame(). Conversely, to convert an adjacency matrix use graph_from_adjacency_matrix().",
    "crumbs": [
      "Orientation",
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Network Data</span>"
    ]
  },
  {
    "objectID": "Network Data.html#two-mode-network",
    "href": "Network Data.html#two-mode-network",
    "title": "1¬† Network Data",
    "section": "1.2 Two Mode Network",
    "text": "1.2 Two Mode Network\nWhat does it mean for a network to be ‚Äòtwo mode?‚Äô Well, you may have guess by now, however, in the spirit of being thorough, let‚Äôs dive in. If you have a two mode network then you have two different types of node connected to each other. For example, your network could be comprised of individuals connected to groups or words connected to documents. The important thing to know is that your two types of node must be absolutely distinct. In other words, let‚Äôs say you have individuals and groups, there must not be any cross over. Additionally, there must not be any cross over of ties. Individuals cannot be connected to other individuals nor groups to other groups.\nOnce again, two mode network data can be stored as an edgelist or an adjacency matrix. Let‚Äôs use the names of those in the previous networks, only this time, instead of being connected to each other, the ties reflect their TV subscriptions.\n\n1.2.1 Edgelists\nA two mode network stored as an edgelist is structured the same way as a one mode network. However, this time, one column (the ‚Äòfrom‚Äô column) has the individuals and the other (the ‚Äòto‚Äô column) has the groups.\n\nindividuals &lt;- c(\"Robert\", \"Robert\", \"Robert\", \"Robert\", \"George\", \"George\",\"George\", \"Albert\", \"Albert\", \"Henrietta\", \"Henrietta\", \"Roland\", \"Roland\", \"Roland\", \"Roland\", \"Roland\", \"Charles\") \n\ngroups &lt;- c(\"ESPN\", \"Hulu\", \"AMAZON\", \"Disney+\", \"Netflix\", \"AMAZON\", \"Disney+\", \"ESPN\", \"Disney+\", \"Hulu\", \"Netflix\", \"ESPN\", \"Hulu\", \"AMAZON\", \"Disney+\", \"Netflix\", \"Hulu\")\n\n\ntm_edge &lt;- data.frame(   \n  i = individuals,   \n  g = groups)  \n\nprint(tm_edge)\n\n           i       g\n1     Robert    ESPN\n2     Robert    Hulu\n3     Robert  AMAZON\n4     Robert Disney+\n5     George Netflix\n6     George  AMAZON\n7     George Disney+\n8     Albert    ESPN\n9     Albert Disney+\n10 Henrietta    Hulu\n11 Henrietta Netflix\n12    Roland    ESPN\n13    Roland    Hulu\n14    Roland  AMAZON\n15    Roland Disney+\n16    Roland Netflix\n17   Charles    Hulu\n\n\nNow you have a two mode edgelist there are a few things we need to do. The first is familiar to you since you use the same function to create a two mode network as a one mode network from an edgelist. First, you use graph_from_data_frame() to create the network object g_tm. However, this object, as it is, appears as a one mode network. R needs to know that there are two types of node.\nTo do this, you can create a node characteristic to differentiate one from the other (individuals from groups). Igraph has a function that helps do this. bipartite_mapping() is a function that, in essence, searches your network and identifies one type (stored as FALSE or 0) and another type (stored as TRUE or 1). This is precisely why you must have distinct node types in each column. Otherwise igraph would not be able to recognise the individuals from the groups!\nFinally, you use the vertex.color option to differentiate the individuals from the groups in your visualisation. Not to worry, more on that in CHAPTER X.\n\n# Make the network object\ng_tm &lt;- graph_from_data_frame(tm_edge)\n\n#Identify the two node types\nV(g_tm)$type &lt;- bipartite_mapping(g_tm)$type\n\n# Visualise\nset.seed(123)\nplot(g_tm, vertex.color = V(g_tm)$type)\n\n\n\n\n\n\n\n\n\n\n1.2.2 Adjacency Matrices\nTwo Mode adjacency matrices are a little bit different from one more adjacency matrices. A two mode matrix (also known as an incidence, affiliation, or bipartite matrix) has rows for the individuals (i) and columns for the groups (g). The cells are still filled with ‚Äò1‚Äô and ‚Äò0‚Äô to indicate an individual is connected to a group. For obvious reasons, there is not a diagonal on this type of matrix since the rows and columns are distinct. No overlap means no self loops.\nYou can convert the two mode network you have been working on into a matrix using igraph‚Äôs as_biadjacency_matrix() function. Then you can view it. It is as you expect. Robert and gang are in the rows and each column is filled with the TV subscriptions from the original network.\n\ntm_matrix &lt;- as_biadjacency_matrix(g_tm, sparse = FALSE)\n\ntm_matrix\n\n          ESPN Hulu AMAZON Disney+ Netflix\nRobert       1    1      1       1       0\nGeorge       0    0      1       1       1\nAlbert       1    0      0       1       0\nHenrietta    0    1      0       0       1\nRoland       1    1      1       1       1\nCharles      0    1      0       0       0\n\n\nNow this is ready to be converted into a network object. You do so using graph_from_biadjacency_matrix() from igraph. Since a matrix obviously has two types of mode (the rows and columns are different), igraph can easily create a two mode network from these data. So there is no need to using the mapping that you use before.\n\ng_tm2 &lt;- graph_from_biadjacency_matrix(tm_matrix)\n\nset.seed(123)\nplot(g_tm2, vertex.color = V(g_tm2)$type)",
    "crumbs": [
      "Orientation",
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Network Data</span>"
    ]
  },
  {
    "objectID": "Network Data.html#on-network-data",
    "href": "Network Data.html#on-network-data",
    "title": "1¬† Network Data",
    "section": "1.3 On Network Data",
    "text": "1.3 On Network Data\nSo, network data (both one or two mode) are stored as either an edgelist or an adjacency matrix. However, do all network data start that way? The short answer is no, they don‚Äôt. The long answer is fleshed out in CHAPTER X where you will learn more about network data collection. However, suffice it to say that you might need to think outside the box when you are working with network-based research. You may have survey data, observational data, or even time-diary data that you are working with. Eventually, you will need to clean your data in such a way that they end up in either of these two formats. How you get there is beyond this handbook. However, be mindful, that whatever process you use does not inadvertently cause you missing data (i.e.¬†you leave people or ties out during your cleaning process).\nA second thing to be mindful of is that network data, especially social network data, are quite personal. This introduces ethical issues and validity issues for any study you are performing even if you are using secondary data. The ethical issue is that you must be mindful that these data are inherently relational and therefore present risk of reputation to the respondent. Where possible pseudonyms or identification is absolutely advisable! Additionally, consider he context of your data. If your network reflects friendship or trust among workmates, people may feel pressured to say they all trust the boss. Further, to appear popular, they might overestimate how connected they are. While this isn‚Äôt a huge issue - one‚Äôs perception of how well connected they are is still very useful - it is something for you to consider and perhaps address as a potential limitation of your data.\nThe boundary of your data is imperative to understand‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶",
    "crumbs": [
      "Orientation",
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Network Data</span>"
    ]
  },
  {
    "objectID": "Advanced Visualisation - Interactive.html",
    "href": "Advanced Visualisation - Interactive.html",
    "title": "7¬† Interactive Networks Visualisations",
    "section": "",
    "text": "7.1 Interactive networks using visNetwork\nSo far, we have worked only on static visualisations but there are other ways you can present network data that are a little more fun and can be more instructive. In this chapter we are going to work on two interactive networks and discuss the utility of both. There are multiple packages in R that help you put together interactive visualisations using the visnetwork and threejs packages. For a more complete tutorial on some others, take a look at Katya Ognyanova‚Äôs website.\nFirst, we will be using the visnetwork to create a network visualisation that you can click on, move and view labels one at a time. To do this, we are going to use the data I put together previously that we have used when working on node and edge characteristics. Like in that tutorial, you will need to set your own working directory for the below code to run and pull in each sheet.\nvertices.df &lt;- load_data(\"Node data.csv\")\nedges.df &lt;- load_data(\"Edge data.csv\")\nLet‚Äôs take a look at these objects so you can see how these data are structured. You will see that the vertices.df object has a few node characteristics that help describe those in the network. The edges.df object contains the connections between the nodes in the network and some information about those connections. These will all come into play as we construct our interactive networks based on it.\nhead(vertices.df)\n\n  name age role gender\n1    A  20   DJ      F\n2    B  25   MC      M\n3    C  21   DJ      F\n4    D  23 crew      M\n5    E  24   MC      M\n6    F  23   MC      F\n\nhead(edges.df)\n\n  from to freq affinity\n1    A  B    2      pos\n2    A  C    1      neg\n3    A  D    1      pos\n4    A  E    1      neg\n5    A  F    3      neg\n6    E  F    2      pos\nThe visNetwork package requires that our each node has a unique ID. This ID is not separate from the network (i.e.¬†a row number in a dataframe), rather, this unique ID MUST MATCH the names of the vertices. THIS IS IMPORTAT. If you are to create this type of network, you will need both the edge information and the node information. Remember, the latter, the node information, can simply consist of just an id column. So, if you are working with a network that only has a an adjacency matrix or a network, you can create a dataframe that has the other half you need - a dataframe with the node id (names).\nIn our case, we have a network that I have created that has both of these separate dataframes that we can use to create our network. First, we need the aforementioned ID for each node. In this case, we can use the rename() function from the dplyr package to rename the column ‚Äòname‚Äô to id. The visNetwork package can now detect the unique ids that define each node.\nvertices.df &lt;- vertices.df %&gt;%\n  rename(id = name)\nNow that our data is structured in the correct format, we can use the visnNetwork() argument to create our interactive network! Outside of markdown, if you are working in a script file, this will appear in the viewer window of your Rstudio. Here, however, it will appear in a widget below the code chunk. Play around with the network. You can scroll in and out. Select and move a node around in the network.\nvisNetwork(vertices.df, edges.df)\nThe package visNetwork requires that you have certain variables available to it in order for the visualisation to reflect the information you have. Below, I demonstrate the label, title, and shadow options. Label does what you expect, it labels the nodes. The above visualisation does not have labels because visNetwork did not find a column in the vertices.df that is called label. Title is an option that enables you to click on the node and get more information about it. Shadow shows a small shadow behind the node - you can set this as TRUE or FALSE.\nBelow, I set the label as the id. To do this, I have to ensure that R recognises these as strings or characters. Hence I use the as.character() function. Then, I set the title of the node to reflect the node‚Äôs gender. Then, for fun, I like the shadows!!\nvertices.df$label &lt;- as.character(vertices.df$id)\nvertices.df$title &lt;- vertices.df$gender\nvertices.df$shadow &lt;- TRUE\nhead(vertices.df)\n\n  id age role gender label title shadow\n1  A  20   DJ      F     A     F   TRUE\n2  B  25   MC      M     B     M   TRUE\n3  C  21   DJ      F     C     F   TRUE\n4  D  23 crew      M     D     M   TRUE\n5  E  24   MC      M     E     M   TRUE\n6  F  23   MC      F     F     F   TRUE\nThe object now has these columns in it! Let‚Äôs see the visual that it creates!\nvisNetwork(vertices.df, edges.df)\nHere is a more complete visualisation using other options available to you with the visNetwork() function. The width = 100% ensures that the visualisation fills the space in the widget. The height option also does something similar. The background, main, submain, and footer options show other ways you can alter the visualisation. Fun, right??\nvisNetwork(vertices.df, edges.df, background=\"firebrick\",\n           main=\"TITLE HERE\", submain=\"SUB HERE!\")\nOne final thing that we can do is change the colours of the nodes to represent the communities they are a part of. I use the louvain algorithm with the igraph package. To do this, I create a igraph object from both data frames, run the clustering. Then I designate the ‚Äúgroup‚Äù characteristic of the vertices data frame using the membership from the clustering object. The new visual\nedges &lt;- graph_from_data_frame(d = edges.df, vertices = vertices.df, directed = F)\nclust &lt;- cluster_louvain(edges)\nvertices.df$group &lt;- as.factor(clust$membership)\n\n\nvisNetwork(vertices.df, edges.df)%&gt;%\n  visOptions(highlightNearest = T, nodesIdSelection = T)",
    "crumbs": [
      "Visualisation",
      "<span class='chapter-number'>7</span>¬† <span class='chapter-title'>Interactive Networks Visualisations</span>"
    ]
  },
  {
    "objectID": "Advanced Visualisation - Interactive.html#d-interctive-networks-with-threejs",
    "href": "Advanced Visualisation - Interactive.html#d-interctive-networks-with-threejs",
    "title": "7¬† Interactive Networks Visualisations",
    "section": "7.2 3D interctive networks with threejs",
    "text": "7.2 3D interctive networks with threejs\nIf you thought the visNetwork visualisation was cool‚Ä¶ wait till you see these ones!!\nHere we will cover a second package, threejs and create some slightly different interactive visualisations. For this one, let‚Äôs use different network data. You need an network object created in igraph. We could use the data we have been using so far by creating an igraph object the way we have been doing so ar. However, to mix things up, let‚Äôs use our familiar Grime network.\nHere I bring in the Grime 2008 edgelist, clean it and store it in an object called grime_08_clean. This process if familiar to you now. You are pros!\n\ngrime_edge_list &lt;- load_data(\"GRIME_2008_Edge.csv\", header = TRUE)\n\ngrime_08 &lt;- graph_from_data_frame(d= grime_edge_list, directed = TRUE)\nplot(grime_08)\n\n\n\n\n\n\n\ngrime_08_clean &lt;- delete.edges(grime_08, E(grime_08)[which_loop(grime_08)])\n\nHere we can create an object that threejs recognises. The function we need to use is the graphjs() that will convert your network into a 3D interactive network a bit like a molecular or planetary model. You should be able to do this with any one-mode network. In this chunk I create an object that has the 3D network called grime_08_3d. Then, I visualise it.\n\ngrime_08_3d &lt;- graphjs(grime_08_clean)\n\ngrime_08_3d\n\n\n\n\n\nWe can make this visualisation a little cleaner by deleting the isolates. To do this, I use the delete_vertices() argument from the igraph package. Then, I recreate an object, now called grime_08_isol_3d. I also add a title to our visualisation.\n\ngrime_isol &lt;- delete_vertices(grime_08_clean,  which(degree(grime_08_clean)==0))\n\ngrime_08_isol_3d &lt;- graphjs(grime_isol, main=\"Grime 2008!\")\ngrime_08_isol_3d\n\n\n\n\n\nOkay, this is great, but we can tell a bit more of a story here. Let‚Äôs use something we are familiar with, a node attribute, to help us pull out a bit more of a story from this visualisation. I want to highlight highly central nodes in this network and change their colour if they are highly central (let‚Äôs say a degree above 3). Once again, the package threejs looks for specific characteristics of your network to visualise. One of these is the characteristic ‚Äúcolor‚Äù. In the chunk below, I use the set_vertex_attr() function from igraph to create an attribute called color that threejs can recognise. Then, I use an ifelse() statement to set the colour of highly central attributes to red and others white. For sake of comparison, I copy the grime_isol object we worked on above, to a new object called grime_isol_colour. Although, you could set the vertex attribute to the object directly. I can also set the size of the node here to further its readability. The package threejs recognises the option ‚Äòsize‚Äô as being the size of the node in the visualisation.\n\ngrime_isol_colour &lt;- grime_isol\n\ngrime_isol_colour &lt;- set_vertex_attr(grime_isol, \"color\", value = ifelse(degree(grime_isol) &gt; 3, \"red\", \"ivory\"))\n\nV(grime_isol_colour)$size &lt;- 5\n\ngrime_08_isol_3d_col &lt;- graphjs(grime_isol_colour, main=\"Major Collaborators in Grime 2008!\", bg = \"black\")\ngrime_08_isol_3d_col\n\n\n\n\n\nIf you would like to save this widget, you can do so using the savewidget() function from the htmltools package. Then you can call upon it using the browseURL function. However, in order to make this work well in a html format, you will need to use the browsable() function on the object. The chunk below should open an html page with your network.\n\ngrime_08_isol_3d_col &lt;- browsable(grime_08_isol_3d_col)\n\nsaveWidget(grime_08_isol_3d_col, file=\"grime_2008_JS.html\")\nbrowseURL(\"grime_2008_JS.html\")\n\nFinally, you can further represent elements of your graph in the 3D network. For example, you can change the colours of the nodes to reflect the membership of which community they are in. In this chunk, I use the infomap community detection algorithm to identify which communities the nodes are in. Then, I create a new node level characteristic called ‚Äúcolor‚Äù that captures which community they are in. If you have many communities, you may need to use a colour palette package like vidris or RColorBrewer,\n\ngrime_coms &lt;- grime_isol\ncl &lt;- cluster_infomap(grime_coms)\nV(grime_coms)$color &lt;- cl$membership\nV(grime_coms)$size &lt;- 5\n\ngrime_coms3D &lt;- graphjs(grime_coms,   edge.color = \"maroon\",  bg = \"white\", main = \"Communities in Grime 2008\")\ngrime_coms3D",
    "crumbs": [
      "Visualisation",
      "<span class='chapter-number'>7</span>¬† <span class='chapter-title'>Interactive Networks Visualisations</span>"
    ]
  },
  {
    "objectID": "Advanced Visualisation - Interactive.html#closing-thoughts-on-interactive-networks",
    "href": "Advanced Visualisation - Interactive.html#closing-thoughts-on-interactive-networks",
    "title": "7¬† Interactive Networks Visualisations",
    "section": "7.3 Closing Thoughts on Interactive Networks",
    "text": "7.3 Closing Thoughts on Interactive Networks\nI think these networks are cool. However, I really think they are a bit of a gimmick! Their utility is limited at best. For example, they only really work in online spaces while are completely useless in print. The click functions and maneuverable attributes of these graphs are fun to play around with, perhaps useful in grabbing the imagination of readers. However, many academic uses for network analysis is much easier to present using static graphs. Still‚Ä¶ they are loads of fun!",
    "crumbs": [
      "Visualisation",
      "<span class='chapter-number'>7</span>¬† <span class='chapter-title'>Interactive Networks Visualisations</span>"
    ]
  },
  {
    "objectID": "Communities - ggraph.html",
    "href": "Communities - ggraph.html",
    "title": "8¬† Communities",
    "section": "",
    "text": "8.1 The Process\nWithin your network you may have subgroups. In a class of students, there are often smaller homework groups, study groups, friendship groups, etc.. What is the demographic composition of these groups? Do subgroups appear more in some settings compared to others? What happens to these groups over time? To answer these types of questions you need a specific analytic tool, community detection.\nAt its core, community detection is a method used to analyse the sub components(groups) of your graph. It literally detects whether there are smaller groups within a network that are more connected to each other than to others. Using mathematically informed algorithms, various community detection approaches produce measurements of how many sub groups there are in your graph and how cohesive those subgroups are.\nFor this tutorial let‚Äôs use the Grime collaboration network data. This dataset is taken from the Spotify profiles of Grime artists. Nodes are the artists themselves while the edges represent collaborations. First, you need to bring in the data from 2008 and clean up the graph a bit before we dive in. This network is directed, meaning that incoming collaborations represent featuring artists on a host‚Äôs profile. Outgoing collaborations reflect an artist appearing on another‚Äôs profile. However, for the sake of this tutorial, we will ignore this particular feature of the graph (you will read why) treating ties simply as ‚Äòcollaboration.‚Äô\nLet‚Äôs get familiar with how to perform community detection. In this section, I will be using the Louvain algorithm since it is one of the more commonly known and comprehensible. To do so, use the cluster_lourvain() command. Please note, your network may not work with Louvain because it only works with undirected networks (hence why I brought the Grime network in as undirected). In fact, only a few community detection algorithms work well with directed networks (e.g.¬†cluster_infomap() and cluster_edge_betweenness()).\nIt is strongly recommended that when you run the community detection that you put the information into an object. Then you can take a look at what is has in it.\nlouv &lt;- cluster_louvain(grime_08_clean)\nGreat, but now let‚Äôs focus on understanding what this actually means!",
    "crumbs": [
      "Analysis",
      "<span class='chapter-number'>8</span>¬† <span class='chapter-title'>Communities</span>"
    ]
  },
  {
    "objectID": "Communities - ggraph.html#the-process",
    "href": "Communities - ggraph.html#the-process",
    "title": "8¬† Communities",
    "section": "",
    "text": "8.1.1 Understanding the Metrics\nRemember the example of the homework/friendship groups that might exist among a class of students? Well, using this measure we can get an idea of how many of these subgroups exist in this network, and how ‚Äútightly knit‚Äù these groups really are.\n\nlouv\n\nIGRAPH clustering multi level, groups: 17, mod: 0.61\n+ groups:\n  $`1`\n  [1] \"Asher D\"        \"Scorcher\"       \"Flowdan\"        \"Tinchy Stryder\"\n  [5] \"Frisco\"         \"Kano\"           \"Wiley\"          \"Lauren Mason\"  \n  \n  $`2`\n  [1] \"Dizzee Rascal\"\n  \n  $`3`\n  [1] \"Lethal Bizzle\"\n  \n  + ... omitted several groups/vertices\n\n\nOur new object, louv, shows us that the algorithm has detected 17 subgroups (more on this later) and that the network has a modularity score of 0.61. Then, this lists the separate groups with all their memebers assigning each node a membership into one of the groups.\nModularity is a score of how separated, or modular, the network is indicating how cohesive the groups are compared to the whole network. Put simply, modularity measures the density of each group compared to the density inside the group. The statistic is measured from -1/2 to +1 with metrics closer to 1 indicating higher modularity. It is a measurement that compares what we expect to see if the graph were completely random with what is actually observed. Use modularity(). The modularity of this network is 0.61 (rounded) which indicates that the subgroups in this network are pretty distinct!\n\nmodularity(louv)\n\n[1] 0.6084184\n\n\nMeanwhile, membership is a vector showing which group each node is classed in. This will come in very handy for you if you want to export this information or use it for visualisations. Use membership().\n\nmembership(louv)\n\n        Asher D   Dizzee Rascal   Lethal Bizzle        Scorcher     Bless Beats \n              1               2               3               1               4 \n        Flowdan  Tinchy Stryder          Frisco            Kano     Treble Clef \n              1               1               1               1               5 \n        Shystie          Blacks         Badness         Chronik         Tempa T \n              6               7               7               7               7 \nNewham Generals          Skepta             JME            Chip             BBK \n              7               7               7               8               4 \nVirus Syndicate          Ghetts        Mercston        Double S        Griminal \n              9              10              11               8               8 \n        Ice Kid Nu Brand Flexxx       Wretch 32           Wiley  Bossman Birdie \n              8              12               8               1              13 \n    The Streets            Sway    Tinie Tempah           Giggs          Jammer \n             14              15              16              17               7 \n      Roll Deep          Devlin        P Money     Lauren Mason     Milli Major \n              4              10               8               1              13 \n\n\nThere are three main uses for these metrics. First, we can visualise the network indicating where the communities are and who is in each community. Second, you may wish to describe these communities a little more. Are some communities filled with popular people in the group? Are there more men than women in certain communities? If so, are these groups more successful? In the instance of Grime music, is there something specific about their music that distinguishes them from other groups that might inform who they collaborate with? Third, say you have networks over time, you might wish to measure the modularity of this network over time. Over time, does a network become more modular (indicating greater insulation among these subgroups).",
    "crumbs": [
      "Analysis",
      "<span class='chapter-number'>8</span>¬† <span class='chapter-title'>Communities</span>"
    ]
  },
  {
    "objectID": "Communities - ggraph.html#visualising-communities",
    "href": "Communities - ggraph.html#visualising-communities",
    "title": "8¬† Communities",
    "section": "8.2 Visualising Communities",
    "text": "8.2 Visualising Communities\nThere are two main ways to visualise communities in the network. First is to change the colours of the nodes to match the community they are in. To do this, you first set community membership as a node level characteristic in the graph. Then, using ggraph() we can change the node colours to reflect their group membership.\n\nV(grime_08_clean)$louv &lt;- membership(louv)\n\nggraph(grime_08_clean, layout = \"fr\") +  \n  geom_edge_link(color = \"grey\") +\n  geom_node_point(aes(color = as.factor(louv)), \n                  size = 5, show.legend = FALSE) +\n  geom_node_text(aes(label = louv), \n                 color = \"black\", size = 3, repel = FALSE) +\n  theme_void()\n\n\n\n\n\n\n\n\nSecond, you can use polygons to demonstrate the boundaries of the communities. To do this, you plot the clustering object alongside the graph object. Note, that this method is arguably the most desirable since colours aren‚Äôt always the easiest to distinguish.\n\nggraph(grime_08_clean, layout = \"fr\") +  \n  geom_edge_link(color = \"grey\") +\n  geom_node_point(aes(color = as.factor(louv)), \n                  size = 5, show.legend = FALSE) +\n  geom_node_text(aes(label = louv), \n                 color = \"black\", size = 3, repel = FALSE) +\n  geom_mark_hull(aes(x = x, y = y, group = louv, fill = as.factor(louv)), \n                 concavity = 5, expand = unit(3, \"mm\"), alpha = 0.25,\n                 show.legend = FALSE) +\n  theme_void()\n\n\n\n\n\n\n\n\nAnother thing to notice is that some of the isolates share colours with others in the network. This is because Rstudio only uses a set number of colours by default. It may be misleading in your report if you include isolates in your network since it appears as if they are in the same community. This is false!!! You may want to clean your network a bit more when presenting these visuals, then (more later).",
    "crumbs": [
      "Analysis",
      "<span class='chapter-number'>8</span>¬† <span class='chapter-title'>Communities</span>"
    ]
  },
  {
    "objectID": "Communities - ggraph.html#analysing-the-communities.",
    "href": "Communities - ggraph.html#analysing-the-communities.",
    "title": "8¬† Communities",
    "section": "8.3 Analysing the communities.",
    "text": "8.3 Analysing the communities.\nYou may wish to describe the nature of these communities. A basic example is just to take a look at their characteristics like average the nodal degree in each community to see if certain groups have higher degree than others (i.e.¬†are filled with more popular artists). In the following chunk, I make a data frame in an object called node data. This data frame has the membership from the louvain algorithm and the nodes‚Äô degree. Then, I present a variable (not saved in the dataframe) called mean_degree which presents the mean degree of each community.\n\nnode_data &lt;- data.frame(\n  deg = degree(grime_08_clean),\n  subgroup = louv$membership\n)\n\nnode_data %&gt;%\n     group_by(subgroup) %&gt;%\n     summarise(mean_degree = mean(deg, na.rm = TRUE))\n\n# A tibble: 17 √ó 2\n   subgroup mean_degree\n      &lt;dbl&gt;       &lt;dbl&gt;\n 1        1        2.12\n 2        2        0   \n 3        3        0   \n 4        4        1.67\n 5        5        0   \n 6        6        0   \n 7        7        2.12\n 8        8        2.17\n 9        9        0   \n10       10        1   \n11       11        0   \n12       12        0   \n13       13        1   \n14       14        0   \n15       15        0   \n16       16        0   \n17       17        0   \n\n\nWhat does this new table tell you about each community?\nYou can do many different descriptive analyses of these communities. Let‚Äôs say you have some node-level characteristics like their gender. you can examine the percentage of men/women in each community to see if gender may be associated with one group more than another.",
    "crumbs": [
      "Analysis",
      "<span class='chapter-number'>8</span>¬† <span class='chapter-title'>Communities</span>"
    ]
  },
  {
    "objectID": "Communities - ggraph.html#clean-your-graph",
    "href": "Communities - ggraph.html#clean-your-graph",
    "title": "8¬† Communities",
    "section": "8.4 Clean your graph",
    "text": "8.4 Clean your graph\nBefore we go any further and compare the modularity of Grime networks over time, one thing you need to think about when detecting communities in your graph is its structure/composition. How your graph is structured might strongly impact the findings you get from your community detection.\nIn 2008, there were a lot of Grime artists who did not collaborate with anyone else (isolates). If we were to run a community detection algorithm on the graph with all the isolates still in the graph, they would be included in the algorithms mathematics.\nFor example, let‚Äôs re-run the analysis using the Louvain algorithm without the isolates and you will see what a difference it makes visually. To do this, you will delete the isolates from the network and the plot it.\n\ngrime_isol &lt;-delete_vertices(grime_08_clean, which(degree(grime_08_clean)==0))\n\n\nggraph(grime_isol, layout = \"fr\") +  \n  geom_edge_link(color = \"grey\") +\n  geom_node_point(aes(color = \"firebrick1\", ), show.legend = FALSE, size = 5) +\n  theme_void()\n\n\n\n\n\n\n\n\nNow take the louvain on this network and take a look at it.\n\nlouv_isol &lt;- cluster_louvain(grime_isol)\n\nlouv_isol\n\nIGRAPH clustering multi level, groups: 6, mod: 0.61\n+ groups:\n  $`1`\n  [1] \"Asher D\"        \"Scorcher\"       \"Flowdan\"        \"Tinchy Stryder\"\n  [5] \"Frisco\"         \"Kano\"           \"Wiley\"          \"Lauren Mason\"  \n  \n  $`2`\n  [1] \"Bless Beats\" \"BBK\"         \"Roll Deep\"  \n  \n  $`3`\n  [1] \"Blacks\"          \"Badness\"         \"Chronik\"         \"Tempa T\"        \n  [5] \"Newham Generals\" \"Skepta\"          \"JME\"             \"Jammer\"         \n  + ... omitted several groups/vertices\n\n\nThe number of groups has reduced from 17 to 6. This shows that the first algorithm counted the isolates as groups. This becomes even more apparent when we plot the network.\nNotice, however, that modularity does not change.\n\nV(grime_isol)$louv &lt;- membership(louv_isol)\n\nggraph(grime_isol, layout = \"fr\") +  \n  geom_edge_link(color = \"grey\") +\n  geom_node_point(aes(color = as.factor(louv)), \n                  size = 5, show.legend = FALSE) +\n  geom_node_text(aes(label = louv), \n                 color = \"black\", size = 3, repel = FALSE) +\n  theme_void()\n\n\n\n\n\n\n\nggraph(grime_isol, layout = \"fr\") +  \n  geom_edge_link(color = \"grey\") +\n  geom_node_point(aes(color = as.factor(louv)), \n                  size = 5, show.legend = FALSE) +\n  geom_node_text(aes(label = louv), \n                 color = \"black\", size = 3, repel = FALSE) +\n  geom_mark_hull(aes(x = x, y = y, group = louv, fill = as.factor(louv)), concavity = 5, expand = unit(3, \"mm\"), alpha = 0.25,\n                 show.legend = FALSE) +\n  theme_void()\n\n\n\n\n\n\n\n\nNow we do not have the isolates in, it is a much less confusing (noisy) visualisation.",
    "crumbs": [
      "Analysis",
      "<span class='chapter-number'>8</span>¬† <span class='chapter-title'>Communities</span>"
    ]
  },
  {
    "objectID": "Communities - ggraph.html#modularity-overtime",
    "href": "Communities - ggraph.html#modularity-overtime",
    "title": "8¬† Communities",
    "section": "8.5 Modularity Overtime",
    "text": "8.5 Modularity Overtime\nYou might want to see if a group becomes more or less cohesive over time. In this case, do Grime artists segment into smaller groups as time goes on? One way to measure this, is to track the modularity of the network over time. To do this, let‚Äôs bring in two more years of these data and observe the changes in modularity over that period. Note, for the sake of cleaner visualisations, the isolates are cleaned in the following chunk.\n\ngrime_edge_list &lt;- load_data(\"GRIME_2010_Edge.csv\", header = TRUE)\ngrime_10 &lt;- graph_from_data_frame(d= grime_edge_list, directed = FALSE)\ngrime_10_clean &lt;- delete.edges(grime_10, E(grime_10)[which_loop(grime_10)])\ngrime_10_clean &lt;-delete_vertices(grime_10_clean, which(degree(grime_10_clean)==0))\n\n\ngrime_edge_list &lt;- load_data(\"GRIME_2012_Edge.csv\", header = TRUE)\ngrime_12 &lt;- graph_from_data_frame(d= grime_edge_list, directed = FALSE)\ngrime_12_clean &lt;- delete.edges(grime_12, E(grime_12)[which_loop(grime_12)])\ngrime_12_clean &lt;-delete_vertices(grime_12_clean, which(degree(grime_12_clean)==0))\n\nNow run louvain on these two new networks following the procedure you have followed so far to set the memberhsip as a node level characteristic.\n\nlouv_10 &lt;- cluster_louvain(grime_10_clean)\nV(grime_10_clean)$louv &lt;- membership(louv_10)\n\nlouv_12 &lt;- cluster_louvain(grime_12_clean)\nV(grime_12_clean)$louv &lt;- membership(louv_12)\n\nThen you can plot all three networks to take a look at the communities.\n\ng8 &lt;- ggraph(grime_isol, layout = \"fr\") +  \n  geom_edge_link(color = \"grey\") +\n  geom_node_point(aes(color = as.factor(louv)), \n                  size = 5, show.legend = FALSE) +\n  geom_node_text(aes(label = louv), \n                 color = \"black\", size = 3, repel = FALSE) +\n  geom_mark_hull(aes(x = x, y = y, group = louv, fill = as.factor(louv)), concavity = 5, expand = unit(3, \"mm\"), alpha = 0.25,\n                 show.legend = FALSE) +\nggtitle(paste(\"Modularity =\", round(louv$modularity, 1))) +\n  theme_void()\n\n\ng10 &lt;- ggraph(grime_10_clean, layout = \"fr\") +  \n  geom_edge_link(color = \"grey\") +\n  geom_node_point(aes(color = as.factor(louv)), \n                  size = 5, show.legend = FALSE) +\n  geom_node_text(aes(label = louv), \n                 color = \"black\", size = 3, repel = FALSE) +\n  geom_mark_hull(aes(x = x, y = y, group = louv, fill = as.factor(louv)), concavity = 5, expand = unit(3, \"mm\"), alpha = 0.25,\n                 show.legend = FALSE) +\nggtitle(paste(\"Modularity =\", round(louv_10$modularity, 1))) +\n  theme_void()\n\ng12 &lt;- ggraph(grime_12_clean, layout = \"fr\") +  \n  geom_edge_link(color = \"grey\") +\n  geom_node_point(aes(color = as.factor(louv)), \n                  size = 5, show.legend = FALSE) +\n  geom_node_text(aes(label = louv), \n                 color = \"black\", size = 3, repel = FALSE) +\n  geom_mark_hull(aes(x = x, y = y, group = louv, fill = as.factor(louv)), concavity = 5, expand = unit(3, \"mm\"), alpha = 0.25,\n                 show.legend = FALSE) +\nggtitle(paste(\"Modularity =\", round(louv_12$modularity, 1))) +\n  theme_void()\n\ng8 + g10 + g12\n\n\n\n\n\n\n\n\nTake a look at the modularity score and each community over time. What are some observations that you can make? The total number of nodes has clearly grown indicating that there are more artists collaborating with each other in the genre. At the same time, modularity and number of subgroups within the network remains relatively stable. This suggests that the new artists coming into the genre are joining these groups within the genre. Perhaps there are specific sub genres of Grime that new artists join.",
    "crumbs": [
      "Analysis",
      "<span class='chapter-number'>8</span>¬† <span class='chapter-title'>Communities</span>"
    ]
  },
  {
    "objectID": "Communities - ggraph.html#comparing-algorithms",
    "href": "Communities - ggraph.html#comparing-algorithms",
    "title": "8¬† Communities",
    "section": "8.6 Comparing algorithms",
    "text": "8.6 Comparing algorithms\nAs a researcher, you may want to try different algorithms to determine which tells the story of your network. This section shows you four different algorithms. The onus is on you to ensure you understand what the algorithms do and why they may produce slightly different results.\n\nwt &lt;- cluster_walktrap(grime_isol)\nV(grime_isol)$wt &lt;- membership(wt)\n\nle &lt;- cluster_leading_eigen(grime_isol)\nV(grime_isol)$le &lt;- membership(le)\n\nedge &lt;- cluster_edge_betweenness(grime_isol)\nV(grime_isol)$edge &lt;- membership(edge)\n\nset.seed(123)\ng8_louv &lt;- ggraph(grime_isol, layout = \"fr\") +  \n  geom_edge_link(color = \"grey\") +\n  geom_node_point(aes(color = as.factor(louv)), \n                  size = 5, show.legend = FALSE) +\n  geom_node_text(aes(label = louv), \n                 color = \"black\", size = 3, repel = FALSE) +\n  ggtitle(\"Louvain\") +\n  theme_void()\n\nset.seed(123)\ng8_wt &lt;- ggraph(grime_isol, layout = \"fr\") +  \n  geom_edge_link(color = \"grey\") +\n  geom_node_point(aes(color = as.factor(wt)), \n                  size = 5, show.legend = FALSE) +\n  geom_node_text(aes(label = wt), \n                 color = \"black\", size = 3, repel = FALSE) +\n  ggtitle(\"Walktrap\")+\n  theme_void()\n\nset.seed(123)\ng8_le &lt;- ggraph(grime_isol, layout = \"fr\") +  \n  geom_edge_link(color = \"grey\") +\n  geom_node_point(aes(color = as.factor(le)), \n                  size = 5, show.legend = FALSE) +\n  geom_node_text(aes(label = le), \n                 color = \"black\", size = 3, repel = FALSE) +\n  ggtitle(\"Leading Eidgen\") +\n  theme_void()\n\nset.seed(123)\ng8_edge &lt;- ggraph(grime_isol, layout = \"fr\") +  \n  geom_edge_link(color = \"grey\") +\n  geom_node_point(aes(color = as.factor(edge)), \n                  size = 5, show.legend = FALSE) +\n  geom_node_text(aes(label = edge), \n                 color = \"black\", size = 3, repel = FALSE) +\n  ggtitle(\"Edge Between\") +\n  theme_void()\n\ng8_louv + g8_wt + g8_le + g8_edge\n\n\n\n\n\n\n\n\nIn this case, you have complete consensus across multiple algorithms. This is rare, but should build confidence in your analysis.",
    "crumbs": [
      "Analysis",
      "<span class='chapter-number'>8</span>¬† <span class='chapter-title'>Communities</span>"
    ]
  },
  {
    "objectID": "communities - plot.html",
    "href": "communities - plot.html",
    "title": "9¬† Communities",
    "section": "",
    "text": "9.1 The Process\nWithin your network you may have subgroups. In a class of students, there are often smaller homework groups, study groups, friendship groups, etc.. What is the demographic composition of these groups? Do subgroups appear more in some settings compared to others? What happens to these groups over time? To answer these types of questions you need a specific analytic tool, community detection.\nAt its core, community detection is a method used to analyse the sub components(groups) of your graph. It literally detects whether there are smaller groups within a network. Using mathematically informed algorithms, various community detection approaches produce measurements of how many sub groups there are in your graph and how cohesive those subgroups are.\nFor this tutorial I am using the Grime collaboration network data that we have been using a lot. I am going to bring in the data from 2008 and clean up the graph a bit before we dive in. This network is directed, but for the sake of the tutorial, I bring it in as an undirected graph then swap. You will read why.\nLet‚Äôs get familiar with how to perform community detection. In this section, I will be using the Louvain algorithm since it is one of the more commonly known and comprehensible. To do so, use the cluster_lourvain() command. Please note, your network may not work with Louvain because it only works with undirected networks (hence why I brought the Grime network in as undirected).\nI strongly recommend putting that information into an object. Then we can take a look at what is has in it.\nlouv &lt;- cluster_louvain(grime_08_clean)\n\nlouv\n\nIGRAPH clustering multi level, groups: 17, mod: 0.61\n+ groups:\n  $`1`\n  [1] \"Asher D\"        \"Scorcher\"       \"Flowdan\"        \"Tinchy Stryder\"\n  [5] \"Frisco\"         \"Kano\"           \"Wiley\"          \"Lauren Mason\"  \n  \n  $`2`\n  [1] \"Dizzee Rascal\"\n  \n  $`3`\n  [1] \"Lethal Bizzle\"\n  \n  + ... omitted several groups/vertices",
    "crumbs": [
      "Analysis",
      "<span class='chapter-number'>9</span>¬† <span class='chapter-title'>Communities</span>"
    ]
  },
  {
    "objectID": "communities - plot.html#the-process",
    "href": "communities - plot.html#the-process",
    "title": "9¬† Communities",
    "section": "",
    "text": "9.1.1 Understanding the Metrics\nThe two main things you will want to take from these algorithms are the modularity and the membership. Modularity is a score of how separated, or modular, the network is indicating how cohesive the groups are compared to the whole network. Put simply, modularity measures the density of each group compared to the density inside the group. The statistic is measured from -1/2 to +1 with metrics closer to 1 indicating higher modularity. It is a measurement that compares what we expect to see if the graph were completely random with what is actually observed. Use modularity().\nMeanwhile, membership is a vector showing which group each node is classed in. This will come in very handy for you if you want to export this information or use it for visualisations. Use membership().\n\nmodularity(louv)\n\n[1] 0.6084184\n\nmembership(louv)\n\n        Asher D   Dizzee Rascal   Lethal Bizzle        Scorcher     Bless Beats \n              1               2               3               1               4 \n        Flowdan  Tinchy Stryder          Frisco            Kano     Treble Clef \n              1               1               1               1               5 \n        Shystie          Blacks         Badness         Chronik         Tempa T \n              6               7               7               7               7 \nNewham Generals          Skepta             JME            Chip             BBK \n              7               7               7               8               4 \nVirus Syndicate          Ghetts        Mercston        Double S        Griminal \n              9              10              11               8               8 \n        Ice Kid Nu Brand Flexxx       Wretch 32           Wiley  Bossman Birdie \n              8              12               8               1              13 \n    The Streets            Sway    Tinie Tempah           Giggs          Jammer \n             14              15              16              17               7 \n      Roll Deep          Devlin        P Money     Lauren Mason     Milli Major \n              4              10               8               1              13 \n\n\n\n\n9.1.2 Visualisation Tips for community detection\nThere are two main ways to visualise communities in the network. First is to change the colours of the nodes to match the community they are in. To do this, you utilise the vertex.color() argument in the plot() command\n\npar(mar = c(0,0,0,0))\nplot(grime_08_clean, vertex.color = louv$membership, vertex.label = NA)\n\n\n\n\n\n\n\n\nSecond, you can use polygons to demonstrate the boundaries of the communities. To do this, you plot the clustering object alongside the graph object.\n\npar(mar = c(0,0,0,0))\nplot(louv, grime_08_clean, vertex.label = NA)\n\n\n\n\n\n\n\n\nNotice the red edges? Good! This visualisation demonstrates nodes that bridge across communities.\nAnother thing to notice is that some of the isolates share colours with others in the network. This is because Rstudio only uses a set number of colours by default. It may be misleading in your report if you include isolates in your network since it appears as if they are in the same community. This is false!!! You may want to clean your network a bit more when presenting these visuals, then.\n\n\n9.1.3 Clean your graph\nOne main thing you need to think about when detecting communities in your graph is its structure/composition. How your graph is structured might strongly impact the findings you get from your community detection.\nIN 2008, there were a lot og Grime artists who did not collaborate with anyone else (isolates). If we were to run a community detection algorithm on the graph with all the isolates still in the graph, they would be included in the algorithms mathematics.\nFor example, I am using going to re-run the analysis I did above using the Louvain algorithm with and without the isolates and you will see what a difference it makes visually. To do this, I will delete the isolates from the network and the plot it.\n\ngrime_isol &lt;-delete_vertices(grime_08_clean, which(degree(grime_08_clean)==0))\npar(mar = c(0,0,0,0))\nplot(grime_isol)\n\n\n\n\n\n\n\n\nNow take the louvain on this network and take a look at it.\n\nlouv_isol &lt;- cluster_louvain(grime_isol)\n\nlouv_isol\n\nIGRAPH clustering multi level, groups: 6, mod: 0.61\n+ groups:\n  $`1`\n  [1] \"Asher D\"        \"Scorcher\"       \"Flowdan\"        \"Tinchy Stryder\"\n  [5] \"Frisco\"         \"Kano\"           \"Wiley\"          \"Lauren Mason\"  \n  \n  $`2`\n  [1] \"Bless Beats\" \"BBK\"         \"Roll Deep\"  \n  \n  $`3`\n  [1] \"Blacks\"          \"Badness\"         \"Chronik\"         \"Tempa T\"        \n  [5] \"Newham Generals\" \"Skepta\"          \"JME\"             \"Jammer\"         \n  + ... omitted several groups/vertices\n\n\nThe number of groups has reduced from 17 to 6. This shows that the first algorithm counted the isolates as groups. This becomes even more apparent when we plot the network.\nNotice, however, that modularity does not change.\n\npar(mfrow = c(1, 2))\npar(mar =c(0,0,0,0))\nset.seed(123)\nplot(louv_isol, grime_isol, vertex.label = NA)\nset.seed(123)\nplot(grime_isol, vertex.color = louv_isol$membership, vertex.label = NA)\n\n\n\n\n\n\n\n\nNow we do not have the isolates in, it is a much less confusing (noisy) visualisation.",
    "crumbs": [
      "Analysis",
      "<span class='chapter-number'>9</span>¬† <span class='chapter-title'>Communities</span>"
    ]
  },
  {
    "objectID": "communities - plot.html#comparing-algorithms",
    "href": "communities - plot.html#comparing-algorithms",
    "title": "9¬† Communities",
    "section": "9.2 Comparing algorithms",
    "text": "9.2 Comparing algorithms\nAs a researcher, you may want to try different algorithms to determine which tells the story of your network. This section shows you four different algorithms. As the scientist, the onus is on you to ensure you understand what the algorithms do and why they may produce slightly different results.\n\nwt &lt;- cluster_walktrap(grime_isol)\nle &lt;- cluster_leading_eigen(grime_isol)\nedge &lt;- cluster_edge_betweenness(grime_isol)\n\npar(mfrow = c(2, 2))\npar(mar =c(0,0,3,0))\nset.seed(123)\nplot(louv_isol, grime_isol, main = \"Louvain\", vertex.label = NA)\nset.seed(123)\nplot(edge, grime_isol, main = \"Edge Betweenness\", vertex.label = NA)\nset.seed(123)\nplot(wt, grime_isol, main = \"Walktrap\", vertex.label = NA)\nset.seed(123)\nplot(le, grime_isol, main = \"Leading Eigenvector\", vertex.label = NA)\n\n\n\n\n\n\n\n\nIn this case, we have consensus across multiple algorithms. This is rare, but should build more confidence in your analysis.",
    "crumbs": [
      "Analysis",
      "<span class='chapter-number'>9</span>¬† <span class='chapter-title'>Communities</span>"
    ]
  },
  {
    "objectID": "communities - plot.html#analysing-the-communities.",
    "href": "communities - plot.html#analysing-the-communities.",
    "title": "9¬† Communities",
    "section": "9.3 Analysing the communities.",
    "text": "9.3 Analysing the communities.\nOne thing you can do with the community detection is to describe their nature.A basic example is just to take a look at their characteristics like average the nodal degree in each community to see if certain groups have higher degree than others. In the following chunk, I make a data frame in an object called node data. This data frame has the membership from the louvain algorithm and the nodes‚Äô degree. Then, I present a variable (not saved in the dataframe) called mean_degree which presents the mean degree of each community.\n\nnode_data &lt;- data.frame(\n  deg = degree(grime_isol),\n  subgroup = louv_isol$membership\n)\n\nnode_data %&gt;%\n     group_by(subgroup) %&gt;%\n     summarise(mean_degree = mean(deg, na.rm = TRUE))\n\n# A tibble: 6 √ó 2\n  subgroup mean_degree\n     &lt;dbl&gt;       &lt;dbl&gt;\n1        1        2.12\n2        2        1.67\n3        3        2.12\n4        4        2.17\n5        5        1   \n6        6        1   \n\n\nWhat does this new table tell you about each community?\nYou can do many different descriptive analyses of these communities. Let‚Äôs say you have some node-level characteristics like their gender. you can examine the percentage of men/women in each community to see if gender may be associated with one group more than another.",
    "crumbs": [
      "Analysis",
      "<span class='chapter-number'>9</span>¬† <span class='chapter-title'>Communities</span>"
    ]
  },
  {
    "objectID": "communities - plot.html#final-thoughts",
    "href": "communities - plot.html#final-thoughts",
    "title": "9¬† Communities",
    "section": "9.4 Final Thoughts",
    "text": "9.4 Final Thoughts\nYou need to remember that there are a lot of algorithms that can be used. Each algorithm identifies groups within your network based on a certain characteristic. For example, some algorithms like Louvain seek to maximise the modularity of groups finding the communities that are more densely connected to each other compared to the network as a whole. Meanwhile, Walktrap uses random walks across the graph to determine which nodes occur more frequently together on each others random walk. The co-occurrence of nodes across random walks indicates that they are likely in the same community.\nSo, you need to be cautious when selecting what community detection algorithm you are going to use and understand them. When reporting, you will want to report your findings as they relate to the community detection algorithm that you are using otherwise your results could be misleading. For example, if you use the Walktrap but report that the communities are more densely connected to each other than the whole network (clearly a Louvain-related explanation) this may or may not actually be true because Walktrap is not directly measuring community vs.¬†network density.\nThe tendency for researchers is to try multiple algorithms and find one that either produces the nicest visualisation, or produces the highest metrics. I strongly recommend not doing this but rather thinking deeply about why there might be differences across measurements. This in itself could be a finding!",
    "crumbs": [
      "Analysis",
      "<span class='chapter-number'>9</span>¬† <span class='chapter-title'>Communities</span>"
    ]
  },
  {
    "objectID": "Advanced Visualisation - Dynamic.html",
    "href": "Advanced Visualisation - Dynamic.html",
    "title": "5¬† Dynamic Network Visualisations",
    "section": "",
    "text": "library(igraph)\nlibrary(ADAPTSNA)\n\nYou might be interested in networks that change over time. Rather than a cross-section of relationships, you may have multiple networks that are taken at different time points. These are called discrete longitudinal networks. They are discrete because each network represents a discrete, distinct, point in time. For example, you may have monthly phone call data between people and their family. You may have yearly romantic affiliations between a group of people. The point is, the time stamps are distinct and standardised (yearly, monthly, daily etc.) and the relationships may change over time. There is such a thing as continuous longitudinal network data, but we will just focus on discrete networks for now.\nIn other tutorials we have been using collaboration data between Grime musicians. Well, we can measure this over time! This next chunk should seem familiar to you, they bring in and clean up edgelists of collaborations every two years from 2008-2014 (four time stamps).\n\n# 2008\nedge_list &lt;- load_data(\"GRIME_2008_Edge.csv\", header = TRUE)\ngrime_08&lt;- graph_from_data_frame(d=edge_list, directed = TRUE)\n##Removing Loops\ngrime_08 &lt;- delete_edges(grime_08, E(grime_08)[is.loop(grime_08)])\n\n\n# 2010\nedge_list_10 &lt;- load_data(\"GRIME_2010_Edge.csv\", header = TRUE)\ngrime_10&lt;- graph_from_data_frame(d=edge_list_10, directed = TRUE)\n##Removing Loops\ngrime_10 &lt;- delete_edges(grime_10, E(grime_10)[is.loop(grime_10)])\n\n# 2012\nedge_list_12 &lt;- load_data(\"GRIME_2012_Edge.csv\", header = TRUE)\ngrime_12&lt;- graph_from_data_frame(d=edge_list_12, directed = TRUE)\n##Removing Loops\ngrime_12 &lt;- delete_edges(grime_12, E(grime_12)[is.loop(grime_12)])\n\n# 2014\nedge_list_14 &lt;- load_data(\"GRIME_2014_Edge.csv\", header = TRUE)\ngrime_14&lt;- graph_from_data_frame(d=edge_list_14, directed = TRUE)\n##Removing Loops\ngrime_14 &lt;- delete_edges(grime_14, E(grime_14)[is.loop(grime_14)])\n\nNow we have the networks in, we need to switch gears a little over to another package that allows us to you create an object known as a network list. Like it sounds, it is a list of networks. We use the package intergraph to swap from igraph over to an object type ‚ÄúNetwork‚Äù that the packages Networkdynamic and ndtv recognise as they are the ones we will use for our visualisaitons. We also detach igraph since we are no longer using that package. We want to detach it so R does not get confused if there are functions that are similarly worded across packages.\n\nlibrary(intergraph)\ngrime_net_1 &lt;- asNetwork(grime_08)\ngrime_net_2 &lt;- asNetwork(grime_10)\ngrime_net_3 &lt;- asNetwork(grime_12)\ngrime_net_4 &lt;- asNetwork(grime_14)\n\nIf you take a look at these networks, the appear a little different from our usual igraph object but have the same information stored.\n\ngrime_net_1\n\n Network attributes:\n  vertices = 40 \n  directed = TRUE \n  hyper = FALSE \n  loops = FALSE \n  multiple = FALSE \n  bipartite = FALSE \n  total edges= 28 \n    missing edges= 0 \n    non-missing edges= 28 \n\n Vertex attribute names: \n    vertex.names \n\n Edge attribute names: \n    collab_weight \n\n\nRight, now the fun stuff. We need to bring in our new packages and then create our dynamic network object using the networkdynamic() function.\n\ndetach(\"package:igraph\", unload=TRUE)\nlibrary(networkDynamic)\nlibrary(ndtv)\n\nnet_dynamic_4periods &lt;- networkDynamic(network.list = list(grime_net_1, \n                                                           grime_net_2, \n                                                           grime_net_3,\n                                                           grime_net_4), vertex.pid = \"vertex.names\")\n\nNeither start or onsets specified, assuming start=0\nOnsets and termini not specified, assuming each network in network.list should have a discrete spell of length 1\nArgument base.net not specified, using first element of network.list instead\nInitialized network of size 91 inferred from number of unique vertex.pids\nCreated net.obs.period to describe network\n Network observation period info:\n  Number of observation spells: 1 \n  Maximal time range observed: 0 until 4 \n  Temporal mode: discrete \n  Time unit: step \n  Suggested time increment: 1 \n\n\nNote that you have to state the vertex.names as the id. There are artists in these networks that come and go (known as joiners or leavers). setting the vertex.pid ensures that R recognises all artists based on these unique identifiers.\nLet‚Äôs take a look at this new dynamic network object.\n\nnet_dynamic_4periods\n\nNetworkDynamic properties:\n  distinct change times: 5 \n  maximal time range: 0 until  4 \n\nIncludes optional net.obs.period attribute:\n Network observation period info:\n  Number of observation spells: 1 \n  Maximal time range observed: 0 until 4 \n  Temporal mode: discrete \n  Time unit: step \n  Suggested time increment: 1 \n\n Network attributes:\n  vertices = 91 \n  directed = TRUE \n  hyper = FALSE \n  loops = FALSE \n  multiple = FALSE \n  bipartite = FALSE \n  vertex.pid = vertex.names \n  net.obs.period: (not shown)\n  total edges= 188 \n    missing edges= 0 \n    non-missing edges= 188 \n\n Vertex attribute names: \n    active vertex.names \n\n Edge attribute names: \n    active \n\n\nThis object tells us all about the network over time. Pay special attention to the time range. We have four networks and this ojbect confirms that there are four time periods (0 - 4).\nYou can make this a data frame to observe changes in tie formation. Pay attention to the onset and terminus columns. These indicate when ties form and dissolve. Head and tail columns indicate a ‚Äúto‚Äù and ‚Äúfrom‚Äù logic.\n\nnet_dynamic_4periods_dat &lt;- as.data.frame(net_dynamic_4periods)\nhead(net_dynamic_4periods_dat)\n\n  onset terminus tail head onset.censored terminus.censored duration edge.id\n1     0        1    1   89          FALSE             FALSE        1       1\n2     0        1   69   89          FALSE             FALSE        1       2\n3     0        1    9   89          FALSE             FALSE        1       3\n4     0        1   24   89          FALSE             FALSE        1       4\n5     0        1   81   89          FALSE             FALSE        1       5\n6     0        1   26   89          FALSE             FALSE        1       6\n\n\nNow we can start making some visualisations. First, we can create a time prism of the networks.\n\ncompute.animation(net_dynamic_4periods)\n\nslice parameters:\n  start:0\n  end:4\n  interval:1\n  aggregate.dur:1\n  rule:latest\n\ntimePrism(net_dynamic_4periods,at=c(0,1, 2,3),\n          displaylabels=FALSE,planes = TRUE,\n          label.cex=0.5)\n\n\n\n\n\n\n\n\nWith this network object, we are ready to look at the changes over time and present a movie using the render.d3movie() function from ndtv. I suggest using the output.mode = ‚ÄòhtmlWidget‚Äô option so it keeps the video in your rstudio environment. Alternatively, you could use the launchBrowser= T option to open up an internet page with your video. To do this, you need to specify the filename. For example, filename=‚ÄúGrime-Network.html‚Äù.\n\nrender.d3movie(net_dynamic_4periods, output.mode = 'htmlWidget')\n\n\n\n\n\nThe play buttons on the bottom right operate the video. You can alter the speed of the transitions between the time points by using the options menu on the top right.\nYou can alter the appearance of the movie in a similar way as you can change the colours and other elements of the network.\n\nrender.d3movie(net_dynamic_4periods, usearrows = F, displaylabels = F, bg=\"black\", vertex.border=\"white\", vertex.col =  \"blue\", edge.col = \"orange\", output.mode = 'htmlWidget')",
    "crumbs": [
      "Visualisation",
      "<span class='chapter-number'>5</span>¬† <span class='chapter-title'>Dynamic Network Visualisations</span>"
    ]
  },
  {
    "objectID": "Network Data.html#two-mode-networks",
    "href": "Network Data.html#two-mode-networks",
    "title": "1¬† Network Data",
    "section": "1.2 Two Mode Networks",
    "text": "1.2 Two Mode Networks\nWhat does it mean for a network to be ‚Äòtwo mode?‚Äô Well, you may have guess by now, however, in the spirit of being thorough, let‚Äôs dive in. If you have a two mode network then you have two different types of node connected to each other. For example, your network could be comprised of individuals connected to groups or words connected to documents. The important thing to know is that your two types of node must be absolutely distinct. In other words, let‚Äôs say you have individuals and groups, there must not be any cross over. Additionally, there must not be any cross over of ties. Individuals cannot be connected to other individuals nor groups to other groups.\nOnce again, two mode network data can be stored as an edgelist or an adjacency matrix. Let‚Äôs use the names of those in the previous networks, only this time, instead of being connected to each other, the ties reflect their TV subscriptions.\n\n1.2.1 Edgelists\nA two mode network stored as an edgelist is structured the same way as a one mode network. However, this time, one column (the ‚Äòfrom‚Äô column) has the individuals and the other (the ‚Äòto‚Äô column) has the groups.\n\nindividuals &lt;- c(\"Robert\", \"Robert\", \"Robert\", \"Robert\", \"George\", \"George\",\"George\", \"Albert\", \"Albert\", \"Henrietta\", \"Henrietta\", \"Roland\", \"Roland\", \"Roland\", \"Roland\", \"Roland\", \"Charles\") \n\ngroups &lt;- c(\"ESPN\", \"Hulu\", \"AMAZON\", \"Disney+\", \"Netflix\", \"AMAZON\", \"Disney+\", \"ESPN\", \"Disney+\", \"Hulu\", \"Netflix\", \"ESPN\", \"Hulu\", \"AMAZON\", \"Disney+\", \"Netflix\", \"Hulu\")\n\n\ntm_edge &lt;- data.frame(   \n  i = individuals,   \n  g = groups)  \n\nprint(tm_edge)\n\n           i       g\n1     Robert    ESPN\n2     Robert    Hulu\n3     Robert  AMAZON\n4     Robert Disney+\n5     George Netflix\n6     George  AMAZON\n7     George Disney+\n8     Albert    ESPN\n9     Albert Disney+\n10 Henrietta    Hulu\n11 Henrietta Netflix\n12    Roland    ESPN\n13    Roland    Hulu\n14    Roland  AMAZON\n15    Roland Disney+\n16    Roland Netflix\n17   Charles    Hulu\n\n\nNow you have a two mode edgelist there are a few things we need to do. The first is familiar to you since you use the same function to create a two mode network as a one mode network from an edgelist. First, you use graph_from_data_frame() to create the network object g_tm. However, this object, as it is, appears as a one mode network. R needs to know that there are two types of node.\nTo do this, you can create a node characteristic to differentiate one from the other (individuals from groups). Igraph has a function that helps do this. bipartite_mapping() is a function that, in essence, searches your network and identifies one type (stored as FALSE or 0) and another type (stored as TRUE or 1). This is precisely why you must have distinct node types in each column. Otherwise igraph would not be able to recognise the individuals from the groups!\nFinally, you use the vertex.color option to differentiate the individuals from the groups in your visualisation. Not to worry, more on that in CHAPTER X.\n\n# Make the network object\ng_tm &lt;- graph_from_data_frame(tm_edge)\n\n#Identify the two node types\nV(g_tm)$type &lt;- bipartite_mapping(g_tm)$type\n\n# Visualise\nset.seed(123)\nplot(g_tm, vertex.color = V(g_tm)$type)\n\n\n\n\n\n\n\n\n\n\n1.2.2 Adjacency Matrices\nTwo Mode adjacency matrices are a little bit different from one more adjacency matrices. A two mode matrix (also known as an incidence, affiliation, or bipartite matrix) has rows for the individuals (i) and columns for the groups (g). The cells are still filled with ‚Äò1‚Äô and ‚Äò0‚Äô to indicate an individual is connected to a group. For obvious reasons, there is not a diagonal on this type of matrix since the rows and columns are distinct. No overlap means no self loops.\nYou can convert the two mode network you have been working on into a matrix using igraph‚Äôs as_biadjacency_matrix() function. Then you can view it. It is as you expect. Robert and gang are in the rows and each column is filled with the TV subscriptions from the original network.\n\ntm_matrix &lt;- as_biadjacency_matrix(g_tm, sparse = FALSE)\n\ntm_matrix\n\n          ESPN Hulu AMAZON Disney+ Netflix\nRobert       1    1      1       1       0\nGeorge       0    0      1       1       1\nAlbert       1    0      0       1       0\nHenrietta    0    1      0       0       1\nRoland       1    1      1       1       1\nCharles      0    1      0       0       0\n\n\nNow this is ready to be converted into a network object. You do so using graph_from_biadjacency_matrix() from igraph. Since a matrix obviously has two types of mode (the rows and columns are different), igraph can easily create a two mode network from these data. So there is no need to using the mapping that you use before.\n\ng_tm2 &lt;- graph_from_biadjacency_matrix(tm_matrix)\n\nset.seed(123)\nplot(g_tm2, vertex.color = V(g_tm2)$type)",
    "crumbs": [
      "Orientation",
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Network Data</span>"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Introduction to Social Network Analysis",
    "section": "",
    "text": "WELCOME!\nWhy do network analysts never get lost?\n\nBecause they always follow the shortest path!",
    "crumbs": [
      "WELCOME!"
    ]
  },
  {
    "objectID": "Advanced Visualisation - Noisy.html",
    "href": "Advanced Visualisation - Noisy.html",
    "title": "7¬† Advanced Visualisation - Noisy Networks",
    "section": "",
    "text": "7.1 Contours\nlayout_df &lt;- create_layout(g, layout = \"kk\")\n\nggraph(layout_df) +\n  geom_edge_link(alpha = 0.5) +  # Edge links\n  stat_density_2d(\n    aes(x = x, y = y, fill = after_stat(level)),\n    geom = \"polygon\",\n    contour = TRUE,\n    alpha = 0.3\n  ) +  # Contour map\n  scale_fill_viridis_c() +  # Color scale for contour levels\n  geom_text(\n    data = subset(layout_df, og == 1),\n    aes(x = x, y = y, label = name),  # Make sure 'name' column exists\n    color = \"black\"\n  ) +\n  theme_void() +\n  theme(legend.position = \"none\")",
    "crumbs": [
      "Visualisation",
      "<span class='chapter-number'>7</span>¬† <span class='chapter-title'>Advanced Visualisation - Noisy Networks</span>"
    ]
  },
  {
    "objectID": "Advanced Visualisation - Noisy.html#contours",
    "href": "Advanced Visualisation - Noisy.html#contours",
    "title": "8¬† Advanced Visualisation - Noisy Networks",
    "section": "9.1 Contours",
    "text": "9.1 Contours\n\nlayout_df &lt;- create_layout(g, layout = \"kk\")\n\nggraph(layout_df) +\n  geom_edge_link(alpha = 0.5) +  # Edge links\n  stat_density_2d(\n    aes(x = x, y = y, fill = after_stat(level)),\n    geom = \"polygon\",\n    contour = TRUE,\n    alpha = 0.3\n  ) +  # Contour map\n  scale_fill_viridis_c() +  # Color scale for contour levels\n  geom_text(\n    data = subset(layout_df, og == 1),\n    aes(x = x, y = y, label = name),  # Make sure 'name' column exists\n    color = \"black\"\n  ) +\n  theme_void() +\n  theme(legend.position = \"none\")",
    "crumbs": [
      "Visualisation",
      "<span class='chapter-number'>8</span>¬† <span class='chapter-title'>Advanced Visualisation - Noisy Networks</span>"
    ]
  },
  {
    "objectID": "Advanced Visualisation - Noisy.html#very-noisy-networks",
    "href": "Advanced Visualisation - Noisy.html#very-noisy-networks",
    "title": "7¬† Advanced Visualisation - Noisy Networks",
    "section": "7.2 VERY NOISY NETWORKS",
    "text": "7.2 VERY NOISY NETWORKS\n\ng_edge2 &lt;- read.csv(\"Q:/Shared drives/SAT - The Three Amigos/SNA Book/data_placeholder/fans_edgelist.csv\")\ng2 &lt;- graph_from_data_frame(d = g_edge2, directed = T) \n\n\nlayout_df2 &lt;- create_layout(g2, layout = \"kk\")\n\nggraph(layout_df2) +\n  geom_edge_link(alpha = 0.5) +  # Edge links\n  stat_density_2d(\n    aes(x = x, y = y, fill = after_stat(level)),\n    geom = \"polygon\",\n    contour = TRUE,\n    alpha = 0.3\n  ) +  # Contour map\n  scale_fill_viridis_c() +  # Color scale for contour levels\n  theme_void() +\n  theme(legend.position = \"none\")",
    "crumbs": [
      "Visualisation",
      "<span class='chapter-number'>7</span>¬† <span class='chapter-title'>Advanced Visualisation - Noisy Networks</span>"
    ]
  },
  {
    "objectID": "assortitivity.html",
    "href": "assortitivity.html",
    "title": "8¬† Assortativity",
    "section": "",
    "text": "9 Assortativity\nBirds of a feather flock together. This is one of the most important insights about social interaction. Time and time again and across the globe, people display a tendency for connecting to others who are like themselves. This tendency for connecting to similar others is called assortativity. And when people actually form relationships or engage in interactions with similar others, we refer to this as homophily. By contrast, connecting with dissimilar others is referred to as heterophily.\nAssortative tendencies may be the rule, but the study of different types of social contexts and relationships reveals variation in assortativity. For example, romantic relations in the United States tend to be racially and educationally homophilous, but also gender heterophilous. Furthermore, a social context might begin with strong assortative tendencies, only for those tendencies to weaken over time. An important goal of social science research is therefore to better understand the extent and dynamics of assortativity.\nWe will begin to examine these issues using data from the Hartford drug user network. First, let‚Äôs load the necessary packages.\nlibrary(intronets)\nlibrary(igraph)\nlibrary(ggraph)\nlibrary(dplyr)\nThen we can load and inspect the drugnet data. The data are derived from a series of interviews and ethnographic observations with individuals who engaged in the use of illicit drugs. The connections represent close relationships among the users.\nload_nets(\"drugnet.rda\")\ndrug_connect\n\nIGRAPH f0ae330 DN-- 193 323 -- \n+ attr: name (v/c), ethnicity (v/n), gender (v/n)\n+ edges from f0ae330 (vertex names):\n [1] X1 -&gt;X2   X1 -&gt;X10  X2 -&gt;X1   X2 -&gt;X10  X3 -&gt;X7   X4 -&gt;X7   X4 -&gt;X211\n [8] X5 -&gt;X134 X6 -&gt;X152 X7 -&gt;X3   X7 -&gt;X4   X7 -&gt;X9   X8 -&gt;X107 X8 -&gt;X117\n[15] X9 -&gt;X1   X9 -&gt;X2   X9 -&gt;X7   X10-&gt;X1   X10-&gt;X2   X11-&gt;X135 X11-&gt;X220\n[22] X13-&gt;X216 X14-&gt;X24  X14-&gt;X52  X16-&gt;X10  X16-&gt;X19  X17-&gt;X64  X17-&gt;X79 \n[29] X18-&gt;X55  X18-&gt;X104 X18-&gt;X165 X19-&gt;X18  X20-&gt;X64  X20-&gt;X182 X21-&gt;X16 \n[36] X21-&gt;X22  X22-&gt;X21  X22-&gt;X64  X22-&gt;X107 X23-&gt;X20  X23-&gt;X22  X23-&gt;X64 \n[43] X24-&gt;X14  X24-&gt;X31  X24-&gt;X124 X27-&gt;X117 X28-&gt;X29  X29-&gt;X28  X30-&gt;X19 \n[50] X31-&gt;X24  X31-&gt;X32  X31-&gt;X124 X31-&gt;X149 X31-&gt;X235 X32-&gt;X31  X32-&gt;X87 \n+ ... omitted several edges\nThe drug_connect object contains the largest connected component of the network. Note that we have information about ethnicity and gender for each individual. This information can be used to explore the role of assortativity in network relationships among drug users. Let‚Äôs visualize the network, highlighting the ethnic and gender attributes of the individuals.\nggraph(drug_connect, layout = \"fr\") +\n  geom_edge_link(color = \"darkgrey\", alpha = 0.7) +\n  geom_node_point(aes(color = as.factor(ethnicity), shape = as.factor(gender)), size = 4) +\n  labs(color = \"Ethnicity\", shape = \"Gender\") +\n  scale_color_discrete(labels = c(\"White\", \"African American\", \n                                  \"Puerto Rican/Latino\",\"Other\")) +\n  scale_shape_discrete(labels = c(\"Male\",\"Female\")) +\n  theme_void()\nA few things stand out from the visualization. First two distinct groups are apparent from the visualization. Second, those two groups tend to be dominated by ethnic groups, with one group largely comprised of African American drug users and the other of Puerto Rican/Latino drug users. This tells us that assortatity by ethnicity is probably quite strong in this network. We can also observe some clustering by gender within those groups. So perhaps gender assortativity is present, though almost certainly not as strong as ethnic assortativity.",
    "crumbs": [
      "Analysis",
      "<span class='chapter-number'>8</span>¬† <span class='chapter-title'>Assortativity</span>"
    ]
  },
  {
    "objectID": "assortitivity.html#estimating-assortativity",
    "href": "assortitivity.html#estimating-assortativity",
    "title": "8¬† Assortativity",
    "section": "9.1 Estimating assortativity",
    "text": "9.1 Estimating assortativity\nAssortativity can be calculated by evaluating the number of ties between actors who share the same attribute (for example, both are women) relative to the number of ties between actors who have different attributes (for example, one is a woman and one is a man). This is referred to as a nominal form of assortativity. It measures ties based on homophilous matches on attributes. We can start by estimating assortativity based on gender.\n\nassortativity_nominal(drug_connect, (as.factor(V(drug_connect)$gender)))\n\n[1] 0.2435105\n\n\nThe results produce an assortativity coefficient that ranges between -1 and 1. A value of 1 indicates that all ties are homophilous. A value of -1 indicates that all ties are heterophilous. A value of zero tells us that there is an equal mix of homophilous and heterophilous connections. Here we can see a positive coefficient (0.24), which reveals a tendency toward relationships between individuals from the same gender. As such, we can say that gender assortativity is apparent in this network.\nNow let‚Äôs examine ethnic assortativity.\n\nassortativity_nominal(drug_connect, (as.factor(V(drug_connect)$ethnicity)))\n\n[1] 0.8017222\n\n\nThe results again return a positive assortativity coefficient. The coefficient is substantially higher than what we saw for gender, implying that ethnic assortativity is considerably stronger in this network than is gender assortativity. This result is not surprising given what we saw from the visualization. Clearly relationship formation in this network is structured by ties among people from the same ethnicity.\nThis analysis raises an interesting question: is assortativity stronger among some ethnic groups relative to others? Let‚Äôs examine the homophilous ties and how they vary by the different ethnic groups. The code below identifies which of the edges is homophilous (ego and alter have the same ethnicity) and assigns that logical vector as an edge attribute.\n\nedges &lt;- ends(drug_connect, E(drug_connect), names = FALSE)\neth   &lt;- V(drug_connect)$ethnicity\n\nE(drug_connect)$ethno_homophilous &lt;-\n  eth[edges[,1]] == eth[edges[,2]]\n\ntable(E(drug_connect)$ethno_homophilous)\n\n\nFALSE  TRUE \n   36   287 \n\n\nYou can see that out of all edges, 88 percent are between individuals from the same ethnicity. Now let‚Äôs see how this splits out by different ethnicities. The code below creates a new data frame that represents each edge across the rows. The ethnicity values are assigned to the egos and alters associated with each edge. Then the logical vector for homophily is added as a third column.\n\nedge_df &lt;- data.frame(\n  ego   = eth[edges[,1]],\n  alter = eth[edges[,2]],\n  homophilous = E(drug_connect)$ethno_homophilous\n)\nhead(edge_df)\n\n  ego alter homophilous\n1   1     1        TRUE\n2   1     3       FALSE\n3   1     1        TRUE\n4   1     3       FALSE\n5   1     1        TRUE\n6   1     1        TRUE\n\n\nWe can see that the homophilous values are true when the ethnicity values for ego and alter are the same and are false when they are not. To see how homophily varies by ethnicity, we can collapse or aggregate this table to obtain the proportion of homophilous ties for each ethnic group (based on the column for ego). Before doing this, I will add a variable that indicate what ethnicity each number refers to.\n\nedge_df &lt;- edge_df |&gt; \n  mutate(ego_ethnicity = case_when(\n    ego == 1 ~ \"White\",\n    ego == 2 ~ \"African American\",\n    ego == 3 ~ \"Puerto Rican/Latino\",\n    TRUE ~ \"Other\")) |&gt; \n  mutate(ego_ethnicity = factor(ego_ethnicity, \n                                levels = c(\"White\",\n                                           \"African American\",\n                                           \"Puerto Rican/Latino\",\n                                           \"Other\")))\naggregate(homophilous ~ ego_ethnicity, edge_df, mean)\n\n        ego_ethnicity homophilous\n1               White   0.5217391\n2    African American   0.9173554\n3 Puerto Rican/Latino   0.9371429\n4               Other   0.0000000\n\n\nThe results show that assortativity is especially strong among African American and Puerto Rican individuals in the network, as over 90 percent of their ties are homophilous. White individuals in the network have roughly equivalent numbers of homophilous versus heterophilous ties (52 to 48 percent, respectively). Because there is only one individual with an ethnicity coded as ‚ÄúOther,‚Äù it is impossible for that person to have a homophilous tie and therefore their proportion homophilous ties is 0.",
    "crumbs": [
      "Analysis",
      "<span class='chapter-number'>8</span>¬† <span class='chapter-title'>Assortativity</span>"
    ]
  },
  {
    "objectID": "assortitivity.html#assortativity-for-continuous-attributes",
    "href": "assortitivity.html#assortativity-for-continuous-attributes",
    "title": "8¬† Assortativity",
    "section": "9.2 Assortativity for continuous attributes",
    "text": "9.2 Assortativity for continuous attributes\nWe can also conceive of assortativity based on continuous variables. In these instances, individuals might not have a tendency to exactly match with an alter attribute, but instead to connect with an attribute that is close to their own attribute. For example, age is a continuous attribute that is often subject to homophily, especially when it comes to marriage. When people get married, they are often close in age, not necessarily the exact same age. The continuous measurement of age allows us to evaluate assortativity by its intensity. For example, a marriage to someone who is within two years of your own age is certainly more homophilous than marrying someone who is twenty years older!\nWhile the drug users network does not contain any continuous attribute variables, we can estimate one in order to demonstrate the calculation of continuous assortativity. Below we will identify the degree for each individual in the network and assign that score as a vertex attribute. Then we can assess the extent to which people in this network prefer to connect with others who have similar degree scores.\n\nV(drug_connect)$degree &lt;- degree(drug_connect)\nassortativity(drug_connect, V(drug_connect)$degree)\n\n[1] 0.02227093\n\n\nHere we can see that the value is close to zero, which indicates that assortativity based on degree is not a defining feature of this network. People in this network sometimes connect with others who have similar degree values and sometimes they do not.\nAssortativity is a graph-level characteristic revealing the tendency to connect with similar others. We have shown how to estimate this feature, which can be used to examine the tie formation mechanisms ‚Äì in this case, ethnic homophily matters more for tie formation than gender or degree homophily. It also can be applied across contexts to see how assortativity varies across different types of social networks. There are more powerful statistical tools for assessing assortativity while also conditioning on other network features. While we won‚Äôt cover those procedures here, those who are interested in these advanced techniques should explore further tutorials on exponential random graph models (or ERGMs).",
    "crumbs": [
      "Analysis",
      "<span class='chapter-number'>8</span>¬† <span class='chapter-title'>Assortativity</span>"
    ]
  },
  {
    "objectID": "assortitivity.html#references",
    "href": "assortitivity.html#references",
    "title": "8¬† Assortativity",
    "section": "9.3 References",
    "text": "9.3 References\nFor more on the drugnet data‚Ä¶\n\nWeeks, Margaret R., Scott Clair, Stephen P. Borgatti, Kim Radda, and Jean J. Schensul. 2002. ‚ÄúSocial Networks of Drug Users in High-Risk Sites: Finding the Connections.‚Äù AIDS and Behavior 6(2):193‚Äì206.\nWeeks, Margaret R., Mark Convey, Julia Dickson-Gomez, Jianghong Li, Kim Radda, Maria Martinez, and Eduardo Robles. 2009. ‚ÄúChanging Drug Users‚Äô Risk Environments: Peer Health Advocates as Multi-Level Community Change Agents.‚Äù American Journal of Community Psychology 43(3):330‚Äì44.\n\nFor more on assortativity and homophily‚Ä¶\n\nLada A. Adamic and Eytan Adar. 2003. Friends and neighbors on the Web. Social Networks, 25(3):211-230.\nMcPherson, Miller, Lynn Smith-Lovin, and James M. Cook. 2001. ‚ÄúBirds of a Feather: Homophily in Social Networks.‚Äù Annual Review of Sociology 27(1):415‚Äì44.\nM. E. J. Newman 2003. Mixing patterns in networks, Phys. Rev.¬†E 67, 026126\nM. E. J. Newman 2002. Assortative mixing in networks, Phys. Rev.¬†Lett. 89, 208701",
    "crumbs": [
      "Analysis",
      "<span class='chapter-number'>8</span>¬† <span class='chapter-title'>Assortativity</span>"
    ]
  },
  {
    "objectID": "two_mode.html",
    "href": "two_mode.html",
    "title": "11¬† two_mode",
    "section": "",
    "text": "Content coming.",
    "crumbs": [
      "Extensions",
      "<span class='chapter-number'>11</span>¬† <span class='chapter-title'>two_mode</span>"
    ]
  },
  {
    "objectID": "text.html",
    "href": "text.html",
    "title": "14¬† text",
    "section": "",
    "text": "Content coming.",
    "crumbs": [
      "Extensions",
      "<span class='chapter-number'>14</span>¬† <span class='chapter-title'>text</span>"
    ]
  },
  {
    "objectID": "dynamic.html",
    "href": "dynamic.html",
    "title": "13¬† dynamic",
    "section": "",
    "text": "Content coming",
    "crumbs": [
      "Extensions",
      "<span class='chapter-number'>13</span>¬† <span class='chapter-title'>dynamic</span>"
    ]
  },
  {
    "objectID": "r_basics.html",
    "href": "r_basics.html",
    "title": "Appendix A ‚Äî R Basics and Resources",
    "section": "",
    "text": "A.1 What is R and RStudio?\nThis textbook teaches social network analysis in R. While R can be challenging for first time users, many excellent resources are available for learning R. This appendix offers links to those more detailed resources, while also providing a brief introduction to the software and the coding, focusing specifically on the coding particularities we rely on in this textbook.\nR is a statistical software program and coding language. RStudio is a software platform with a graphical user interface (GUI) that makes it easier to run R code and work with R. You can download these two programs and open RStudio and it will run R in the background. R comes with a series of base functions and these are supplemented with user-developed packages that can be downloaded from R‚Äôs online repository or directly from user-specific repositories (typically, GitHub repositories).",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>A</span>¬† <span class='chapter-title'>R Basics and Resources</span>"
    ]
  },
  {
    "objectID": "r_basics.html#why-r",
    "href": "r_basics.html#why-r",
    "title": "Appendix A ‚Äî R Basics and Resources",
    "section": "A.2 Why R?",
    "text": "A.2 Why R?\nThe obvious first question is, why R? Social network analysis can be conducted in lots of different software programs and applications. We believe that R is the ideal program, at this current moment, for gaining extensive introductory training in SNA. First, R is free, so any student can access the program without the need for funds or an institutional affiliation that can provide those funds.\nSecond, while RStudio has point-and-click capability and GUI interfaces, coding is essential for running detailed analyses and visualizations. This is a benefit, because any network analyst worth their salt should champion the ability to replicate their work. In other words, coding is a necessity and R offers an ideal platform to learn and apply software coding.\nThird, the decentralized character of R package development provides its users with a vast array of packages that are up to date and allow for an almost limitless font of data management and analysis functions. That is to say, there‚Äôs almost nothing statistically you cannot do in R. We will, purposely, only focus on a small number of packages in this textbook. But learning the basics of SNA in R sets you up well for further statistical analyses.",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>A</span>¬† <span class='chapter-title'>R Basics and Resources</span>"
    ]
  },
  {
    "objectID": "r_basics.html#external-resources-for-r",
    "href": "r_basics.html#external-resources-for-r",
    "title": "Appendix A ‚Äî R Basics and Resources",
    "section": "A.3 External Resources for R",
    "text": "A.3 External Resources for R\nThere are many excellent guides for learning and using R & RStudio. An excellent introductory guide is Garrett Grolemund‚Äôs [Hands-On Programming with R]https://rstudio-education.github.io/hopr/, which I highly recommend for those who are working with R for the first time. I also recommend Hadley Wickham‚Äôs [R for Data Science]https://r4ds.hadley.nz/ for further topics related to data management and coding workflow strategies. We rely heavily in our textbook on the tidy data principles that Hadley and his colleagues developed.\nThe use of ChatGPT and other generative AI applications for assistance with coding has generated much debate in the social sciences. We have found these tools to be helpful when we do our coding work, though there are many reasons to be cautious. First, these tools often hallucinate by offering advice about packages or functions that do not (or no longer) exist. Second, these tools frequently offer complex solutions to relatively simple coding problems. It is better to ask about smaller and more precise tasks than to make broader queries about bigger problems. Third, make sure you understand the code that these applications are offering. They frequently offer to develop elaborate functions for you. When that happens, ask the app to break apart the function into smaller parts. And ask lots of questions about what the code is doing. It will take more time, but it will be time well spent.",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>A</span>¬† <span class='chapter-title'>R Basics and Resources</span>"
    ]
  },
  {
    "objectID": "r_basics.html#installing-r-and-rstudio",
    "href": "r_basics.html#installing-r-and-rstudio",
    "title": "Appendix A ‚Äî R Basics and Resources",
    "section": "A.4 Installing R and RStudio",
    "text": "A.4 Installing R and RStudio\nR is available via the Comprehensive R Archive Network ([CRAN]https://cran.r-project.org/). Follow the link and select the file that matches your operating system. After installing R, go to the following link and do the same for [RStudio]https://posit.co/downloads/, just be sure to select the free option. R and RStudio are frequently updated, so you will periodically need to install new versions. When you open RStudio and a new update for R or RStudio are available, you‚Äôll be told that it‚Äôs time to do so. It‚Äôs usually a good idea to keep both programs up to date.\nRunning R code requires that you open RStudio. You do not need to open R as well ‚Äì RStudio runs the R program in the background. Below is an example of what the interface looks like.\n\n\n\nRStudio interface",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>A</span>¬† <span class='chapter-title'>R Basics and Resources</span>"
    ]
  },
  {
    "objectID": "r_basics.html#interface",
    "href": "r_basics.html#interface",
    "title": "Appendix A ‚Äî R Basics and Resources",
    "section": "A.5 Interface",
    "text": "A.5 Interface\nAs you can see, the interface includes 4 boxes. The upper left box is where you write the code. To be clear, code refers to the coding language that fits into this box. Script refers to the coding files which can be saved to your local or cloud environment. I recommend opening script files directly in RStudio, either by clicking on ‚ÄúFile &gt; Open File‚Ä¶‚Äù or by using the open file icon at the upper left, instead of opening script files from outside of RStudio.\nTo run code, you can highlight the portion of code that you want to run and then click on the ‚ÄúRun‚Äù button near the upper middle of the screen. Another option, which we find to be much easier, is to navigate to the line of the code that you want to run and press Ctrl+Enter. After that portion of the code is run, the cursor will move to the next line. This makes it very easy to sequentially run through the code in a script file.\nOne other coding shortcut to mention: R makes autofill suggestions as you write your code. This can be a very helpful feature to rely on when you are calling on different objects and variables.\nWhen you run a command, the code and the corresponding output shows up in the console, which is lower left. You can also run code directly from the console by typing in your code and pressing enter.\nWhen you load or create an object, it shows up in your global environment (upper right). Graphical displays show up in the lower right box in the ‚ÄúPlots‚Äù tab. That lower right box also contains lots of other helpful tabs, including the ‚ÄúHelp‚Äù tab which can be used to learn more about the various functions you will be using.",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>A</span>¬† <span class='chapter-title'>R Basics and Resources</span>"
    ]
  },
  {
    "objectID": "r_basics.html#r-coding-basics",
    "href": "r_basics.html#r-coding-basics",
    "title": "Appendix A ‚Äî R Basics and Resources",
    "section": "A.6 R Coding Basics",
    "text": "A.6 R Coding Basics\nAt the simplest level, R can be used as a calculator. Just enter an equation and run the code. See below.\n\n8675*309\n\n[1] 2680575\n\n\nHere we can see the code in the shaded portion of the text above followed by the output. The output shows that the product of 8675 and 309 is 2680575. The [1] indicates that this is the first element of the output. In fact, it is the only element, which makes that information not especially useful. But rest assured it will be more helpful when your output includes multiple elements.\nImportant note: if you move your cursor over the upper right hand portion of the shaded area, you‚Äôll see a button that copies the code to the clipboard. We recommend following along with the textbook chapters by copying the code and pasting it into your own script file. That way you can follow along with the various exercises, which will help you learn the material better.",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>A</span>¬† <span class='chapter-title'>R Basics and Resources</span>"
    ]
  },
  {
    "objectID": "r_basics.html#functions-and-packages",
    "href": "r_basics.html#functions-and-packages",
    "title": "Appendix A ‚Äî R Basics and Resources",
    "section": "A.7 Functions and Packages",
    "text": "A.7 Functions and Packages\nTypically, R is used to apply functions to data. Here‚Äôs an illustration.\n\nlog(10)\n\n[1] 2.302585\n\n\nlog is a mathematical function that applies the natural logarithm to a number. This is typical format for code: function(information).\nTo learn more about a function, you can type ‚Äú?‚Äù followed by the name of the function and the details will show up in the ‚ÄúHelp‚Äù tab in the bottom right box.\nFunctions are grouped as part of packages. log is part of R‚Äôs ‚Äúbase‚Äù package, which is always available when running RStudio. There are, of course, many other packages installed packages that are not immediately available when you open RStudio. To use those packages, they need to be brought into the library. Here‚Äôs an example of bringing igraph, the main package we will use in this textbook, into the library.\n\nlibrary(igraph)\n\nNow the various igraph functions can be run as part of your code. Quick note: bringing packages into libraries invokes a series of warning messages. We suppress warning messages in the output presented here, so you might see something different when you run these commands by yourself.\nJust like with the log function, you can use the Help window to examine the igraph package and its associated functions. You can also check out other installed and available packages in the ‚ÄúPackages‚Äù tab in the lower right hand box in RStudio. You can click on the check box in this window to load a package, though we recommend using the library command as part of your code instead.\nSome packages are not readily available as part of the standard R and RStudio downloads. For these types of packages, you need to first install the package (install.packages(‚Äúnameofpackage‚Äù)), which downloads it from CRAN and stores the file to your local machine. Then you need to bring the package into the library to use the function. You will only need to download the package once ‚Äì every subsequent time you will only need to bring it into the library. And you will see it appear in the ‚ÄúPackages‚Äù window after it is downloaded.",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>A</span>¬† <span class='chapter-title'>R Basics and Resources</span>"
    ]
  },
  {
    "objectID": "r_basics.html#intronets",
    "href": "r_basics.html#intronets",
    "title": "Appendix A ‚Äî R Basics and Resources",
    "section": "A.8 intronets",
    "text": "A.8 intronets\nWe have created a new package for this textbook called ‚Äúintronets‚Äù. This package contains a command, ‚Äúload_nets‚Äù, that can be used to load the network data from our GitHub repository. To install intronets, use the following code. After doing this one time, you will be able to access the data files using the load_nets command.\n\nlibrary(remotes)\ninstall_github(\"stevemcd1/intronets\")\n\n‚îÄ‚îÄ R CMD build ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n* checking for file 'C:\\Users\\trleppar\\AppData\\Local\\Temp\\RtmpsHTnYm\\remotesaffc4ad97835\\stevemcd1-intronets-7ff62c2/DESCRIPTION' ... OK\n* preparing 'intronets':\n* checking DESCRIPTION meta-information ... OK\n* checking for LF line-endings in source and make files and shell scripts\n* checking for empty or unneeded directories\nOmitted 'LazyData' from DESCRIPTION\n  NB: this package now depends on R (&gt;= 3.5.0)\n  WARNING: Added dependency on R &gt;= 3.5.0 because serialized objects in\n  serialize/load version 3 cannot be read in older versions of R.\n  File(s) containing such objects:\n    'intronets/inst/extdata/drugnet.rda'\n    'intronets/inst/extdata/github.rda' 'intronets/inst/extdata/gss.rda'\n    'intronets/inst/extdata/gss_ego.rda'\n    'intronets/inst/extdata/hi_tech.rda' 'intronets/inst/extdata/ifm.rda'\n    'intronets/inst/extdata/moreno.rda'\n    'intronets/inst/extdata/sampson.rda'\n    'intronets/inst/extdata/tradenets.rda'\n* building 'intronets_0.1.0.tar.gz'",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>A</span>¬† <span class='chapter-title'>R Basics and Resources</span>"
    ]
  },
  {
    "objectID": "r_basics.html#creating-and-manipulating-objects",
    "href": "r_basics.html#creating-and-manipulating-objects",
    "title": "Appendix A ‚Äî R Basics and Resources",
    "section": "A.9 Creating and Manipulating Objects",
    "text": "A.9 Creating and Manipulating Objects\nA major benefit of R over other statistical software programs is that it is object-oriented, rather than matrix-oriented like SPSS, Stata, and SAS. Instead of loading and manipulating a matrix, R allows you to create and manipulate a wider array of different types of objects, matrices included.\nLet‚Äôs create a very simple object. Then we can ‚Äúcall‚Äù that object to print it.\n\nx &lt;- 2 * 8\nx\n\n[1] 16\n\n\nThe arrow (‚Äú&lt;-‚Äù) serves as the assignment operator, which stores the information (the product of 2 and 8) in an object called x. If you are following along in RStudio, you‚Äôll note that the new object x now appears in the global environment. Note that you can name these objects whatever you want to (so long as the names do not include any spaces). And anytime you want to display an object in the console, you can just type its name and run the line.\nHere is a nifty shortcut for creating and printing objects in one step: wrap the entire line in parentheses.\n\n(x &lt;- 2 * 8)\n\n[1] 16\n\n\nObjects can also be created with the use of functions and by using already existing objects.\n\nz &lt;- sqrt(x)\nz\n\n[1] 4\n\n\nThese are all single element objects. Multiple elements can be combined into more complex objects called vectors or arrays by using the ‚Äúc()‚Äù command. Here are some examples.\n\nnumber_vec1 &lt;- c(1, 2, 3, 4, 5) \nnumber_vec2 &lt;- c(1:5) \nnumber_vec1\n\n[1] 1 2 3 4 5\n\nnumber_vec2\n\n[1] 1 2 3 4 5\n\ncharacter_vec &lt;- c(\"Hello\", \"from\", \"Raleigh\", \"NC\", \"!\")\ncharacter_vec\n\n[1] \"Hello\"   \"from\"    \"Raleigh\" \"NC\"      \"!\"      \n\nlogical_vec &lt;- c(TRUE, FALSE, TRUE, FALSE, TRUE)\nlogical_vec\n\n[1]  TRUE FALSE  TRUE FALSE  TRUE\n\n\nHere we can see three different types of vectors based on numbers, characters, and logical sequences. Once these objects are created, we might want to call on a specific element within the vector. This is called subsetting and involves the use of square brackets: ‚Äú[]‚Äù. See the examples below.\n\nnumber_vec1[3]\n\n[1] 3\n\ncharacter_vec[1:2]\n\n[1] \"Hello\" \"from\" \n\nlogical_vec[c(1,3,5)]\n\n[1] TRUE TRUE TRUE\n\n\nWhen these vectors are created, R stores information about the class of the object. You can use the ‚Äúclass‚Äù command to find out what type of object it is.\n\nclass(number_vec1)\n\n[1] \"numeric\"\n\nclass(character_vec)\n\n[1] \"character\"\n\nclass(logical_vec)\n\n[1] \"logical\"\n\n\nVectors can be further combined to create more complex objects. We can ‚Äúbind‚Äù vectors as rows (rbind) or as columns (cbind).\n\nrbind(number_vec1, character_vec, logical_vec)\n\n              [,1]    [,2]    [,3]      [,4]    [,5]  \nnumber_vec1   \"1\"     \"2\"     \"3\"       \"4\"     \"5\"   \ncharacter_vec \"Hello\" \"from\"  \"Raleigh\" \"NC\"    \"!\"   \nlogical_vec   \"TRUE\"  \"FALSE\" \"TRUE\"    \"FALSE\" \"TRUE\"\n\ncbind(number_vec1, character_vec, logical_vec)\n\n     number_vec1 character_vec logical_vec\n[1,] \"1\"         \"Hello\"       \"TRUE\"     \n[2,] \"2\"         \"from\"        \"FALSE\"    \n[3,] \"3\"         \"Raleigh\"     \"TRUE\"     \n[4,] \"4\"         \"NC\"          \"FALSE\"    \n[5,] \"5\"         \"!\"           \"TRUE\"     \n\n\nThese more complex objects have their own classifications. For example, we could create matrices, data frames, or lists (which combine multiple complex objects).\n\nx_mat &lt;- as.matrix(rbind(number_vec1, character_vec, logical_vec))\nx_df &lt;- as.data.frame(cbind(number_vec1, character_vec, logical_vec))\nx_list &lt;- as.list(c(x_mat,x_df))\n\nx_mat\n\n              [,1]    [,2]    [,3]      [,4]    [,5]  \nnumber_vec1   \"1\"     \"2\"     \"3\"       \"4\"     \"5\"   \ncharacter_vec \"Hello\" \"from\"  \"Raleigh\" \"NC\"    \"!\"   \nlogical_vec   \"TRUE\"  \"FALSE\" \"TRUE\"    \"FALSE\" \"TRUE\"\n\nx_df\n\n  number_vec1 character_vec logical_vec\n1           1         Hello        TRUE\n2           2          from       FALSE\n3           3       Raleigh        TRUE\n4           4            NC       FALSE\n5           5             !        TRUE\n\nx_list\n\n[[1]]\n[1] \"1\"\n\n[[2]]\n[1] \"Hello\"\n\n[[3]]\n[1] \"TRUE\"\n\n[[4]]\n[1] \"2\"\n\n[[5]]\n[1] \"from\"\n\n[[6]]\n[1] \"FALSE\"\n\n[[7]]\n[1] \"3\"\n\n[[8]]\n[1] \"Raleigh\"\n\n[[9]]\n[1] \"TRUE\"\n\n[[10]]\n[1] \"4\"\n\n[[11]]\n[1] \"NC\"\n\n[[12]]\n[1] \"FALSE\"\n\n[[13]]\n[1] \"5\"\n\n[[14]]\n[1] \"!\"\n\n[[15]]\n[1] \"TRUE\"\n\n$number_vec1\n[1] \"1\" \"2\" \"3\" \"4\" \"5\"\n\n$character_vec\n[1] \"Hello\"   \"from\"    \"Raleigh\" \"NC\"      \"!\"      \n\n$logical_vec\n[1] \"TRUE\"  \"FALSE\" \"TRUE\"  \"FALSE\" \"TRUE\" \n\n\nJust like with vectors, we can subset elements within these complex objects. For matrices and data frames, we can call on a row, a column, or specific row and column combinations. We can also call on elements in lists.\n\nx_mat[2,3]\n\ncharacter_vec \n    \"Raleigh\" \n\nx_df[,3]\n\n[1] \"TRUE\"  \"FALSE\" \"TRUE\"  \"FALSE\" \"TRUE\" \n\nx_list[[14]]\n\n[1] \"!\"\n\n\nData frames are especially useful objects because they allow us to examine and manipulate the columns as variables. We can call on a variable by using the ‚Äú$‚Äù.\n\nx_df$number_vec1\n\n[1] \"1\" \"2\" \"3\" \"4\" \"5\"\n\n\nYou can see that each number in the list is wrapped in quotation marks. That means it is being treated as a character vector. In fact, all of the variables are being treated as character vectors. So let‚Äôs change the variables to ensure that they are appropriately classified.\n\nx_df$number_vec1 &lt;- as.numeric(x_df$number_vec1)\nx_df$logical_vec &lt;- as.logical(x_df$logical_vec)\nclass(x_df$number_vec1)\n\n[1] \"numeric\"\n\nclass(x_df$logical_vec)\n\n[1] \"logical\"\n\n\nThere are times at which we will want to make multiple transformations simultaneously to an object such as a data frame. One way to make this easier is through the use of piping. This simplifies the commands by allowing you to identify the object first, then nest the transformations within the subsequent lines of code.\nLet‚Äôs do a quick demonstration. First, we will need to bring dplyr into the library in order to use one of the functions (mutate) from that package. Then we identify our data frame, which we follow with the pipe operator (‚Äú|&gt;‚Äù or sometimes ‚Äú%&gt;%‚Äù).\nThe goal is to create a new variable that is the product of the values in the numeric and logical vectors (TRUEs are treated as 1s and the FALSEs are treated as 0s). The mutate command does that calculation, creating a new variable called ‚Äúmultiply‚Äù. Then we can arrange the rows in the data frame in descending order based on the values from the multiply variable.\n\nlibrary(dplyr)\nx_df |&gt; \n  mutate(multiply = number_vec1*logical_vec) |&gt; \n  arrange(desc(multiply))\n\n  number_vec1 character_vec logical_vec multiply\n1           5             !        TRUE        5\n2           3       Raleigh        TRUE        3\n3           1         Hello        TRUE        1\n4           2          from       FALSE        0\n5           4            NC       FALSE        0\n\n\nThis does not make any changes to the data frame object itself ‚Äì it just makes the change and displays it. To change the data frame, we need to use the assignment operator (‚Äú&lt;-‚Äù).\n\nx_df &lt;- x_df |&gt; \n  mutate(multiply = number_vec1*logical_vec) |&gt; \n  arrange(desc(multiply))\n\nFinally, dplyr has a nice function called ‚Äúglimpse‚Äù that allows us to take a quick scan on a data frame. Below we contrast glimpse with ‚Äúhead‚Äù from the base package which shows us the first six lines of a data frame. We will alternate between both display strategies in this textbook.\n\nglimpse(x_df)\n\nRows: 5\nColumns: 4\n$ number_vec1   &lt;dbl&gt; 5, 3, 1, 2, 4\n$ character_vec &lt;chr&gt; \"!\", \"Raleigh\", \"Hello\", \"from\", \"NC\"\n$ logical_vec   &lt;lgl&gt; TRUE, TRUE, TRUE, FALSE, FALSE\n$ multiply      &lt;dbl&gt; 5, 3, 1, 0, 0\n\nhead(x_df)\n\n  number_vec1 character_vec logical_vec multiply\n1           5             !        TRUE        5\n2           3       Raleigh        TRUE        3\n3           1         Hello        TRUE        1\n4           2          from       FALSE        0\n5           4            NC       FALSE        0\n\n\nWe‚Äôll cover a lot more in the other chapters, but this should provide you with the basics for getting started. Good luck!",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>A</span>¬† <span class='chapter-title'>R Basics and Resources</span>"
    ]
  },
  {
    "objectID": "data_collect.html",
    "href": "data_collect.html",
    "title": "15¬† data_collect",
    "section": "",
    "text": "Content coming.",
    "crumbs": [
      "Appendix",
      "<span class='chapter-number'>15</span>¬† <span class='chapter-title'>data_collect</span>"
    ]
  },
  {
    "objectID": "interact_vis.html",
    "href": "interact_vis.html",
    "title": "16¬† interact_vis",
    "section": "",
    "text": "Content coming.",
    "crumbs": [
      "Appendix",
      "<span class='chapter-number'>16</span>¬† <span class='chapter-title'>interact_vis</span>"
    ]
  },
  {
    "objectID": "networks.html",
    "href": "networks.html",
    "title": "2¬† What is a Network?",
    "section": "",
    "text": "2.1 What is a Network?\nOne of our favorite TV shows is ‚ÄúFlight of the Conchords,‚Äù which was a sitcom about a New Zealand folk-rock band living in New York City. Below I will generate a network graph from the friendships shown in season 2 episode 4, ‚ÄúMurray Takes it to the Next Level.‚Äù Here‚Äôs a picture of the guys from that episode.\nTo begin with, I will load the igraph package into the library. If this is your first time using igraph, you will have to install it first by typing install.packages(‚Äúigraph‚Äù).\nlibrary(igraph)",
    "crumbs": [
      "Introduction",
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>What is a Network?</span>"
    ]
  },
  {
    "objectID": "networks.html#what-is-a-network",
    "href": "networks.html#what-is-a-network",
    "title": "2¬† What is a Network?",
    "section": "",
    "text": "Flight of the Conchords friends Jemaine, Brett, Murray, and Jim [Not shown: Greg]\n\n\n\n\n\n2.1.1 Networks as Edgelists\nA network is a series of dots or points in a graph, along with a series of lines that connect those dots. In social network analysis, the dots are often considered to be people, but they could also refer to various products of people, like books or corporations or events. The lines represent relationships. Often we are speaking of friendships, but they could represent marriages or mergers or memberships. Throughout the book, we will refer to the dots interchangeably as nodes or vertices and the lines as edges.\nNow let‚Äôs make a network. One easy way to do so is to create an edgelist, which shows a set of relationships between pairs of nodes in a network. The code below uses the make_graph function to create an igraph object. Each pair indicates a friendship. The first pair is ‚ÄúBrett‚Äù,‚ÄúJemaine‚Äù, so that means these two individuals are friends.\nNote also the ‚Äúdirected = FALSE‚Äù option. We need to include this option because while this is an undirected network, sometimes the lines in a graph are directed. For example, Brett might say that Jemaine is his friend, but Jemaine might not say that Brett is his friend. In that case, the graph would include a line from Brett to Jemaine, but no line from Jemaine to Brett. In the current case, we will treat this relationship as undirected (thus, ‚Äúdirected = FALSE‚Äù) and assume that any friendship is reciprocated.\n\nconchords &lt;- make_graph(edges=c(\"Brett\",\"Jemaine\", \n                           \"Brett\",\"Murray\", \n                           \"Jemaine\",\"Murray\", \n                           \"Murray\",\"Jim\", \n                           \"Greg\",\"Greg\"), directed = FALSE)\n\nYou may have noticed that the last line show a tie between Greg and himself. We included this because Greg is actually an isolate with no friends. (Sorry, Greg.) If we don‚Äôt include this self-tie (called a loop), then Greg won‚Äôt be included as a node in the network. To appropriately include Greg as an isolate, we can ‚Äúsimplify‚Äù the graph to remove the loop.\n\nconchords &lt;- simplify(conchords, \n                      remove.loops = TRUE)\n\n\n\n2.1.2 Networks as Graphs\nNow let‚Äôs plot out the network. For now, we will use R‚Äôs base plot function. In the next chapter we can work with ggraph to develop more detailed visualizations.\n\nplot(conchords)\n\n\n\n\n\n\n\n\nThese visualizations are referred to as network graphs or sociograms. They show all of the nodes and the lines that connect them. When we focus on a single node, we refer to that node as ego and all of the people connected to ego as their alters. A few elements of this network are important to point out.\n\nMurray has lots of friends. He is connected to Jim, Jemaine, and Brett. That means he has a degree of 3.\nGreg has no friends. We refer to him as an isolate.\nJim only has one friend (Murray). In this network, he is a pendant.\nMurray, Jemaine, and Brett form a clique. A clique is a subgroup in which all people are connected to one another.\n\n\n\n2.1.3 Network density\nAnother important feature of networks is their density. Mathematically, density is the proportion of ties present in the graph divided by all possible ties. An empty graph is when there are no ties between individuals in the network, which results in a density score of zero. A complete graph is when all possible ties are present, which results in a density score of one.\nThis network contains 4 ties. The number of possible ties in this network is calculated as (n*(n-1))/2, with n referring to the number of vertices. This translates to (5*(5-1))/2, or (5*4)/2, or 20/2, which equals 10. Therefore, the density of this network is equal to 4/10 = 0.4. This tells us that 40 percent of the total possible ties are present in this network. We can check this result below by using the density command from igraph to estimate this for us.\n\n4/(5*(5-1)/2)\n\n[1] 0.4\n\nedge_density(conchords)\n\n[1] 0.4\n\n\nRemember that this is a undirected network. If this was a directed network, density would be calculated differently. That‚Äôs because each pair of nodes (or dyads) would have the potential for two ties rather than just one (with each node potentially nominating the other as a friend). That effectively doubles the potential ties for the network. In that case, the denominator (all possible ties) for the density equation is n*(n-1), without being divided by 2 afterward.\nLet‚Äôs illustrate this by constructing a directed network. In the show, Murray asks Greg if he thinks they are friends. Greg says, ‚ÄúI like to think so, Murray.‚Äù To this, Murray responds: ‚ÄúWe‚Äôre not. We‚Äôre workmates.‚Äù We can take this as evidence that Greg nominates Murray as a friend (or sends Murray a directed friendship tie), whereas Murray does not nominate Greg as a friend. Armed with this information, let‚Äôs recreate the network as directed, with all ties reciprocated except for the Greg to Murray friendship. (Note that we don‚Äôt need to simplify this network because there are no more loops. Greg is incorporated into the network by virtue of his directed tie to Murray.)\n\nconchords_dir &lt;- make_graph(edges=c(\"Brett\",\"Jemaine\",\n                                    \"Jemaine\",\"Brett\",\n                                    \"Brett\",\"Murray\",\n                                    \"Murray\",\"Brett\",\n                                    \"Jemaine\",\"Murray\",\n                                    \"Murray\",\"Jemaine\",\n                                    \"Murray\",\"Jim\",\n                                    \"Jim\",\"Murray\",\n                                    \"Greg\",\"Murray\"), directed = TRUE)\n\nThis network contains 9 ties. The total possible ties is n*(n-1), or 20. 9 divided by 20 is equal to 0.45. Let‚Äôs check our work.\n\n9/(5*(5-1))\n\n[1] 0.45\n\nedge_density(conchords_dir)\n\n[1] 0.45",
    "crumbs": [
      "Introduction",
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>What is a Network?</span>"
    ]
  },
  {
    "objectID": "networks.html#igraph-objects",
    "href": "networks.html#igraph-objects",
    "title": "2¬† What is a Network?",
    "section": "2.2 igraph objects",
    "text": "2.2 igraph objects\nNow let‚Äôs examine the elements of the igraph object we created for the undirected conchords network.\n\nconchords\n\nIGRAPH 5f0aa7c UN-- 5 4 -- \n+ attr: name (v/c)\n+ edges from 5f0aa7c (vertex names):\n[1] Brett  --Jemaine Brett  --Murray  Jemaine--Murray  Murray --Jim    \n\n\nRight away we can see important information on the top line. This is an IGRAPH object. The ‚ÄúUN‚Äù tells us this is an undirected network. The 5 and 4 indicate that there are 5 nodes and 4 edges (remember, we removed the loop, so it‚Äôs only 4 edges).\nThe second line lists the attributes. The only attribute is name. In the parenthesis after name, the ‚Äúv‚Äù tells us this is a vertex attribute. This makes sense because each name is a characteristic of a node. To examine an attribute, we can use the following code. This is similar to the way one might request information from a variable in a data frame, which is done by naming the data frame, followed by the dollar sign ($), and then naming the variable. In this case, the call is preceded by a ‚ÄúV‚Äù to indicate that we are requesting a vertex attribute.\n\nV(conchords)$name\n\n[1] \"Brett\"   \"Jemaine\" \"Murray\"  \"Jim\"     \"Greg\"   \n\n\nAnd here we see a list of all of the nodes or vertices in the graph. It is also possible to have edge attributes, though we don‚Äôt have any edge attributes here.\nLet‚Äôs compare this network to the directed version.\n\nconchords_dir\n\nIGRAPH 5f2997a DN-- 5 9 -- \n+ attr: name (v/c)\n+ edges from 5f2997a (vertex names):\n[1] Brett  -&gt;Jemaine Jemaine-&gt;Brett   Brett  -&gt;Murray  Murray -&gt;Brett  \n[5] Jemaine-&gt;Murray  Murray -&gt;Jemaine Murray -&gt;Jim     Jim    -&gt;Murray \n[9] Greg   -&gt;Murray \n\n\nThis object tells us that the network is directed (‚ÄúDN‚Äù) and still contains the same number of vertices (5), but has more ties (9) because it includes reciprocated friendships plus Greg‚Äôs unreciprocated tie. Note, too, that the list of edges shows the direction of the friendship nominations represented by arrows (‚Äú-&gt;‚Äù) between each dyad. In the undirected network, the edges were separated by ‚Äú‚Äì‚Äù.\n\n2.2.1 Networks as Matrices\nNetworks can also be presented as matrices. We can view the matrix for this network by applying the as.matrix command to the conchords object.\n\nas.matrix(conchords)\n\n5 x 5 sparse Matrix of class \"dgCMatrix\"\n        Brett Jemaine Murray Jim Greg\nBrett       .       1      1   .    .\nJemaine     1       .      1   .    .\nMurray      1       1      .   1    .\nJim         .       .      1   .    .\nGreg        .       .      .   .    .\n\n\nThis matrix has 5 rows and 5 columns, each representing the 5 nodes in the network. The values represented in the matrix show whether or not a friendship exists. At row 1 (Brett) and column 2 (Jemaine), we see a value of 1, which indicates that Brett and Jemaine are friends. When a ‚Äú.‚Äù is present, this means there is no relationship between the two individuals. We tend to refer to these cells by their row number and then their column number. Therefore, cell (4,3) refers to the relationship between Jim and Murray, in which we find a value of 1 meaning that they are indeed friends.\nThe diagonal in the matrix includes all of the cells where the row number and the column number are the same: (1,1), (2,2), (3,3), (4,4), and (5,5). These are the loops ‚Äì the ties between the person and themselves. Loops are rarely meaningful in social network analysis so that are not often examined.\nBecause this is an undirected network, the values on the bottom left (below the diagonal) are mirrored on the upper right (above the diagonal). For example, the value for (2,1) is the same as (1,2).\nNow let‚Äôs contrast this matrix with the directed version.\n\nas.matrix(conchords_dir)\n\n5 x 5 sparse Matrix of class \"dgCMatrix\"\n        Brett Jemaine Murray Jim Greg\nBrett       .       1      1   .    .\nJemaine     1       .      1   .    .\nMurray      1       1      .   1    .\nJim         .       .      1   .    .\nGreg        .       .      1   .    .\n\n\nIn a directed network, the row values are read as send ties and the column values as received ties. In that sense, the value of 1 in (2,1) tells us that Jemaine sends a friendship nomination to Brett, or that Brett receives a friendship nomination from Jemaine. Alternatively, the value of 1 in (1,2) tells us that Brett sends a friendship nomination to Jemaine, or that Jemaine receives a friendship nomination from Brett.\nThis directed matrix is identical to the undirected version, except for one detail: it includes the directed tie from Greg to Murray (5,3). Murray does not return this friendship, so the corresponding reciprocal tie (3,5) above the diagonal is not present.\n\n\n2.2.2 Binary vs.¬†Valued Matrices\nThe ‚Äú.‚Äù values are essentially zeros in the matrix. In this way, we can consider this matrix to be a binary matrix as it contains only zeros or ones. Binary networks such as these only indicate whether or not a friendship exists. Valued matrices (or weighted matrices) would include other numbers as well. For example, we might want to give best friend relationships a value of 2 instead of a 1 to indicate a stronger friendship.\nIn the show, Brett and Jemaine are best friends and so are Murray and Jim. So let‚Äôs create a new edge attribute to distinguish best friend from friend relationships. We will assign new values to the edges. Note that we need to follow the exact sequence as they are listed in the conchords object. Let‚Äôs examine that again.\n\nconchords\n\nIGRAPH 5f0aa7c UN-- 5 4 -- \n+ attr: name (v/c)\n+ edges from 5f0aa7c (vertex names):\n[1] Brett  --Jemaine Brett  --Murray  Jemaine--Murray  Murray --Jim    \n\n\nThe first edge (Brett ‚Äì Jemaine) and the last edge (Murray ‚Äì Jim) are the best friend relationships. So we will create a new numerical vector to assign the appropriate weights to the edges.\n\nE(conchords)$weight &lt;- c(2, 1, 1, 2)\nconchords\n\nIGRAPH 5f0aa7c UNW- 5 4 -- \n+ attr: name (v/c), weight (e/n)\n+ edges from 5f0aa7c (vertex names):\n[1] Brett  --Jemaine Brett  --Murray  Jemaine--Murray  Murray --Jim    \n\n\nNow we can see that our new weight variable is listed as an edge attribute. Now let‚Äôs view the matrix again.\n\nas.matrix(conchords)\n\n5 x 5 sparse Matrix of class \"dgCMatrix\"\n        Brett Jemaine Murray Jim Greg\nBrett       .       1      1   .    .\nJemaine     1       .      1   .    .\nMurray      1       1      .   1    .\nJim         .       .      1   .    .\nGreg        .       .      .   .    .\n\n\nHmm‚Ä¶this does not show the new values, only the binary ones. We have to extract the matrix using an igraph function and include an option to apply the weighted values.\n\nas_adjacency_matrix(conchords, attr = \"weight\")\n\n5 x 5 sparse Matrix of class \"dgCMatrix\"\n        Brett Jemaine Murray Jim Greg\nBrett       .       2      1   .    .\nJemaine     2       .      1   .    .\nMurray      1       1      .   2    .\nJim         .       .      2   .    .\nGreg        .       .      .   .    .\n\n\nNow we can see the weighted values that indicate best friends.\nNote that that command used here called this an adjacency matrix. That‚Äôs because this is a one mode network that shows the extent to which a single set of vertices is adjacent to one another. Later in the book we will discuss two mode networks that show the relationships between two different sets of nodes. For example, imagine we are interested in connections between people and the voluntary organizations they are involved in. The corresponding incidence matrix would list the people along the rows, the organizations along the columns, and the cells would show which people belong to which organizations. For the time being, we can set aside the idea of two mode networks and focus only on one mode networks.\n\n\n2.2.3 Creating a Graph from an Adjacency Matrix and a Data Frame\nEarlier we demonstrated how to create an igraph object from an edgelist. However, you might have network data in other formats. For example, how can we create an igraph object by starting with an adjacency matrix? Below we will extract the adjacency matrix from the conchords network and then use the graph_from_adjacency_matrix command to create a new (duplicated) igraph object. We need to point out the adjacency matrix object and indicate whether the graph is directed or undirected, as well as if it is weighted or not.\n\nconchord_mat &lt;- as_adjacency_matrix(conchords, attr = \"weight\")\nconchord2 &lt;- graph_from_adjacency_matrix(\n  adjmatrix = conchord_mat,\n  mode = \"undirected\",\n  weighted = TRUE)\nconchord2\n\nIGRAPH 5f9f5c0 UNW- 5 4 -- \n+ attr: name (v/c), weight (e/n)\n+ edges from 5f9f5c0 (vertex names):\n[1] Brett  --Jemaine Brett  --Murray  Jemaine--Murray  Murray --Jim    \n\n\nHere you can see that the conchord igraph object was effectively duplicated.\nFinally, you might have network data in the form of data frames, which are data matrices that include a set of cases in the rows and variables in the columns. There are two main pieces of network information that could be contained in a data frame: 1) the vertex attributes and 2) the edge attributes.\nLet‚Äôs create two separate data frames with this information for the conchords network, starting with the vertex attributes. In the code below, we include the names of the people in the network, plus let‚Äôs add two other attributes. In the show, Brett and Jemaine are both musicians, so we will give them a value of 1 for a musician variable. Also, Brett, Jemaine, and Murray are originally from New Zealand, so they will receive a value of 1 for a nz variable.\n\nvertex_df &lt;- as.data.frame(V(conchords)$name)\ncolnames(vertex_df) &lt;- c(\"name\")\nvertex_df$musician &lt;- c(1,1,0,0,0)\nvertex_df$nz &lt;- c(1,1,1,0,0)\nvertex_df\n\n     name musician nz\n1   Brett        1  1\n2 Jemaine        1  1\n3  Murray        0  1\n4     Jim        0  0\n5    Greg        0  0\n\n\nNext let‚Äôs create the edge attribute data frame. The first line of the code below extracts the edgelist and creates a data frame. That data frame contains two columns, one for each of the two people who are linked. We then change the column names to indicate that the first person as the sender of the tie and the second column as the receiver of the tie. Remember that we are treating this network as undirected, which means that all ties are reciprocated. So in that sense we don‚Äôt have a clear sender or receiver, but still we need these specific column headings in order to convert the data frame to an igraph object later.\nThe third line of the code assigns the weight of the tie to a separate column called ‚Äúweight.‚Äù Then we can view the data frame.\n\nedge_df &lt;- as.data.frame(as_edgelist(conchords))\ncolnames(edge_df) &lt;- c(\"from\",\"to\")\nedge_df$weight &lt;- E(conchords)$weight\nedge_df\n\n     from      to weight\n1   Brett Jemaine      2\n2   Brett  Murray      1\n3 Jemaine  Murray      1\n4  Murray     Jim      2\n\n\nUsing these two data frames, we can create a new igraph object. We first need to assign the edge_df as ‚Äúd‚Äù, then indicate that those edges are undirected, and finally add the vertex attributes.\n\nconchord3 &lt;- graph_from_data_frame(\n  d = edge_df,\n  directed = FALSE,\n  vertices = vertex_df)\nconchord3\n\nIGRAPH 5fb0594 UNW- 5 4 -- \n+ attr: name (v/c), musician (v/n), nz (v/n), weight (e/n)\n+ edges from 5fb0594 (vertex names):\n[1] Brett  --Jemaine Brett  --Murray  Jemaine--Murray  Murray --Jim    \n\n\nAs you can see, this creates a new igraph object named conchord3. This object is the same as the earlier ones we created, except that it now includes new vertex attributes for musician and for New Zealand.\nIn addition to covering basic terminology, this chapter showed how to view networks in different formats (as an edgelist, as a graph, and as a matrix), how to identify and manipulate igraph objects, and how to create igraph objects from different starting points (an edgelist, an adjacency matrix, and a data frame). The next chapter will get into more details about visualizing igraph networks in ggraph.\nAnd if we have piqued your interest about the Flight of the Conchords, you can learn more about the show here.",
    "crumbs": [
      "Introduction",
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>What is a Network?</span>"
    ]
  },
  {
    "objectID": "communities.html",
    "href": "communities.html",
    "title": "7¬† Communities",
    "section": "",
    "text": "7.1 Communities\nWhen examining a network graph, one of the first things people look for is elements of the graph that comprise subgroups. These subgroups are often comprised of nodes that are highly connected relative to the rest of the graph. By noting the different subgroups, we can learn something about how the people in the network see themselves and in interact with one another.\nWhile the ‚Äúeye-test‚Äù allows us to visually demarcate different subgroups or communities within a network, community detection can be better deduced through the use of a series of algorithms. We will explore some examples of this below. First it will be necessary to load a few R packages: igraph for conducting network analysis, ggraph for presenting the graphs, dplyr for manipulating the data, patchwork for presenting side-by-side graphs, and ggforce for drawing polygons.\nlibrary(intronets)\nlibrary(igraph)\nlibrary(ggraph)\nlibrary(dplyr)\nlibrary(patchwork)\nlibrary(ggforce)",
    "crumbs": [
      "Analysis",
      "<span class='chapter-number'>7</span>¬† <span class='chapter-title'>Communities</span>"
    ]
  },
  {
    "objectID": "communities.html#load-network-data",
    "href": "communities.html#load-network-data",
    "title": "7¬† Communities",
    "section": "7.2 Load network data",
    "text": "7.2 Load network data\nIn the 1960s, a Cornell University PhD student, Samuel Franklin Sampson decided to conduct his dissertation research through the ethnographic study of monks in a Northeastern US monastery. He was interested in understanding and reporting on the social interactions among the monks. Interestingly enough, the monks had a falling out during his data collection period which resulted in several monks being expelled from the monastery!\nWe will use the network data that Sampson collected to detect clusters and communities among the cloistered. The code below loads the data.\n\nload_nets(\"sampson.rda\")\nsampson\n\nIGRAPH 8399fc3 U--- 18 60 -- \n+ attr: cloisterville (v/l), group (v/c), na (v/l), vertex.names (v/c)\n+ edges from 8399fc3:\n [1]  1-- 2  1-- 3  2-- 3  1-- 5  4-- 5  1-- 6  4-- 6  5-- 6  1-- 7  2-- 7\n[11]  1-- 8  2-- 8  4-- 8  6-- 8  7-- 8  5-- 9  6-- 9  8-- 9  4--10  5--10\n[21]  8--10  9--10  4--11  5--11  8--11  1--12  2--12  7--12  9--12  3--13\n[31]  5--13  7--13 10--13  1--14  2--14 10--14 11--14 12--14  1--15  2--15\n[41]  5--15  7--15 12--15 14--15  1--16  2--16  7--16  9--16 11--16 12--16\n[51] 15--16  2--17  3--17 13--17  1--18  2--18  3--18  7--18 13--18 17--18\n\n\nWe can see here that this network contains 18 monks and 60 friendship ties among them. Originally, Sampson asked the monks to rank order their friendships; the ties here represent being in the top-three friendships. The network has been coerced such that any top-three nomination is treated as a symmetric friendship relationship.\nLet‚Äôs display the monk‚Äôs friendships. The graph below shows a fairly dense network with many overlapping friendships among the monks.\n\nggraph(sampson, layout = \"fr\") + \n  geom_edge_link(color = \"darkgrey\") +\n  geom_node_label(aes(label = vertex.names), \n                  color = \"royalblue\") +\n  theme_void()",
    "crumbs": [
      "Analysis",
      "<span class='chapter-number'>7</span>¬† <span class='chapter-title'>Communities</span>"
    ]
  },
  {
    "objectID": "communities.html#cliques",
    "href": "communities.html#cliques",
    "title": "7¬† Communities",
    "section": "7.3 Cliques",
    "text": "7.3 Cliques\nSubgroups tend to be identified on the basis of cohesion, which is determined by dense connections among actors within a network. There are several ways to identify these communities. The most extreme way to define a subgroup is by identifying cliques ‚Äì maximally connected subcomponents of a graph. In other words, a clique is a set of actors in which every subgroup member is directly connected to everyone else in the group. This subgroup therefore represents a complete subgraph. Cliques are comprised of at least three vertices.\nR can provide a list of all cliques in the Sampson network. But because this is a dense network, there are many cliques. Knowing that cliques are at least the size of 3, let‚Äôs examine all cliques the size of 5 or more.\n\ncliques(sampson, min = 5)\n\n[[1]]\n+ 5/18 vertices, from 8399fc3:\n[1]  1  2 12 15 16\n\n[[2]]\n+ 5/18 vertices, from 8399fc3:\n[1]  1  2 12 14 15\n\n[[3]]\n+ 5/18 vertices, from 8399fc3:\n[1]  2  7 12 15 16\n\n[[4]]\n+ 6/18 vertices, from 8399fc3:\n[1]  1  2  7 12 15 16\n\n[[5]]\n+ 5/18 vertices, from 8399fc3:\n[1]  1  7 12 15 16\n\n[[6]]\n+ 5/18 vertices, from 8399fc3:\n[1]  1  2  7 12 16\n\n[[7]]\n+ 5/18 vertices, from 8399fc3:\n[1]  1  2  7 15 16\n\n[[8]]\n+ 5/18 vertices, from 8399fc3:\n[1]  1  2  7 12 15\n\n\nThe results show 8 different cliques the size of 5 or more. The largest clique includes 6 individuals who are all interconnected. Below we identify those 6 and distinguish them from the others in the network graph. First, we identify the numerical set of monks in the largest clique. Then we assign a logical value as a vertex attribute for monks who are either in (TRUE) or out of (FALSE) the largest clique. That information can then be used to color the labels in the graph.\n\n(max_clique &lt;- as.numeric(unlist(cliques(sampson, min = 6))))\n\n[1]  1  2  7 12 15 16\n\nV(sampson)$clique &lt;- seq_len(vcount(sampson)) %in% max_clique\n\nggraph(sampson, layout = \"fr\") + \n  geom_edge_link(color = \"darkgrey\") +\n  geom_node_label(aes(label = vertex.names,\n                      color = clique)) +\n  theme_void()\n\n\n\n\n\n\n\n\nHere we can see which monks are part of the largest clique: Winfrid, Mark, Boniface, Albert, Gregory, and John Bosco.",
    "crumbs": [
      "Analysis",
      "<span class='chapter-number'>7</span>¬† <span class='chapter-title'>Communities</span>"
    ]
  },
  {
    "objectID": "communities.html#coreness",
    "href": "communities.html#coreness",
    "title": "7¬† Communities",
    "section": "7.4 Coreness",
    "text": "7.4 Coreness\nCoreness provides another way to identify cohesive subgroups in social networks. It is more relaxed in that group members do not need to all be directly connected to one another as with a clique. Instead, group membership is defined by their degree value. Specifically, a k-core is a maximally connected subgroup in which each node is adjacent to at least k other nodes. Nodes with lower k values tend to be on the periphery of a graph, whereas nodes with higher k values constitute a dense core.\nBelow we can use the coreness function to obtain k-core estimates for each node. Then we can examine the frequency of k values.\n\ncore &lt;- coreness(sampson)\ntable(core)\n\ncore\n 4  5 \n 4 14 \n\n\nBecause this is such a dense network, we do not see much variation in coreness. A few monks (4) have a coreness value of 4, whereas the remaining monks (14) have a coreness value of 5, representing the core of this network. Being part of the core means that they belong to a group of students where every member has a degree of at least 5.\nLet‚Äôs graph coreness. We assign the core estimate as a vertex attribute. When graphing the network, we can use the coreness attribute to size the node labels, while still showing the clique membership.\n\nV(sampson)$coreness &lt;- core\n\nggraph(sampson, layout = \"fr\") + \n  geom_edge_link(color = \"darkgrey\") +\n  geom_node_label(aes(label = vertex.names,\n                      color = clique, \n                      size = as.factor(coreness))) +\n  theme_void()\n\n\n\n\n\n\n\n\nThe graph shows that the core group of monks includes the largest clique, plus several other monks who are not part of the largest clique. The peripheral monks are Basil, Simplicius, Amand, and Elias.",
    "crumbs": [
      "Analysis",
      "<span class='chapter-number'>7</span>¬† <span class='chapter-title'>Communities</span>"
    ]
  },
  {
    "objectID": "communities.html#modularity-group-attributes",
    "href": "communities.html#modularity-group-attributes",
    "title": "7¬† Communities",
    "section": "7.5 Modularity: Group attributes",
    "text": "7.5 Modularity: Group attributes\nCommunities are often defined based on shared personal attributes among group members. Some attributes might be especially salient for forming communities, whereas other attributes may matter very little. Network analysts can use statistics to assess the extent to specific attributes matter more than others for community formation.\nThe concept of modularity refers to the extent that relationships in a network are defined by group membership. It is an estimate of density among in-group members relative to out-group members. A value of 1 reflects perfect modularity, in that all individuals connect to all other individuals from the same group and not to any out-group members. A value of -1 indicates that people only connect to out-group members. A value of 0 indicates a random mix of ties that is completely unrelated to group membership.\nSome of the monks joined the monastery after participating in a minor seminary (referred to by Sampson as ‚Äúcloisterville‚Äù) prior to joining the monastery. To what extent did this earlier experience shape their friendship relationships in the monastery? We can use the modularity estimate to help answer this question.\n\nV(sampson)$cloisterville\n\n [1]  TRUE  TRUE  TRUE  TRUE  TRUE FALSE  TRUE FALSE FALSE FALSE FALSE FALSE\n[13] FALSE FALSE FALSE FALSE FALSE FALSE\n\n(cloister_mod &lt;- modularity(sampson, \n                            as.factor(V(sampson)$cloisterville)))\n\n[1] -0.07347222\n\n\nThe modularity estimate is negative and close to zero. This suggests that previous shared experiences in cloisterville had little influence on the later friendship relationships of these aspiring monks. This is an interesting ‚Äì and somewhat surprising ‚Äì finding that helps us to rule out a reason as to why some monks were expelled and others were not.",
    "crumbs": [
      "Analysis",
      "<span class='chapter-number'>7</span>¬† <span class='chapter-title'>Communities</span>"
    ]
  },
  {
    "objectID": "communities.html#community-detection",
    "href": "communities.html#community-detection",
    "title": "7¬† Communities",
    "section": "7.6 Community Detection",
    "text": "7.6 Community Detection\nSo far we have addressed modularity in terms of vertex attributes that define shared experiences (attending cloisterville). But one of the most exciting developments within social network analysis is the ability to define group membership on the basis of ties rather than node-level attributes.\nSeveral different community detection algorithms have been established in order to accomplish this task. While there are many different types of algorithms, each with their own approach to assigning nodes to groups, they all share a general goal of identifying subgroups that maintain relatively high levels of group modularity.\nLet‚Äôs consider three different modularity algorithms. First, the Louvain algorithm emphasizes modularity optimization. It assigns and reassigns nodes to different groups in order to identify a maximal modularity score. Second, edge betweenness identifies distinct groups by iteratively removing from the network edges that constitute bridges between different communities. Third, random walk estimates multiple random pathways between nodes across the network, clustering nodes into communities based on the extent to which they frequently appear as part of the same paths.\nBelow we estimate these three algorithms, apply the membership vector to the igraph object, and compare the modularity scores to the cloisterville attributes.\n\n### Louvain\nlouvain &lt;- cluster_louvain(sampson)\nV(sampson)$louvain &lt;- membership(louvain)\nlouvain_mod &lt;- modularity(sampson, V(sampson)$louvain)\n\n### Edge betweenness\nedgeb &lt;- cluster_edge_betweenness(sampson)\nV(sampson)$edgeb &lt;- membership(edgeb)\nedgeb_mod &lt;- modularity(sampson, V(sampson)$edgeb)\n\n### walktrap\nwalktrap &lt;- cluster_walktrap(sampson)\nV(sampson)$walktrap &lt;- membership(walktrap)\nwalktrap_mod &lt;- modularity(sampson, V(sampson)$walktrap)\n\n## tabulating modularity scores\nrbind(louvain_mod,edgeb_mod,walktrap_mod,cloister_mod)\n\n                    [,1]\nlouvain_mod   0.28986111\nedgeb_mod     0.28986111\nwalktrap_mod  0.28986111\ncloister_mod -0.07347222\n\n\nWhat can we tell from this comparison of modularity scores? Each algorithm does a better job of capturing community clustering than the cloisterville experience. In fact, the values for Louvain, edge betweenness, and walktrap are all identical, suggesting that they do an equally good job of differentiating friendship communities among the monks.\nLet‚Äôs visually inspect the community memberships, using Louvain as the prime example. We‚Äôll save this graph so it can be compared later.\n\ng1 &lt;- ggraph(sampson, layout = \"fr\") + \n  geom_edge_link(color = \"darkgrey\") +\n  geom_node_label(aes(label = vertex.names,\n                      color = as.factor(louvain)),\n                  show.legend = FALSE) +\n  ggtitle(paste(\"Louvain (modularity =\", round(louvain_mod, 3), \")\")) +\n  theme_void()\ng1\n\n\n\n\n\n\n\n\nHow do these communities compare to Sampson‚Äôs coding of different friendship groups? He identified three groups which are summarized below.\n\ntable(V(sampson)$group)\n\n\n   Loyal Outcasts    Turks \n       7        4        7 \n\n\nThe Loyal Opposition entered the monastery first. The Young Turks entered later and questioned existing practices. Several of the monks (‚ÄúOutcasts‚Äù) were expelled from the monastery as a result of the conflict. Let‚Äôs compare the community detection groups to the observed groups.\n\ng2 &lt;- ggraph(sampson, layout = \"fr\") + \n  geom_edge_link(color = \"darkgrey\") +\n  geom_node_label(aes(label = vertex.names,\n                      color = group)) +\n  ggtitle(paste(\"Sampson groups\")) +\n  theme_void()\n\ng1 + g2 \n\n\n\n\n\n\n\n\nAs you can see, the Louvain community detection algorithm perfectly predicted membership in each of the groups coded by Sampson. (Just note that the colors are switched across the two graphs, such that the Turks are red in the Louvain graph and blue in the Sampson graph.)",
    "crumbs": [
      "Analysis",
      "<span class='chapter-number'>7</span>¬† <span class='chapter-title'>Communities</span>"
    ]
  },
  {
    "objectID": "communities.html#community-polygons",
    "href": "communities.html#community-polygons",
    "title": "7¬† Communities",
    "section": "7.7 Community Polygons",
    "text": "7.7 Community Polygons\nFinally, it can sometimes be useful to distinguish between network communities by displaying a polygon that wraps around the groups. Below we apply the polygons to the walktrap results by adding an extra geom_mark_hull layer to the earlier Louvain plot.\n\ng1 + geom_mark_hull(aes(x = x, y = y,\n                        group = louvain, \n                        fill = as.factor(louvain)), \n                 concavity = 5, expand = unit(2, \"mm\"), alpha = 0.25,\n                 show.legend = FALSE)\n\n\n\n\n\n\n\n\nThis plot shows the distinct friendship communities among the monks.\nCommunity detection algorithms are very useful for identifying subgroups within social networks. That said, there is not one best community detection algorithm to use for all analyses. Your decision depends on the type of network you are examining, the questions you are proposing, and the micro-interactional processes that are central to the formation and maintenance of network ties.",
    "crumbs": [
      "Analysis",
      "<span class='chapter-number'>7</span>¬† <span class='chapter-title'>Communities</span>"
    ]
  },
  {
    "objectID": "communities.html#references",
    "href": "communities.html#references",
    "title": "7¬† Communities",
    "section": "7.8 References",
    "text": "7.8 References\nFor more on the Sampson Monastery study‚Ä¶\n\nBreiger R., Boorman S. and Arabie P. (1975). An algorithm for clustering relational data with applications to social network analysis and comparison with multidimensional scaling. Journal of Mathematical Psychology, 12, 328-383.\nSampson, S. F. (1969). Crisis in a cloister. Unpublished doctoral dissertation, Cornell University.",
    "crumbs": [
      "Analysis",
      "<span class='chapter-number'>7</span>¬† <span class='chapter-title'>Communities</span>"
    ]
  },
  {
    "objectID": "centrality.html",
    "href": "centrality.html",
    "title": "5¬† Centrality and Centralization",
    "section": "",
    "text": "5.1 Central Actors and Centralized Networks\nMy interest in social networks was sparked by my fascination with peer group dynamics when I was in middle school. Some of my classmates were very popular in that they had lots of friends, whereas others tended to keep to themselves or had only one or two close friendships. While I never quite fit into either extreme, I was, for a time, quite envious of the popular kids in my school. I was fascinated by how those students could draw the attention and admiration of my classmates, as well as influence their opinions.\nThis is a common fascination about social networks. Some actors play an especially important role in social networks by virtue of their centrality in the network. Being central in a network tends to provide people with prominence (they are easy to identify), prestige (they have higher status), and power (they have the ability to influence others).\nCentrality is a node-level attribute. But entire networks can be defined by their level of centralization, which refers to the extent that a network is dominated by a central actor. It is easy to imagine a situation whereby the social relationships for one grade level might be centralized around a singularly popular individual, whereas the relationships in another grade level might be less focused on a single person. Variation in centralization across graphs is likely to have important implications for learning, mental health, and many other outcomes across those different contexts.\nThis chapter will address different ways of measuring centrality and centralization in social networks. We will examine a historical example of centrality and its consequences for power dynamics among prominent families in Renaissance Florence. We will also consider the general tendencies that often produce highly centralized networks and how those tendencies are reflected in modern and even digital social networks.\nFirst, let‚Äôs read in our libraries. We will use intronets to access the data, igraph to manipulate network objects, dplyr for data management, and ggraph to visualize the networks.\nlibrary(intronets)\nlibrary(igraph)\nlibrary(dplyr)\nlibrary(ggraph)",
    "crumbs": [
      "Analysis",
      "<span class='chapter-number'>5</span>¬† <span class='chapter-title'>Centrality and Centralization</span>"
    ]
  },
  {
    "objectID": "centrality.html#measuring-centrality",
    "href": "centrality.html#measuring-centrality",
    "title": "5¬† Centrality and Centralization",
    "section": "5.2 Measuring Centrality",
    "text": "5.2 Measuring Centrality\nHow do we know if one person is more central to a network than another? There are actually several answers to this question and those answers depend on which aspect of centrality is most important. Is a central actor someone who has lots of friends? Someone who is relatively close to all others based on relationship path distances? Or someone who has the ability to control the flow of information that passes through the different relationships?\nLet‚Äôs examine these ideas by examining a network of inter-marriage relationships between families in 15th Century Florence, Italy. Constructed based on historical marriage records, these families were prominent merchants and financiers during the Renaissance. At this time and place in history, marriage bonds were important because allowed families to ally together to support their business interests and their political aspirations.\nThe code below loads in the marriage network data and examines its contents.\n\nload_nets(\"ifm.rda\")\nifm\n\nIGRAPH abdc5da U--- 16 20 -- \n+ attr: na (v/l), seats (v/n), ties (v/n), vertex.names (v/c), wealth\n| (v/n), na (e/l)\n+ edges from abdc5da:\n [1]  1-- 9  2-- 6  2-- 7  2-- 9  3-- 5  3-- 9  4-- 7  4--11  4--15  5--11\n[11]  5--15  7-- 8  7--16  9--13  9--14  9--16 10--14 11--15 13--15 13--16\n\n\nThe igraph object contains 16 families and 20 marriage bonds between them. Information is provided about the number of seats held by family members in the civic council and the family‚Äôs net wealth. We will later use these variables to consider how each family‚Äôs marriage network centrality is related to their political and economic power.\nLet‚Äôs visualize the network of relationships.\n\nggraph(ifm, layout = \"fr\") +\n  geom_edge_link(color = \"grey\", alpha = 0.7) +\n  geom_node_label(aes(label = vertex.names)) +\n  theme_void()\n\n\n\n\n\n\n\n\n\n5.2.1 Degree centrality\nWhich of these families is most central? The simplest way to answer this question is to rank the families by the number of ties that they have to other families. This number is their degree, which is why this is referred to as degree centrality. The idea is that a family is central to the network if it maintains many ties.\nThe following code obtains the degree values for each family and assigns those values to the graph as vertex attributes. Then we can create a separate data frame to compare the degree scores for each family.\n\nV(ifm)$deg &lt;- degree(ifm)\ncent &lt;- as.data.frame(cbind(V(ifm)$vertex.names,\n                            V(ifm)$deg))\ncolnames(cent) &lt;- c(\"family\",\"degree\")\ncent$degree &lt;- as.numeric(cent$degree)\ncent |&gt; \n  arrange(desc(degree))\n\n         family degree\n1        MEDICI      6\n2      GUADAGNI      4\n3       STROZZI      4\n4       ALBIZZI      3\n5      BISCHERI      3\n6    CASTELLANI      3\n7       PERUZZI      3\n8       RIDOLFI      3\n9    TORNABUONI      3\n10    BARBADORI      2\n11     SALVIATI      2\n12   ACCIAIUOLI      1\n13       GINORI      1\n14 LAMBERTESCHI      1\n15        PAZZI      1\n16        PUCCI      0\n\n\nThe results show that the family with the highest degree (the most marriage bonds) is the Medici family. You may have heard of this family before. The Medicis were considered to be the most powerful family in Renaissance Florence. The degree centrality measure suggests that the Medicis helped consolidate their power by developing many influential marriage ties.\nThe raw degree number is fine for estimating centrality among nodes in a single network. But it can be problematic when comparing centrality scores across different networks. For example, 6 is a high degree score in this network, but it might not be a high score for a sample of elite Venetian families. For this we need to standardize the degree count such that it reflects the number of ties to other alters as a proportion of all possible ties. All possible ties to others is equal to the total number of families (n) minus 1. The standardized degree centrality score is estimated below. Note that the maximum value is 0.4, which is the score for Medici. This tells us that Medici is connected to 40% of the other families by marriage (6/15 = 0.4).\n\nn &lt;- gorder(ifm)  \ndeg_cent &lt;- cent$degree/(n - 1)\nsummary(deg_cent)\n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n0.00000 0.06667 0.20000 0.16667 0.20000 0.40000 \n\n\nOne final thing to note about degree centrality: this network is undirected because we are treating marriages as mutually agreed upon relationships. In directed networks, one can estimate separate indegree and outdegree centrality scores.\n\n\n5.2.2 Closeness centrality\nAnother way to think about centrality is based on the notion of closeness. We can think about distance in a network graph based on the number of paths (along the network edges) it would take to get from one node to the next. For example, Albizzi has to travel a distance of two paths to reach Barbadori (Albizzi ‚Äì Medici, Medici ‚Äì Barbadori), compared to a distance of one path for Castellani to reach Barbadori (Castellani ‚Äì Barbadori). In this way, Castellani is one path length closer to Barbadori than is Albizzi.\nTo estimate each family‚Äôs closeness centrality to the entire network, we would need to calculate the average geodesic (shortest path length) for every combination of families in the graph. The code below generates a distance matrix that displays these values. Here I will show only the distances between the first five families in the matrix. Note that it shows the correct path distances, as described above, between Albizzi and Barbadori (2), as well as Castellani and Barbadori (1).\n\ndist_mat &lt;- distances(ifm)\nrownames(dist_mat) &lt;- V(ifm)$vertex.names\ncolnames(dist_mat) &lt;- V(ifm)$vertex.names\ndist_mat[1:5,1:5]\n\n           ACCIAIUOLI ALBIZZI BARBADORI BISCHERI CASTELLANI\nACCIAIUOLI          0       2         2        4          3\nALBIZZI             2       0         2        2          3\nBARBADORI           2       2         0        3          1\nBISCHERI            4       2         3        0          2\nCASTELLANI          3       3         1        2          0\n\n\nTo estimate closeness centrality, one starts by averaging the values from this distance matrix for each family. Then we take the inverse (1 divided by the average distance) to obtain the closeness estimate. The closeness command in igraph does this calculation for us.\n\nclose &lt;- closeness(ifm)\ncent$close &lt;- close\ncent |&gt; \n  arrange(desc(close)) |&gt; \n  select(family,close)\n\n         family      close\n1        MEDICI 0.04000000\n2       RIDOLFI 0.03571429\n3       ALBIZZI 0.03448276\n4    TORNABUONI 0.03448276\n5      GUADAGNI 0.03333333\n6     BARBADORI 0.03125000\n7       STROZZI 0.03125000\n8      BISCHERI 0.02857143\n9    CASTELLANI 0.02777778\n10     SALVIATI 0.02777778\n11   ACCIAIUOLI 0.02631579\n12      PERUZZI 0.02631579\n13       GINORI 0.02380952\n14 LAMBERTESCHI 0.02325581\n15        PAZZI 0.02040816\n16        PUCCI        NaN\n\n\nAgain the Medici family shows up as the most central family in the network, indicating that it has the lowest average path distance to all other families. Note that Pucci does not receive a closeness centrality score. This is because Pucci is an isolate and cannot reach any of the other families.\n\n\n5.2.3 Betweenness Centrality\nOne final way to evaluate centrality is to assess the extent to which a node is a central hub in the network, such that knowledge or information might frequently travel through the node. In this way, a central hub is a node that is between other nodes.\nAgain we can return to the idea of geodesic (shortest path) distances between nodes. To the extent that families are frequently on these geodesic paths, they have high betweenness centrality. Let‚Äôs look at an example. The following code obtains the geodesic path from Albizzi (vertex #2) to Pazzi (vertex #10).\n\ngeodesic_2to10 &lt;- all_shortest_paths(ifm, from = \"2\", to = \"10\")\nvec_2to10 &lt;- as.vector(geodesic_2to10$res[[1]])\nV(ifm)$vertex.names[vec_2to10]\n\n[1] \"ALBIZZI\"  \"MEDICI\"   \"SALVIATI\" \"PAZZI\"   \n\n\nBy virtue of being on this geodesic path, Medici and Salviati are in a central location that allows them control the flow of resources between Albizzi and Pazzi or otherwise broker relationships between those two families.\nCalculating betweenness centrality therefore involves estimating the number of geodesic paths that each family is part of. By including the normalized option, the betweenness count is divided by the total possible geodesic paths on which a family could possibly be included.\n\nbetween &lt;- betweenness(ifm, normalized = T)\ncent$between &lt;- between\ncent |&gt; \n  arrange(desc(between)) |&gt; \n  select(family,between)\n\n         family    between\n1        MEDICI 0.45238095\n2      GUADAGNI 0.22063492\n3       ALBIZZI 0.18412698\n4      SALVIATI 0.12380952\n5       RIDOLFI 0.09841270\n6      BISCHERI 0.09047619\n7       STROZZI 0.08888889\n8     BARBADORI 0.08095238\n9    TORNABUONI 0.07936508\n10   CASTELLANI 0.04761905\n11      PERUZZI 0.01904762\n12   ACCIAIUOLI 0.00000000\n13       GINORI 0.00000000\n14 LAMBERTESCHI 0.00000000\n15        PAZZI 0.00000000\n16        PUCCI 0.00000000\n\n\nOnce again, Medici shows up as the most central family in the network, and by a wide margin. Medici‚Äôs betweenness centrality score suggests that it resides on around 45 percent of all geodesic paths in the network. Further inspection of the graph reveals why. Below we highlight all of the direct paths to Medici.\n\nmedici_id &lt;- as.numeric(which(V(ifm)$vertex.names == \"MEDICI\"))\nE(ifm)$medici_edge &lt;- E(ifm) %in% incident(ifm, medici_id, mode = \"all\")\n\nggraph(ifm, layout = \"fr\") +\n  geom_edge_link(aes(color = medici_edge), width = 2, \n                 alpha = 0.7, show.legend = F) +\n  geom_node_label(aes(label = vertex.names)) +\n  theme_void()\n\n\n\n\n\n\n\n\nMedici is on nearly all of the geodesic paths that involve Acciaiuoli, Salviati, and Pazzi (the only exception is for the geodesic between Salviati and Pazzi). That puts Medici in a strong position to broker deals between those families and all others in the network.\n\n\n5.2.4 Centrality Extensions\nResearchers and statisticians have developed many other ways to measure centrality in networks. The reference section includes further citations to explore. But I wanted to mention one commonly used measure: eigenvector centrality. This is an attempt to improve on closeness centrality by weighting a node‚Äôs closeness to other nodes based on how central those target nodes are.\nFor example, the closeness centrality score treats the distance between a family and Ginori as being as important as the distance to Medici. The eigenvector centrality score gives greater weight to path distances that target Medici because Medici is the most central family. In this way, eigenvector centrality measures the extent to which families are close to families that are highly central.\n\neigen &lt;- eigen_centrality(ifm)\ncent$eigen &lt;- round(eigen$vector, 4)\ncent |&gt; \n  arrange(desc(eigen)) |&gt; \n  select(family,eigen)\n\n         family  eigen\n1        MEDICI 1.0000\n2       STROZZI 0.8273\n3       RIDOLFI 0.7937\n4    TORNABUONI 0.7572\n5      GUADAGNI 0.6719\n6      BISCHERI 0.6572\n7       PERUZZI 0.6408\n8    CASTELLANI 0.6020\n9       ALBIZZI 0.5669\n10    BARBADORI 0.4920\n11     SALVIATI 0.3391\n12   ACCIAIUOLI 0.3071\n13 LAMBERTESCHI 0.2063\n14       GINORI 0.1741\n15        PAZZI 0.1041\n16        PUCCI 0.0000\n\n\nMedici is again the most central family using this metric. Note that this procedure estimates a value of zero for Pucci, the isolate, instead of a missing value.",
    "crumbs": [
      "Analysis",
      "<span class='chapter-number'>5</span>¬† <span class='chapter-title'>Centrality and Centralization</span>"
    ]
  },
  {
    "objectID": "centrality.html#the-benefits-of-centrality",
    "href": "centrality.html#the-benefits-of-centrality",
    "title": "5¬† Centrality and Centralization",
    "section": "5.3 The Benefits of Centrality",
    "text": "5.3 The Benefits of Centrality\nHow might centrality in the marriage ties network benefit these Florentine families? To address this question, let‚Äôs attach the political and economic vertex attributes to our centrality dataset. Then we can correlate the two sets of scores. Before running the correlation, I have to remove the column for the names of the families because it is not numeric. I also remove the closeness variable, which returns no correlation results due to the missing score for the isolate, Pucci. (This is okay because the eigenvector score provides a similar estimate.)\n\ncent$seats &lt;- V(ifm)$seats\ncent$wealth &lt;- V(ifm)$wealth\ncent |&gt; \n  select(-family, -close) |&gt; \n  cor(method = c(\"pearson\"))\n\n           degree   between     eigen     seats    wealth\ndegree  1.0000000 0.8333763 0.9404711 0.5480948 0.5589956\nbetween 0.8333763 1.0000000 0.6737085 0.4313423 0.3511716\neigen   0.9404711 0.6737085 1.0000000 0.5366747 0.5365981\nseats   0.5480948 0.4313423 0.5366747 1.0000000 0.4216972\nwealth  0.5589956 0.3511716 0.5365981 0.4216972 1.0000000\n\n\nCorrelation coefficients range from -1 to 1, with positive values indicating a positive relationship, the opposite for negative values, and zeros reflecting null relationships. The diagonal values are all ones because they reflect the perfect correspondence between a single variable and itself. The first thing to note is that all of our centrality scores are strongly and positively related to one another, with all values above 0.6. This implies that the number of connections (degree), the closeness (eigenvector), and the brokerage (betweenness) aspects of centrality are highly related.\nLooking at the bottom two rows, we can see that the measures of political power (seats) and economic power (wealth) are also strongly and positively associated with the centrality scores, with all correlation coefficients above 0.35. More detailed analysis would be needed to make causal claims about these relationships, but the results are certainly suggestive that marriage network centrality and political/economic power go hand in hand.",
    "crumbs": [
      "Analysis",
      "<span class='chapter-number'>5</span>¬† <span class='chapter-title'>Centrality and Centralization</span>"
    ]
  },
  {
    "objectID": "centrality.html#centralization",
    "href": "centrality.html#centralization",
    "title": "5¬† Centrality and Centralization",
    "section": "5.4 Centralization",
    "text": "5.4 Centralization\nWhile centrality is a node-level feature, centralization is a graph-level feature. Centralization refers to the extent that a graph is dominated by a single focal actor, providing a sense of how hierarchically organized the network is. It is measured by the sum of the differences between the most central actor‚Äôs centrality score and the centrality scores of all other actors, divided by the maximum possible difference. Values range from 0 (even centrality scores among actors) to 1 (highly unequal centrality scores). Because the metric is based on centrality scores, one can estimate separate centralization values for degree, closeness, betweenness, eigenvector, or any other form of centrality.\nLet‚Äôs examine eigenvector centralization for the Florentine marriage network.\n\ncentr_eigen(ifm, directed = F)$centralization\n\n[1] 0.5614437\n\n\nIs this a high, low, or moderate level of centralization? Let‚Äôs compare this network to a series of simulated networks. Below we create two unique types of networks: ring and star.\n\nring &lt;- make_ring(16, directed = F, mutual = F, circular = T)\nstar &lt;- make_star(16)\n\nggraph(ring, layout = \"fr\") +\n  geom_edge_link(color = \"grey\", alpha = 0.7) +\n  geom_node_point(color = \"green\", size = 4) +\n  theme_void()\n\n\n\n\n\n\n\nggraph(star, layout = \"fr\") +\n  geom_edge_link(color = \"grey\", alpha = 0.7) +\n  geom_node_point(color = \"green\", size = 4) +\n  theme_void()\n\n\n\n\n\n\n\nround(centr_eigen(ring, directed = F)$centralization, 3)\n\n[1] 0\n\nround(centr_eigen(star, directed = F)$centralization, 3)\n\n[1] 0.795\n\n\nThese simulated networks represent centralization extremes. Every node in the ring network has the exact same eigenvector centrality score, which results in a centralization score of zero. By contrast, the edges in star network is focused on a single focal actor, with no ties among the other actors, which results in a very high centralization score. In fact, this is the highest score possible for a connected network of the same size (N = 16) as the Florentine marriage network. The centralization score for the Florentine network falls within these extremes, but is closer to the higher end of the values.",
    "crumbs": [
      "Analysis",
      "<span class='chapter-number'>5</span>¬† <span class='chapter-title'>Centrality and Centralization</span>"
    ]
  },
  {
    "objectID": "centrality.html#preferential-attachment",
    "href": "centrality.html#preferential-attachment",
    "title": "5¬† Centrality and Centralization",
    "section": "5.5 Preferential Attachment",
    "text": "5.5 Preferential Attachment\nIt is not surprising that the Florentine network leans toward the higher end of the centralization spectrum. Human networks are frequently marked by higher levels of centralization than random networks. Researchers have linked this pattern to a general tendency toward connecting with people who are popular.\nThis tendency is referred to as preferential attachment. Instead of thinking about a social network as an already existing set of people in a bounded unit (like students assigned to a class), the preferential attachment model theorizes networks as scale-free in that they involve a constant influx of new people into the network. These new people make choices about whom they want to form ties with. And those choices are influenced by popularity.\nConsider the Florentine network. Let‚Äôs say you are the head of one of the families and you want to form a marriage bond. If you could choose between Medici and Pucci, who would you choose? Forming a tie with Medici (the most central and popular family) is a far better choice if you want to enhance your status, wealth, and power in the city.\nWe can simulate a series of preferential attachment networks to see how the centralization of the network changes as the size of the network grows. Here we create 5 networks in which we vary the size from 15 nodes to 300 nodes. We set the tendency to connect to high degree alters (power) to .5, which is the midpoint between no preferential attachment (0) to maximum preferential attachment (1). Then we can visualize the largest of these networks.\n\npa15 &lt;- sample_pa(15, power = .5, directed = F)\npa50 &lt;- sample_pa(50, power = .5, directed = F)\npa100 &lt;- sample_pa(100, power = .5, directed = F)\npa200 &lt;- sample_pa(200, power = .5, directed = F)\npa300 &lt;- sample_pa(300, power = .5, directed = F)\n\nV(pa300)$deg &lt;- degree(pa300)\nV(pa300)$deg_cat &lt;- ifelse(V(pa300)$deg &gt; 5, 2, 1)\n\nggraph(pa300, layout = \"fr\") +\n  geom_edge_link(color = \"darkgrey\") +  \n  geom_node_point(aes(color = deg_cat, size = deg), show.legend = F) +    \n  theme_void()   \n\n\n\n\n\n\n\n\nThe graph sizes the nodes by degree and highlights the high degree nodes (degree &gt; 5). The visualization reveals numerous hubs that are popular targets for connection. What we end up with is a hierarchically structured network focused on these central nodes.\nWhat does this mean for centralization? Let‚Äôs observe the changes in the centralization scores as the size of the network increases. The code below calculates eigenvector centralization scores and plots them.\n\ncent15 &lt;- centr_eigen(pa15, directed = F)$centralization\ncent50 &lt;- centr_eigen(pa50, directed = F)$centralization\ncent100 &lt;- centr_eigen(pa100, directed = F)$centralization\ncent200 &lt;- centr_eigen(pa200, directed = F)$centralization\ncent300 &lt;- centr_eigen(pa300, directed = F)$centralization\n\npa_n &lt;- c(15, 50, 100, 200, 300)\npa_cent &lt;- c(cent15, cent50, cent100, cent200, cent300)\nplot(pa_n, pa_cent)\n\n\n\n\n\n\n\n\nThe graph reveals an exponential increase in graph centralization as more and more actors enter the network, quickly becoming maximally centralized. Now imagine networks based on social media connections and it is easy to see how content on those platforms can become dominated by a small number of highly central superstar connectors!\nCentrality and centralization are crucial aspects of social networks, whether historical family relations or modern social media relations. Centrality helps us to understand who the most prominent and powerful actors are in the network and to explain how those individuals shape the flow and distribution of valuable resources in those contexts. The different centrality measures allow us to assess distinct mechanisms by which central actors affect the network. Centralization captures the extent of hierarchy in networks, telling us how dominant central actors are within and across different social contexts.",
    "crumbs": [
      "Analysis",
      "<span class='chapter-number'>5</span>¬† <span class='chapter-title'>Centrality and Centralization</span>"
    ]
  },
  {
    "objectID": "centrality.html#references",
    "href": "centrality.html#references",
    "title": "5¬† Centrality and Centralization",
    "section": "5.6 References",
    "text": "5.6 References\nMore reading on the Florentine families data‚Ä¶\n\nKent D. 1978. The rise of the Medici: Faction in Florence, 1426-1434. Oxford: Oxford University Press.\nBreiger R. and Pattison P. 1986. Cumulated social roles: The duality of persons and their algebras. Social Networks, 8, 215-256.\nPadgett, John F., and Christopher K. Ansell. 1993. ‚ÄúRobust Action and the Rise of the Medici, 1400-1434.‚Äù American Journal of Sociology 98(6):1259‚Äì1319.\n\nMore reading on centrality and centralization\n\nBarab√°si, Albert-L√°szl√≥, and R√©ka Albert. 1999. ‚ÄúEmergence of Scaling in Random Networks.‚Äù Science 286(5439):509‚Äì12.\nBurt, Ronald S. 1992. Structural Holes: The Social Structure of Competition. Cambridge, MA: Harvard University Press.\nBonacich, Phillip. 2007. ‚ÄúSome Unique Properties of Eigenvector Centrality.‚Äù Social Networks 29(4):555‚Äì64.\nBorgatti, Stephen P., and Martin G. Everett. 2006. ‚ÄúA Graph-Theoretic Perspective on Centrality.‚Äù Social Networks 28(4):466‚Äì84.\nEverett, M. G., and S. P. Borgatti. 1999. ‚ÄúThe Centrality of Groups and Classes.‚Äù The Journal of Mathematical Sociology 23(3):181‚Äì201.",
    "crumbs": [
      "Analysis",
      "<span class='chapter-number'>5</span>¬† <span class='chapter-title'>Centrality and Centralization</span>"
    ]
  },
  {
    "objectID": "egonet_setup.html",
    "href": "egonet_setup.html",
    "title": "11¬† Ego network data setup",
    "section": "",
    "text": "11.1 Setting up ego network data\nMost of the techniques discussed as part of these tutorial use holistic network analysis. Let‚Äôs initialize the necessary packages.\nlibrary(intronets)\nlibrary(igraph)\nlibrary(ggraph)\nlibrary(tidyverse)\nlibrary(janitor)\nHolistic network data refer to a complete set of relationships that exist as part of a bounded collective unit. By ‚Äúbounded,‚Äù I mean that the boundaries for the group are clear. For example, in a classroom a student either is or is not on the roster. A researcher can identify those boundaries and then survey these students about who they study with. These responses can then be converted to an adjacency matrix of studying relationships between all of these students.\nIn many instances, boundaries are either unclearly defined, inaccessible, or too large to study collectively. Let‚Äôs say we want to know about the relationships among people who are fans of Manga graphic novels.\nFor these reasons, we might decide to collect egocentric network data, whereby we identify a select number of people from a broader social group, then we interview them about their relationships. It is not necessary to survey all such people, just a subset of the bigger group. The responses from each person results in a separate network.\nSo instead of one big network defining all of the relationships within the group (for example)‚Ä¶\nset.seed(9035768)\nr1 &lt;- sample_gnp(40, 1/15)\n\nggraph(r1, layout = \"fr\") +\n  geom_edge_link(color = \"darkgrey\") +  \n  geom_node_point(color = \"red\", size = 4) +  \n  ggtitle(\"Holistic network\") +\n  theme_void()\n‚Ä¶we obtain multiple smaller networks that revolve around the relationships of a single focal person, ego (which is why these data are referred to as ‚Äúegocentric‚Äù).\nn_alters &lt;- 5\nego_id &lt;- 1\nalter_ids &lt;- 2:(n_alters + 1)\n\nedges &lt;- data.frame(from = ego_id, to = alter_ids)\nalter_pairs &lt;- t(combn(alter_ids, 2))\nn_alter_ties &lt;- sample(1:nrow(alter_pairs), 3)\nrandom_alter_edges &lt;- alter_pairs[n_alter_ties, , drop = FALSE]\ncolnames(random_alter_edges) &lt;- c(\"from\", \"to\")\nedges_all &lt;- rbind(edges, random_alter_edges)\n\ng &lt;- graph_from_data_frame(edges_all, directed = FALSE)\nV(g)$label &lt;- c(\"ego\",\"alter1\",\"alter2\",\"alter3\",\"alter4\",\"alter5\")\n\nggraph(g, layout = \"fr\") +\n  geom_edge_link(color = \"gray60\") +\n  geom_node_point(size = 5, aes(color = label == \"ego\")) +\n  geom_node_text(aes(label = label), vjust = -1, size = 4) +\n  scale_color_manual(values = c(\"TRUE\" = \"firebrick\", \"FALSE\" = \"skyblue\"), guide = \"none\") +\n  ggtitle(\"Egocentric network\") +\n  theme_void()\nWe will demonstrate egocentric network analysis using data from the General Social Survey. Let‚Äôs load the data.\nurl &lt;- \"https://raw.githubusercontent.com/stevemcd1/intronets/master/inst/extdata/gss.rda\"\nload(url(url))",
    "crumbs": [
      "Extensions",
      "<span class='chapter-number'>11</span>¬† <span class='chapter-title'>Ego network data setup</span>"
    ]
  },
  {
    "objectID": "egonet_setup.html#general-social-survey-network-data",
    "href": "egonet_setup.html#general-social-survey-network-data",
    "title": "11¬† Ego network data setup",
    "section": "11.2 General Social Survey network data",
    "text": "11.2 General Social Survey network data\nThe GSS is a national probability sample of adults in the United States that has been conducted annually or biannually every year since the 1970s. It is an extraordinarily valuable source of information about the attitudes and behaviors of the US population.\nWe will work with the 2004 dataset because that year included a detailed module of questions asking people to identify the people with whom they discuss important matters, which I will refer to as ‚Äúconfidants.‚Äù The responses to this initial question are available in the NUMGIVEN variable.\n\ngss |&gt; \n  tabyl(NUMGIVEN)\n\n NUMGIVEN   n    percent\n        0 397 0.27062031\n        1 281 0.19154738\n        2 263 0.17927744\n        3 232 0.15814588\n        4 128 0.08725290\n        5  96 0.06543967\n        6  70 0.04771643\n\n\nThe number of confidants is capped at six ‚Äì respondents could not provide more than that. There is also a surprising number of people who said that they do not confide in anyone (almost 400!) or only confide in a single person (281).\nMuch has been written in the research literature about what this might mean, either in terms of how are friendships are changing over time or whether these estimates are methodological artifacts. If you are interested in this debate, check out some of the sources at the end of this tutorial. Otherwise, we are going to sidestep these debates and instead proceed with analysis of ego networks with two or more confidants.\n\ngss2 &lt;- gss |&gt; \n  filter(NUMGIVEN &gt;= 2) |&gt; \n  filter(GSSID != \"NA\") |&gt; \n  rename(ego_id = GSSID)",
    "crumbs": [
      "Extensions",
      "<span class='chapter-number'>11</span>¬† <span class='chapter-title'>Ego network data setup</span>"
    ]
  },
  {
    "objectID": "egonet_setup.html#constructing-the-files",
    "href": "egonet_setup.html#constructing-the-files",
    "title": "11¬† Ego network data setup",
    "section": "11.3 Constructing the files",
    "text": "11.3 Constructing the files\n\n11.3.1 Ego attributes\nThree sets of files are essential for conducting egocentric network analysis. First, we need to gather information about all of the egos ‚Äì those individuals who were surveyed about their confidants. We therefore subset the gss2 file to include the first eight columns of data, which can then be viewed with the glimpse command.\n\n# save ego attribute data\nego &lt;- gss2[,1:8] \nglimpse(ego)\n\nRows: 288\nColumns: 8\n$ ego_id   &lt;dbl&gt; 3, 5, 10, 12, 16, 30, 35, 36, 46, 54, 57, 59, 61, 62, 63, 65,‚Ä¶\n$ AGE      &lt;dbl&gt; 52, 34, 26, 58, 48, 73, 47, 58, 55, 49, 47, 55, 49, 40, 40, 5‚Ä¶\n$ EDUC     &lt;dbl&gt; 14, 17, 14, 12, 11, 16, 17, 16, 16, 12, 16, 16, 16, 16, 20, 2‚Ä¶\n$ SEX      &lt;dbl&gt; 1, 2, 1, 2, 1, 1, 2, 2, 1, 1, 1, 2, 1, 1, 2, 1, 2, 2, 2, 2, 2‚Ä¶\n$ RACE     &lt;dbl&gt; 2, 3, 2, 2, 2, 1, 1, 1, 3, 1, 1, 1, 1, 1, 3, 3, 1, 1, 2, 2, 2‚Ä¶\n$ PARTYID  &lt;dbl&gt; 0, 2, 1, 1, 6, 5, 1, 0, 1, 5, 0, 2, 6, 5, 0, 5, 7, 5, 0, 0, 1‚Ä¶\n$ RELIG    &lt;dbl&gt; 1, 2, 1, 4, 1, 3, 99, 3, 5, 2, 4, 4, 1, 2, 8, 7, 3, 1, 2, 1, ‚Ä¶\n$ NUMGIVEN &lt;dbl&gt; 4, 4, 6, 2, 2, 3, 3, 6, 3, 2, 3, 4, 2, 2, 3, 2, 2, 4, 2, 3, 2‚Ä¶\n\n\nFor each ego, the data contain a numerical identifier and seven attribute questions. We won‚Äôt use all of these variables, but they are available for you to examine if you like.\n\n\n11.3.2 Alter attributes\nEgo was asked to provide information about each of their confidants, which we refer to as alters. So our next step is to construct an alter attribute file. We need the first column of data which includes the ego id, the eight column which is the NUMGIVEN variable, and then a long list of attributes for each alter.\n\n# save alter attribute data\nalter &lt;- gss2[,c(1,8,25:114)]\nglimpse(alter)\n\nRows: 288\nColumns: 92\n$ ego_id   &lt;dbl&gt; 3, 5, 10, 12, 16, 30, 35, 36, 46, 54, 57, 59, 61, 62, 63, 65,‚Ä¶\n$ NUMGIVEN &lt;dbl&gt; 4, 4, 6, 2, 2, 3, 3, 6, 3, 2, 3, 4, 2, 2, 3, 2, 2, 4, 2, 3, 2‚Ä¶\n$ SEX1     &lt;dbl&gt; 2, 2, 2, 2, 1, 1, 1, 2, 1, 1, 1, 1, 2, 1, 1, 1, 1, 2, 1, 2, 2‚Ä¶\n$ SEX2     &lt;dbl&gt; 2, 1, 2, 2, 2, 1, 2, 2, 2, 2, 1, 2, 1, 1, 2, 1, 2, 1, 2, 2, 2‚Ä¶\n$ SEX3     &lt;dbl&gt; 1, 2, 1, 0, 0, 1, 2, 2, 1, 0, 2, 1, 0, 0, 1, 0, 0, 2, 0, 1, 0‚Ä¶\n$ SEX4     &lt;dbl&gt; 1, 2, 2, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0‚Ä¶\n$ SEX5     &lt;dbl&gt; 0, 0, 2, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0‚Ä¶\n$ RACE1    &lt;dbl&gt; 2, 3, 4, 2, 2, 4, 4, 4, 1, 3, 4, 4, 4, 4, 4, 5, 4, 4, 2, 4, 2‚Ä¶\n$ RACE2    &lt;dbl&gt; 2, 3, 2, 4, 2, 4, 4, 4, 1, 3, 1, 4, 4, 4, 4, 5, 4, 4, 2, 3, 2‚Ä¶\n$ RACE3    &lt;dbl&gt; 2, 3, 2, 0, 0, 4, 4, 4, 1, 0, 1, 4, 0, 0, 4, 0, 0, 4, 0, 2, 0‚Ä¶\n$ RACE4    &lt;dbl&gt; 2, 3, 3, 0, 0, 0, 0, 4, 0, 0, 0, 4, 0, 0, 0, 0, 0, 4, 0, 0, 0‚Ä¶\n$ RACE5    &lt;dbl&gt; 0, 0, 3, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0‚Ä¶\n$ SPOUSE1  &lt;dbl&gt; 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 1, 1, 2, 1, 2, 1, 2, 2, 2, 2‚Ä¶\n$ SPOUSE2  &lt;dbl&gt; 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2‚Ä¶\n$ SPOUSE3  &lt;dbl&gt; 2, 2, 2, 0, 0, 2, 2, 2, 2, 0, 2, 2, 0, 0, 2, 0, 0, 2, 0, 2, 0‚Ä¶\n$ SPOUSE4  &lt;dbl&gt; 2, 2, 2, 0, 0, 0, 0, 2, 0, 0, 0, 2, 0, 0, 0, 0, 0, 2, 0, 0, 0‚Ä¶\n$ SPOUSE5  &lt;dbl&gt; 0, 0, 2, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0‚Ä¶\n$ PARENT1  &lt;dbl&gt; 2, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 2‚Ä¶\n$ PARENT2  &lt;dbl&gt; 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1‚Ä¶\n$ PARENT3  &lt;dbl&gt; 2, 2, 2, 0, 0, 2, 2, 2, 2, 0, 2, 2, 0, 0, 2, 0, 0, 2, 0, 2, 0‚Ä¶\n$ PARENT4  &lt;dbl&gt; 2, 2, 2, 0, 0, 0, 0, 2, 0, 0, 0, 2, 0, 0, 0, 0, 0, 2, 0, 0, 0‚Ä¶\n$ PARENT5  &lt;dbl&gt; 0, 0, 2, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0‚Ä¶\n$ SIBLING1 &lt;dbl&gt; 2, 2, 2, 2, 2, 1, 2, 2, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2‚Ä¶\n$ SIBLING2 &lt;dbl&gt; 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2‚Ä¶\n$ SIBLING3 &lt;dbl&gt; 2, 2, 2, 0, 0, 2, 2, 2, 2, 0, 2, 1, 0, 0, 2, 0, 0, 2, 0, 2, 0‚Ä¶\n$ SIBLING4 &lt;dbl&gt; 1, 2, 2, 0, 0, 0, 0, 2, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0‚Ä¶\n$ SIBLING5 &lt;dbl&gt; 0, 0, 2, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0‚Ä¶\n$ CHILD1   &lt;dbl&gt; 2, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2‚Ä¶\n$ CHILD2   &lt;dbl&gt; 2, 2, 2, 2, 2, 2, 2, 2, 1, 2, 2, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2‚Ä¶\n$ CHILD3   &lt;dbl&gt; 2, 2, 2, 0, 0, 2, 2, 2, 2, 0, 2, 2, 0, 0, 2, 0, 0, 2, 0, 2, 0‚Ä¶\n$ CHILD4   &lt;dbl&gt; 2, 2, 2, 0, 0, 0, 0, 2, 0, 0, 0, 2, 0, 0, 0, 0, 0, 2, 0, 0, 0‚Ä¶\n$ CHILD5   &lt;dbl&gt; 0, 0, 2, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0‚Ä¶\n$ OTHFAM1  &lt;dbl&gt; 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2‚Ä¶\n$ OTHFAM2  &lt;dbl&gt; 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 1, 1, 2, 1, 2, 1, 2, 2, 2‚Ä¶\n$ OTHFAM3  &lt;dbl&gt; 2, 2, 2, 0, 0, 2, 2, 2, 2, 0, 2, 2, 0, 0, 1, 0, 0, 2, 0, 2, 0‚Ä¶\n$ OTHFAM4  &lt;dbl&gt; 2, 1, 2, 0, 0, 0, 0, 2, 0, 0, 0, 2, 0, 0, 0, 0, 0, 2, 0, 0, 0‚Ä¶\n$ OTHFAM5  &lt;dbl&gt; 0, 0, 2, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0‚Ä¶\n$ COWORK1  &lt;dbl&gt; 2, 2, 1, 1, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 2, 2, 1, 2‚Ä¶\n$ COWORK2  &lt;dbl&gt; 2, 1, 2, 1, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2‚Ä¶\n$ COWORK3  &lt;dbl&gt; 2, 1, 1, 0, 0, 2, 2, 2, 2, 0, 1, 2, 0, 0, 2, 0, 0, 2, 0, 2, 0‚Ä¶\n$ COWORK4  &lt;dbl&gt; 2, 1, 1, 0, 0, 0, 0, 2, 0, 0, 0, 2, 0, 0, 0, 0, 0, 2, 0, 0, 0‚Ä¶\n$ COWORK5  &lt;dbl&gt; 0, 0, 1, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0‚Ä¶\n$ MEMGRP1  &lt;dbl&gt; 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2‚Ä¶\n$ MEMGRP2  &lt;dbl&gt; 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 2‚Ä¶\n$ MEMGRP3  &lt;dbl&gt; 2, 2, 2, 0, 0, 2, 2, 2, 2, 0, 2, 2, 0, 0, 2, 0, 0, 1, 0, 2, 0‚Ä¶\n$ MEMGRP4  &lt;dbl&gt; 2, 2, 2, 0, 0, 0, 0, 2, 0, 0, 0, 2, 0, 0, 0, 0, 0, 2, 0, 0, 0‚Ä¶\n$ MEMGRP5  &lt;dbl&gt; 0, 0, 2, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0‚Ä¶\n$ NEIGHBR1 &lt;dbl&gt; 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2‚Ä¶\n$ NEIGHBR2 &lt;dbl&gt; 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 2‚Ä¶\n$ NEIGHBR3 &lt;dbl&gt; 2, 2, 2, 0, 0, 2, 2, 2, 2, 0, 2, 2, 0, 0, 2, 0, 0, 2, 0, 2, 0‚Ä¶\n$ NEIGHBR4 &lt;dbl&gt; 2, 2, 2, 0, 0, 0, 0, 2, 0, 0, 0, 2, 0, 0, 0, 0, 0, 2, 0, 0, 0‚Ä¶\n$ NEIGHBR5 &lt;dbl&gt; 0, 0, 2, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0‚Ä¶\n$ FRIEND1  &lt;dbl&gt; 1, 2, 2, 2, 2, 2, 2, 2, 1, 2, 1, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1‚Ä¶\n$ FRIEND2  &lt;dbl&gt; 1, 1, 1, 2, 2, 1, 2, 1, 1, 2, 1, 2, 2, 2, 2, 2, 1, 2, 2, 1, 2‚Ä¶\n$ FRIEND3  &lt;dbl&gt; 1, 1, 2, 0, 0, 1, 2, 1, 1, 0, 1, 2, 0, 0, 2, 0, 0, 2, 0, 1, 0‚Ä¶\n$ FRIEND4  &lt;dbl&gt; 2, 2, 2, 0, 0, 0, 0, 1, 0, 0, 0, 2, 0, 0, 0, 0, 0, 2, 0, 0, 0‚Ä¶\n$ FRIEND5  &lt;dbl&gt; 0, 0, 2, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0‚Ä¶\n$ ADVISOR1 &lt;dbl&gt; 2, 2, 2, 2, 1, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2‚Ä¶\n$ ADVISOR2 &lt;dbl&gt; 2, 2, 2, 2, 1, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2‚Ä¶\n$ ADVISOR3 &lt;dbl&gt; 2, 2, 2, 0, 0, 2, 2, 2, 1, 0, 2, 2, 0, 0, 2, 0, 0, 2, 0, 2, 0‚Ä¶\n$ ADVISOR4 &lt;dbl&gt; 2, 2, 2, 0, 0, 0, 0, 2, 0, 0, 0, 2, 0, 0, 0, 0, 0, 2, 0, 0, 0‚Ä¶\n$ ADVISOR5 &lt;dbl&gt; 0, 0, 2, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0‚Ä¶\n$ OTHER1   &lt;dbl&gt; 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 2‚Ä¶\n$ OTHER2   &lt;dbl&gt; 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 2, 2‚Ä¶\n$ OTHER3   &lt;dbl&gt; 2, 2, 2, 0, 0, 2, 1, 2, 2, 0, 2, 2, 0, 0, 2, 0, 0, 2, 0, 2, 0‚Ä¶\n$ OTHER4   &lt;dbl&gt; 2, 2, 2, 0, 0, 0, 0, 2, 0, 0, 0, 2, 0, 0, 0, 0, 0, 2, 0, 0, 0‚Ä¶\n$ OTHER5   &lt;dbl&gt; 0, 0, 2, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0‚Ä¶\n$ TALKTO1  &lt;dbl&gt; 4, 1, 1, 2, 2, 4, 1, 1, 2, 1, 1, 1, 1, 2, 1, 1, 1, 3, 3, 1, 1‚Ä¶\n$ TALKTO2  &lt;dbl&gt; 1, 1, 1, 2, 2, 3, 1, 2, 1, 1, 1, 2, 4, 2, 1, 2, 1, 2, 3, 1, 1‚Ä¶\n$ TALKTO3  &lt;dbl&gt; 2, 1, 1, 0, 0, 1, 2, 3, 2, 0, 1, 4, 0, 0, 3, 0, 0, 1, 0, 1, 0‚Ä¶\n$ TALKTO4  &lt;dbl&gt; 2, 1, 3, 0, 0, 0, 0, 3, 0, 0, 0, 3, 0, 0, 0, 0, 0, 3, 0, 0, 0‚Ä¶\n$ TALKTO5  &lt;dbl&gt; 0, 0, 1, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0‚Ä¶\n$ KNOWN1   &lt;dbl&gt; 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0‚Ä¶\n$ KNOWN2   &lt;dbl&gt; 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0‚Ä¶\n$ KNOWN3   &lt;dbl&gt; 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0‚Ä¶\n$ KNOWN4   &lt;dbl&gt; 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0‚Ä¶\n$ KNOWN5   &lt;dbl&gt; 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0‚Ä¶\n$ EDUC1    &lt;dbl&gt; 6, 7, 3, 3, 8, 7, 7, 6, 3, 3, 7, 7, 6, 0, 7, 7, 7, 3, 6, 5, 4‚Ä¶\n$ EDUC2    &lt;dbl&gt; 3, 3, 3, 6, 8, 6, 6, 6, 7, 3, 7, 6, 7, 6, 7, 7, 7, 7, 7, 6, 6‚Ä¶\n$ EDUC3    &lt;dbl&gt; 7, 7, 3, -1, -1, 6, 7, 7, 6, -1, 7, 6, -1, -1, 7, -1, -1, 4, ‚Ä¶\n$ EDUC4    &lt;dbl&gt; 6, 7, 4, -1, -1, -1, -1, 7, -1, -1, -1, 6, -1, -1, -1, -1, -1‚Ä¶\n$ EDUC5    &lt;dbl&gt; -1, -1, 4, -1, -1, -1, -1, 7, -1, -1, -1, -1, -1, -1, -1, -1,‚Ä¶\n$ AGE1     &lt;dbl&gt; 56, 63, 25, 57, 50, 69, 47, 25, 50, 47, 55, 54, 48, 77, 43, 9‚Ä¶\n$ AGE2     &lt;dbl&gt; 40, 36, 25, 52, 98, 62, 79, 57, 24, 34, 50, 27, 72, 64, 40, 4‚Ä¶\n$ AGE3     &lt;dbl&gt; 58, 34, 39, -1, -1, 60, 55, 57, 52, -1, 35, 59, -1, -1, 41, -‚Ä¶\n$ AGE4     &lt;dbl&gt; 59, 36, 33, -1, -1, -1, -1, 59, -1, -1, -1, 58, -1, -1, -1, -‚Ä¶\n$ AGE5     &lt;dbl&gt; -1, -1, 30, -1, -1, -1, -1, 57, -1, -1, -1, -1, -1, -1, -1, -‚Ä¶\n$ RELIG1   &lt;dbl&gt; 1, 2, 5, 2, 8, 3, 9, 3, 4, 2, 1, 4, 1, 2, 5, 8, 3, 2, 4, 1, 1‚Ä¶\n$ RELIG2   &lt;dbl&gt; 1, 2, 5, 3, 8, 3, 9, 3, 4, 2, 5, 2, 1, 2, 5, 5, 3, 1, 2, 1, 1‚Ä¶\n$ RELIG3   &lt;dbl&gt; 1, 2, 2, 0, 0, 3, 9, 3, 5, 0, 8, 2, 0, 0, 4, 0, 0, 1, 0, 1, 0‚Ä¶\n$ RELIG4   &lt;dbl&gt; 1, 2, 2, 0, 0, 0, 0, 3, 0, 0, 0, 2, 0, 0, 0, 0, 0, 1, 0, 0, 0‚Ä¶\n$ RELIG5   &lt;dbl&gt; 0, 0, 2, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0‚Ä¶\n\n\nThe alter attributes include a number at the end of the variable name to indicate which which alter is being referenced. Note that these numbers range from 1 to 5. So if an ego said that they confide in 6 or more alters, the GSS collected information on only the first five alters. Consequently, the maximum number of ego network alters in our analysis will be five.\nAt present, the data are organized by unique egos. But what we really want is for each line to represent a unique alter. In data management speak, the current file is in ‚Äúwide‚Äù format (with the data extending out to the right as variables for separate alters) and needs to be transformed to ‚Äúlong‚Äù format (with the data for each alter extending down for each alter). If an ego has three alters, then there should be three rows in the data, one for each alter.\nTo accomplish this, use the pivot_longer command. The code below reshapes the existing data from wide to long format, extending down information for each alter (so all columns except for ego_id and NUMGIVEN, which we want to repeat for each ego). The names_ functions tell R how to rename the variables (SPOUSE1 should become SPOUSE) and create an alter id variable (and formatting that variable is numeric).\n\n# reshape alter attributes\nalterlong &lt;- alter |&gt; \n  pivot_longer(\n    cols = -c(ego_id,NUMGIVEN), \n    names_to = c(\".value\", \"alter_id\"),  # Split names into \"base\" and \"set\" parts\n    names_pattern = \"(\\\\D+)(\\\\d+)\"  # Separate variable base and set number\n  )\n\n# change alter_id to numeric variable\nalterlong$alter_id &lt;- as.numeric(alterlong$alter_id)\n\nLet‚Äôs inspect this file before making further adjustments.\n\nglimpse(alterlong)\n\nRows: 1,440\nColumns: 21\n$ ego_id   &lt;dbl&gt; 3, 3, 3, 3, 3, 5, 5, 5, 5, 5, 10, 10, 10, 10, 10, 12, 12, 12,‚Ä¶\n$ NUMGIVEN &lt;dbl&gt; 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 6, 6, 6, 6, 6, 2, 2, 2, 2, 2, 2‚Ä¶\n$ alter_id &lt;dbl&gt; 1, 2, 3, 4, 5, 1, 2, 3, 4, 5, 1, 2, 3, 4, 5, 1, 2, 3, 4, 5, 1‚Ä¶\n$ SEX      &lt;dbl&gt; 2, 2, 1, 1, 0, 2, 1, 2, 2, 0, 2, 2, 1, 2, 2, 2, 2, 0, 0, 0, 1‚Ä¶\n$ RACE     &lt;dbl&gt; 2, 2, 2, 2, 0, 3, 3, 3, 3, 0, 4, 2, 2, 3, 3, 2, 4, 0, 0, 0, 2‚Ä¶\n$ SPOUSE   &lt;dbl&gt; 2, 2, 2, 2, 0, 2, 2, 2, 2, 0, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 2‚Ä¶\n$ PARENT   &lt;dbl&gt; 2, 2, 2, 2, 0, 1, 2, 2, 2, 0, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 2‚Ä¶\n$ SIBLING  &lt;dbl&gt; 2, 2, 2, 1, 0, 2, 2, 2, 2, 0, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 2‚Ä¶\n$ CHILD    &lt;dbl&gt; 2, 2, 2, 2, 0, 2, 2, 2, 2, 0, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 2‚Ä¶\n$ OTHFAM   &lt;dbl&gt; 2, 2, 2, 2, 0, 2, 2, 2, 1, 0, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 2‚Ä¶\n$ COWORK   &lt;dbl&gt; 2, 2, 2, 2, 0, 2, 1, 1, 1, 0, 1, 2, 1, 1, 1, 1, 1, 0, 0, 0, 2‚Ä¶\n$ MEMGRP   &lt;dbl&gt; 2, 2, 2, 2, 0, 2, 2, 2, 2, 0, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 2‚Ä¶\n$ NEIGHBR  &lt;dbl&gt; 2, 2, 2, 2, 0, 2, 2, 2, 2, 0, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 2‚Ä¶\n$ FRIEND   &lt;dbl&gt; 1, 1, 1, 2, 0, 2, 1, 1, 2, 0, 2, 1, 2, 2, 2, 2, 2, 0, 0, 0, 2‚Ä¶\n$ ADVISOR  &lt;dbl&gt; 2, 2, 2, 2, 0, 2, 2, 2, 2, 0, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 1‚Ä¶\n$ OTHER    &lt;dbl&gt; 2, 2, 2, 2, 0, 2, 2, 2, 2, 0, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 2‚Ä¶\n$ TALKTO   &lt;dbl&gt; 4, 1, 2, 2, 0, 1, 1, 1, 1, 0, 1, 1, 1, 3, 1, 2, 2, 0, 0, 0, 2‚Ä¶\n$ KNOWN    &lt;dbl&gt; 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0‚Ä¶\n$ EDUC     &lt;dbl&gt; 6, 3, 7, 6, -1, 7, 3, 7, 7, -1, 3, 3, 3, 4, 4, 3, 6, -1, -1, ‚Ä¶\n$ AGE      &lt;dbl&gt; 56, 40, 58, 59, -1, 63, 36, 34, 36, -1, 25, 25, 39, 33, 30, 5‚Ä¶\n$ RELIG    &lt;dbl&gt; 1, 1, 1, 1, 0, 2, 2, 2, 2, 0, 5, 5, 2, 2, 2, 2, 3, 0, 0, 0, 8‚Ä¶\n\n\nThis new alterlong file has exactly five times the number of observations as the original alter file (288*5 = 1440). That‚Äôs because each ego now has five lines, given the potential for having up to five different alters. Alterlong also has much fewer variables, because each of the attributes that used to have five different variables (PARENT1-5) now has only a single variable (PARENT).\nThis dataset contains multiple rows with missing information. For example, the first five entries are for ego_id = 3. The NUMGIVEN value of 4 indicates that this person reported 4 alters. The first 4 entries contain valid alter information, but the 5th entry contains 0s or -1s, which are invalid. Therefore, we need to delete all of the rows for alters that do not exist. Then we can remove the NUMGIVEN variable because it is no longer needed.\n\n# keep only rows where ALTERID &lt;= NUMGIVEN\n# these rows refer to alters that do not exist in the data\n# then remove NUMGIVEN\nalterlong &lt;- alterlong |&gt; \n  filter(alter_id &lt;= NUMGIVEN) |&gt; \n  select(-NUMGIVEN)\n\nThe next step is to adjust the alter_id variables. At present, those ids (1-5) repeat across the dataset, so they are not unique. A better approach is to create unique identifiers that provide information not only about the number designation for the alter, but also the number of the ego to whom they are attached. The code below does this by multiplying the ego_id by 10 and then adding the alter_id.\n\n# distinct ID values\nalterlong$alter_id &lt;- alterlong$ego_id*10 + alterlong$alter_id\nglimpse(alterlong[,1:2])\n\nRows: 955\nColumns: 2\n$ ego_id   &lt;dbl&gt; 3, 3, 3, 3, 5, 5, 5, 5, 10, 10, 10, 10, 10, 12, 12, 16, 16, 3‚Ä¶\n$ alter_id &lt;dbl&gt; 31, 32, 33, 34, 51, 52, 53, 54, 101, 102, 103, 104, 105, 121,‚Ä¶\n\n\nNow we can see that ego #10‚Äôs 4th alter has an alter_id of 104. This will be very helpful when we visualize these networks later.\n\n\n11.3.3 Alter edgelist\nAn edgelist is also needed. For this file, we‚Äôll save the first column (ego_id) and columns 15-24.\n\n# save edge data\nedges &lt;- gss2[,c(1,15:24)]\nglimpse(edges)\n\nRows: 288\nColumns: 11\n$ ego_id  &lt;dbl&gt; 3, 5, 10, 12, 16, 30, 35, 36, 46, 54, 57, 59, 61, 62, 63, 65, ‚Ä¶\n$ CLOSE12 &lt;dbl&gt; 2, 1, 3, 3, 3, 2, 2, 2, 2, 3, 1, 1, 1, 2, 2, 3, 2, 1, 2, 3, 1,‚Ä¶\n$ CLOSE13 &lt;dbl&gt; 1, 3, 1, 0, 0, 2, 2, 2, 2, 0, 1, 2, 0, 0, 2, 0, 0, 1, 0, 2, 0,‚Ä¶\n$ CLOSE14 &lt;dbl&gt; 3, 1, 2, 0, 0, 0, 0, 2, 0, 0, 0, 2, 0, 0, 0, 0, 0, 1, 0, 0, 0,‚Ä¶\n$ CLOSE15 &lt;dbl&gt; 0, 0, 2, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,‚Ä¶\n$ CLOSE23 &lt;dbl&gt; 1, 1, 2, 0, 0, 2, 3, 2, 2, 0, 2, 2, 0, 0, 1, 0, 0, 1, 0, 2, 0,‚Ä¶\n$ CLOSE24 &lt;dbl&gt; 1, 1, 2, 0, 0, 0, 0, 2, 0, 0, 0, 2, 0, 0, 0, 0, 0, 1, 0, 0, 0,‚Ä¶\n$ CLOSE25 &lt;dbl&gt; 0, 0, 2, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,‚Ä¶\n$ CLOSE34 &lt;dbl&gt; 2, 1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 2, 0, 0, 0, 0, 0, 1, 0, 0, 0,‚Ä¶\n$ CLOSE35 &lt;dbl&gt; 0, 0, 1, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,‚Ä¶\n$ CLOSE45 &lt;dbl&gt; 0, 0, 1, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,‚Ä¶\n\n\nThese variables measure how close ego thinks that the two alters are to one another. We will examine the specific values later. For now, just note that the numbers indicate which alters are being referenced. For example, CLOSE25 refers to the perceive closeness between alter 2 and alter 5.\nTo create the edgelist, we need to pivot_long (like before) so that each line represents a unique relationship between alters.\n\n# reshape edges long\nedgeslong &lt;- edges  |&gt; \n  pivot_longer(\n    cols = -ego_id,                             \n    names_to = \"tie\",     # Name for the column representing each tie variable\n    values_to = \"weight\"  # Name for the tie strength values\n  ) |&gt; \n  mutate(\n    from = as.integer(sub(\"CLOSE(\\\\d)(\\\\d)\", \"\\\\1\", tie)),  # Extract first alter from tie variable\n    to = as.integer(sub(\"CLOSE(\\\\d)(\\\\d)\", \"\\\\2\", tie))   # Extract second alter from tie variable\n  ) |&gt; \n  select(ego_id, from, to, weight) \nglimpse(edgeslong)\n\nRows: 2,880\nColumns: 4\n$ ego_id &lt;dbl&gt; 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 10,‚Ä¶\n$ from   &lt;int&gt; 1, 1, 1, 1, 2, 2, 2, 3, 3, 4, 1, 1, 1, 1, 2, 2, 2, 3, 3, 4, 1, ‚Ä¶\n$ to     &lt;int&gt; 2, 3, 4, 5, 3, 4, 5, 4, 5, 5, 2, 3, 4, 5, 3, 4, 5, 4, 5, 5, 2, ‚Ä¶\n$ weight &lt;dbl&gt; 2, 1, 3, 0, 1, 1, 0, 2, 0, 0, 1, 3, 1, 0, 1, 1, 0, 1, 0, 0, 3, ‚Ä¶\n\n\nIn addition to the ego_id we have ‚Äúfrom‚Äù and ‚Äúto‚Äù variables which contain the numbers of the alters that are connected. The direction of the tie does not matter as these relationships are assumed to be symmetric.\nThe weight variable tells us about the strength of the tie between each alter. Oddly, the GSS coded greater closeness between alters with descending values. It makes more sense to recode closer friends (‚Äúespecially close‚Äù) with higher values, which we do below. Also, ‚Äútotal strangers‚Äù indicates that there is no relationship, so those lines are removed from the dataset.\n\n# 1 ESPECIALLY CLOSE; 2 KNOW EACH OTHER; 3  TOTAL STRANGERS\n# recode 1-&gt;2, 2-&gt;1, 3-&gt;0, then remove zeros\nedgeslong &lt;- edgeslong |&gt; \n  mutate(weight = recode(weight, `1`=2, `2`=1, `3`=0)) |&gt; \n  filter(weight &gt; 0)\n\nNow we need to adjust the id values for the alters so they match with the alter attribute file.\n\n# consistent IDs that will link with the alter attribute files\nedgeslong$from &lt;- edgeslong$ego_id*10 + edgeslong$from\nedgeslong$to &lt;- edgeslong$ego_id*10 + edgeslong$to\nglimpse(edgeslong)\n\nRows: 1,030\nColumns: 4\n$ ego_id &lt;dbl&gt; 3, 3, 3, 3, 3, 5, 5, 5, 5, 5, 10, 10, 10, 10, 10, 10, 10, 10, 1‚Ä¶\n$ from   &lt;dbl&gt; 31, 31, 32, 32, 33, 51, 51, 52, 52, 53, 101, 101, 101, 102, 102‚Ä¶\n$ to     &lt;dbl&gt; 32, 33, 33, 34, 34, 52, 54, 53, 54, 54, 103, 104, 105, 103, 104‚Ä¶\n$ weight &lt;dbl&gt; 1, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 2, 2, 2, 1, 1, ‚Ä¶",
    "crumbs": [
      "Extensions",
      "<span class='chapter-number'>11</span>¬† <span class='chapter-title'>Ego network data setup</span>"
    ]
  },
  {
    "objectID": "egonet_setup.html#egor",
    "href": "egonet_setup.html#egor",
    "title": "11¬† Ego network data setup",
    "section": "11.4 egor",
    "text": "11.4 egor\nNow that the files are prepped, they can be combined into an ‚Äúegor‚Äù object. egor is a package designed for conducting egocentric network analysis. The code below loads the egor package and combines the various files we just created into an egor object.\n\n# Create an egor object\nlibrary(egor)\negor.obj &lt;- egor(egos = ego,\n                 alters = alterlong, \n                 aaties = edgeslong, \n                 ID.vars = list(ego = \"ego_id\",\n                                alter = \"alter_id\", \n                                source = \"from\",\n                                target = \"to\"))\n\nThe next step is to convert the egor object into an igraph object. Then we can examine the object.\n\n# transform into an igraph object\ngr.list &lt;- as_igraph(egor.obj)\nhead(gr.list)\n\n$`3`\nIGRAPH bdea15f UNW- 4 5 -- \n+ attr: .egoID (g/n), name (v/c), SEX (v/n), RACE (v/n), SPOUSE (v/n),\n| PARENT (v/n), SIBLING (v/n), CHILD (v/n), OTHFAM (v/n), COWORK (v/n),\n| MEMGRP (v/n), NEIGHBR (v/n), FRIEND (v/n), ADVISOR (v/n), OTHER\n| (v/n), TALKTO (v/n), KNOWN (v/n), EDUC (v/n), AGE (v/n), RELIG (v/n),\n| weight (e/n)\n+ edges from bdea15f (vertex names):\n[1] 31--32 31--33 32--33 32--34 33--34\n\n$`5`\nIGRAPH bdea91a UNW- 4 5 -- \n+ attr: .egoID (g/n), name (v/c), SEX (v/n), RACE (v/n), SPOUSE (v/n),\n| PARENT (v/n), SIBLING (v/n), CHILD (v/n), OTHFAM (v/n), COWORK (v/n),\n| MEMGRP (v/n), NEIGHBR (v/n), FRIEND (v/n), ADVISOR (v/n), OTHER\n| (v/n), TALKTO (v/n), KNOWN (v/n), EDUC (v/n), AGE (v/n), RELIG (v/n),\n| weight (e/n)\n+ edges from bdea91a (vertex names):\n[1] 51--52 51--54 52--53 52--54 53--54\n\n$`10`\nIGRAPH bdeaf16 UNW- 5 9 -- \n+ attr: .egoID (g/n), name (v/c), SEX (v/n), RACE (v/n), SPOUSE (v/n),\n| PARENT (v/n), SIBLING (v/n), CHILD (v/n), OTHFAM (v/n), COWORK (v/n),\n| MEMGRP (v/n), NEIGHBR (v/n), FRIEND (v/n), ADVISOR (v/n), OTHER\n| (v/n), TALKTO (v/n), KNOWN (v/n), EDUC (v/n), AGE (v/n), RELIG (v/n),\n| weight (e/n)\n+ edges from bdeaf16 (vertex names):\n[1] 101--103 101--104 101--105 102--103 102--104 102--105 103--104 103--105\n[9] 104--105\n\n$`12`\nIGRAPH bdeb4b1 UNW- 2 0 -- \n+ attr: .egoID (g/n), name (v/c), SEX (v/n), RACE (v/n), SPOUSE (v/n),\n| PARENT (v/n), SIBLING (v/n), CHILD (v/n), OTHFAM (v/n), COWORK (v/n),\n| MEMGRP (v/n), NEIGHBR (v/n), FRIEND (v/n), ADVISOR (v/n), OTHER\n| (v/n), TALKTO (v/n), KNOWN (v/n), EDUC (v/n), AGE (v/n), RELIG (v/n),\n| weight (e/n)\n+ edges from bdeb4b1 (vertex names):\n\n$`16`\nIGRAPH bdebb65 UNW- 2 0 -- \n+ attr: .egoID (g/n), name (v/c), SEX (v/n), RACE (v/n), SPOUSE (v/n),\n| PARENT (v/n), SIBLING (v/n), CHILD (v/n), OTHFAM (v/n), COWORK (v/n),\n| MEMGRP (v/n), NEIGHBR (v/n), FRIEND (v/n), ADVISOR (v/n), OTHER\n| (v/n), TALKTO (v/n), KNOWN (v/n), EDUC (v/n), AGE (v/n), RELIG (v/n),\n| weight (e/n)\n+ edges from bdebb65 (vertex names):\n\n$`30`\nIGRAPH bdec17a UNW- 3 3 -- \n+ attr: .egoID (g/n), name (v/c), SEX (v/n), RACE (v/n), SPOUSE (v/n),\n| PARENT (v/n), SIBLING (v/n), CHILD (v/n), OTHFAM (v/n), COWORK (v/n),\n| MEMGRP (v/n), NEIGHBR (v/n), FRIEND (v/n), ADVISOR (v/n), OTHER\n| (v/n), TALKTO (v/n), KNOWN (v/n), EDUC (v/n), AGE (v/n), RELIG (v/n),\n| weight (e/n)\n+ edges from bdec17a (vertex names):\n[1] 301--302 301--303 302--303\n\n\nThis new object looks a bit different from the igraph objects we‚Äôve looked at in the past. Embedded in this object is not one single network, but multiple networks, with each element‚Äôs name corresponding to the ego ID.\n\nnames(gr.list)\n\n  [1] \"3\"   \"5\"   \"10\"  \"12\"  \"16\"  \"30\"  \"35\"  \"36\"  \"46\"  \"54\"  \"57\"  \"59\" \n [13] \"61\"  \"62\"  \"63\"  \"65\"  \"66\"  \"70\"  \"71\"  \"72\"  \"74\"  \"75\"  \"80\"  \"83\" \n [25] \"84\"  \"90\"  \"92\"  \"93\"  \"94\"  \"95\"  \"103\" \"106\" \"112\" \"116\" \"117\" \"125\"\n [37] \"129\" \"131\" \"133\" \"135\" \"136\" \"139\" \"140\" \"144\" \"152\" \"155\" \"160\" \"166\"\n [49] \"171\" \"177\" \"181\" \"184\" \"185\" \"193\" \"198\" \"199\" \"202\" \"218\" \"220\" \"223\"\n [61] \"229\" \"233\" \"235\" \"237\" \"238\" \"239\" \"250\" \"252\" \"253\" \"255\" \"258\" \"259\"\n [73] \"261\" \"262\" \"266\" \"268\" \"269\" \"270\" \"271\" \"276\" \"278\" \"280\" \"281\" \"284\"\n [85] \"285\" \"289\" \"294\" \"296\" \"299\" \"300\" \"301\" \"302\" \"305\" \"314\" \"316\" \"317\"\n [97] \"320\" \"322\" \"323\" \"326\" \"330\" \"331\" \"336\" \"337\" \"340\" \"345\" \"350\" \"353\"\n[109] \"355\" \"356\" \"358\" \"359\" \"360\" \"361\" \"363\" \"365\" \"366\" \"370\" \"372\" \"373\"\n[121] \"375\" \"377\" \"378\" \"381\" \"382\" \"391\" \"392\" \"393\" \"394\" \"396\" \"397\" \"401\"\n[133] \"402\" \"403\" \"407\" \"410\" \"412\" \"413\" \"414\" \"420\" \"424\" \"431\" \"433\" \"441\"\n[145] \"448\" \"449\" \"457\" \"460\" \"462\" \"465\" \"471\" \"472\" \"475\" \"476\" \"485\" \"487\"\n[157] \"489\" \"490\" \"501\" \"511\" \"522\" \"523\" \"530\" \"539\" \"542\" \"544\" \"554\" \"555\"\n[169] \"559\" \"560\" \"561\" \"563\" \"567\" \"568\" \"569\" \"572\" \"582\" \"587\" \"589\" \"590\"\n[181] \"595\" \"598\" \"603\" \"617\" \"618\" \"630\" \"635\" \"636\" \"642\" \"669\" \"672\" \"676\"\n[193] \"683\" \"686\" \"688\" \"690\" \"691\" \"694\" \"699\" \"708\" \"710\" \"713\" \"714\" \"715\"\n[205] \"717\" \"726\" \"729\" \"733\" \"734\" \"742\" \"744\" \"746\" \"748\" \"756\" \"758\" \"759\"\n[217] \"763\" \"764\" \"768\" \"769\" \"770\" \"773\" \"780\" \"781\" \"784\" \"788\" \"789\" \"790\"\n[229] \"794\" \"797\" \"801\" \"803\" \"805\" \"808\" \"811\" \"813\" \"816\" \"821\" \"828\" \"829\"\n[241] \"835\" \"836\" \"841\" \"843\" \"844\" \"846\" \"847\" \"848\" \"855\" \"864\" \"873\" \"876\"\n[253] \"877\" \"878\" \"885\" \"887\" \"893\" \"899\" \"902\" \"905\" \"906\" \"912\" \"915\" \"919\"\n[265] \"920\" \"921\" \"927\" \"936\" \"939\" \"941\" \"942\" \"944\" \"945\" \"950\" \"952\" \"957\"\n[277] \"958\" \"967\" \"975\" \"976\" \"978\" \"983\" \"988\" \"994\" \"995\" \"997\" \"998\" \"999\"\n\n\nNote that this set of networks only includes the alter-alter ties. We may want to generate another set of networks in which ego is also included. This can be done using the include.ego option.\n\ngr.list.ego &lt;- as_igraph(egor.obj, include.ego = TRUE)\n\n\n11.4.1 Examining the egonet objects\nNow let‚Äôs take a closer look at the first egonet object. To do this, we can subset the gr.list with a double bracket. Then let‚Äôs look at the vertex sequence.\n\n(gr &lt;- gr.list[[\"3\"]])\n\nIGRAPH bdea15f UNW- 4 5 -- \n+ attr: .egoID (g/n), name (v/c), SEX (v/n), RACE (v/n), SPOUSE (v/n),\n| PARENT (v/n), SIBLING (v/n), CHILD (v/n), OTHFAM (v/n), COWORK (v/n),\n| MEMGRP (v/n), NEIGHBR (v/n), FRIEND (v/n), ADVISOR (v/n), OTHER\n| (v/n), TALKTO (v/n), KNOWN (v/n), EDUC (v/n), AGE (v/n), RELIG (v/n),\n| weight (e/n)\n+ edges from bdea15f (vertex names):\n[1] 31--32 31--33 32--33 32--34 33--34\n\nV(gr)\n\n+ 4/4 vertices, named, from bdea15f:\n[1] 31 32 33 34\n\n\nWhat if we examined the vertex sequence with ego included? Note the name of the last node.\n\n(gr.ego &lt;- gr.list.ego[[\"3\"]])\n\nIGRAPH bee63aa UNW- 5 9 -- \n+ attr: .egoID (g/n), name (v/c), SEX (v/n), RACE (v/n), SPOUSE (v/n),\n| PARENT (v/n), SIBLING (v/n), CHILD (v/n), OTHFAM (v/n), COWORK (v/n),\n| MEMGRP (v/n), NEIGHBR (v/n), FRIEND (v/n), ADVISOR (v/n), OTHER\n| (v/n), TALKTO (v/n), KNOWN (v/n), EDUC (v/n), AGE (v/n), RELIG (v/n),\n| weight (e/n)\n+ edges from bee63aa (vertex names):\n[1] 31--32  31--33  32--33  32--34  33--34  31--ego 32--ego 33--ego 34--ego\n\nV(gr.ego)\n\n+ 5/5 vertices, named, from bee63aa:\n[1] 31  32  33  34  ego\n\n\nNow let‚Äôs plot out the two versions of this ego network: one without ego and one with ego included.\n\npar(mar = c(0,0,2,0), mfrow = c(1,2))\nplot(gr, vertex.label = NA, main = \"No ego\")\nplot(gr.ego, vertex.label = NA, main = \"With ego\")\n\n\n\n\n\n\n\n\nIn the ‚ÄúWith ego‚Äù graph, can you pick out which node is ego? Remember that ego will always be connected to all nodes in the graph.\nThe next step is to add ego ID as a graph attribute in each list element. We will do this for the alter only object and the ego included object. This will be useful when graphing the different ego networks.\n\n# List of graphs without ego\nfor (i in seq_along(gr.list)) {\n  gr.list[[i]]$ego_id &lt;- names(gr.list)[[i]]\n}\n\n# List of graphs with ego\nfor (i in seq_along(gr.list.ego)) {\n  gr.list.ego[[i]]$ego_id &lt;- names(gr.list.ego)[[i]]\n}\n\ngr.list[[\"10\"]]$ego_id\n\n[1] \"10\"\n\n\nNow that the ego network data have been properly formatted, we can save the objects as an R readable .rda file. I‚Äôve commented this out because the data have already been saved. We will load these objects and examine them in the next tutorial.\n\n# save(ego, alterlong, gr.list, gr.list.ego, file=\"gss_ego.rda\")",
    "crumbs": [
      "Extensions",
      "<span class='chapter-number'>11</span>¬† <span class='chapter-title'>Ego network data setup</span>"
    ]
  },
  {
    "objectID": "egonet_setup.html#references",
    "href": "egonet_setup.html#references",
    "title": "11¬† Ego network data setup",
    "section": "11.5 References",
    "text": "11.5 References\nThis tutorial was built on insights and code from Raffaele Vacca. Please see his textbook (https://raffaelevacca.github.io/egocentric-r-book/) for a more detailed discussion of ego networks.\nIf you are interested in some of the substantive issues associated with the GSS ‚Äúimportant matters‚Äù network data, check out the following resources.\nBearman, Peter, and Paolo Parigi. 2004. ‚ÄúCloning Headless Frogs and Other Important Matters: Conversation Topics and Network Structure.‚Äù Social Forces 83(2):535‚Äì57.\nFischer, Claude S. 2009. ‚ÄúThe 2004 GSS Finding of Shrunken Social Networks: An Artifact?‚Äù American Sociological Review 74(4):657‚Äì69.\nMcPherson, Miller, Lynn Smith-Lovin, and Matthew E. Brashears. 2006. ‚ÄúSocial Isolation in America: Changes in Core Discussion Networks over Two Decades.‚Äù American Sociological Review 71(3):353‚Äì75.\nSmall, Mario Luis. 2017. Someone to Talk To. Oxford University Press.\nSmith, Jeffrey A., Miller McPherson, and Lynn Smith-Lovin. 2014. ‚ÄúSocial Distance in the United States: Sex, Race, Religion, Age, and Education Homophily among Confidants, 1985 to 2004.‚Äù American Sociological Review 79(3):432‚Äì56.",
    "crumbs": [
      "Extensions",
      "<span class='chapter-number'>11</span>¬† <span class='chapter-title'>Ego network data setup</span>"
    ]
  },
  {
    "objectID": "egonet_analysis.html",
    "href": "egonet_analysis.html",
    "title": "12¬† Ego network analysis",
    "section": "",
    "text": "12.1 Analyzing ego network data\nOnce the egocentric network data files have been constructed, we can turn to analyzing the data. First we will add needed ego attributes to the ego list files, then we will show basic visualization strategies, and then we will examine metrics across ego, alter, and edge level characteristics.\nThe code below installs the relevant packages and loads the egonet data.\nlibrary(intronets)\nlibrary(igraph) \nlibrary(ggraph)\nlibrary(tidyverse)\nlibrary(janitor)\nlibrary(gridExtra)\nlibrary(patchwork)\n\nload_nets(\"gss_ego.rda\")",
    "crumbs": [
      "Extensions",
      "<span class='chapter-number'>12</span>¬† <span class='chapter-title'>Ego network analysis</span>"
    ]
  },
  {
    "objectID": "egonet_analysis.html#analyzing-ego-network-data",
    "href": "egonet_analysis.html#analyzing-ego-network-data",
    "title": "12¬† Ego network analysis",
    "section": "",
    "text": "12.1.1 Adding ego attributes\nLet‚Äôs begin by examining a single ego network. Below we save new igraph objects ‚Äì one without ego and one with ego included ‚Äì for the ego network number 10 in our larger list.\n\n# Ego-network graph, ego_id = 10\ngr.10 &lt;- gr.list[[\"10\"]]\n\n# With ego included\ngr.ego.10 &lt;- gr.list.ego[[\"10\"]]\n\nBefore we visualize these networks, we need to address a problem with the weights in the gr.ego.10 network. When we constructed this network, weighted values were assigned to the alter-alter ties, but weighted values do not exist for the ego-alter ties. Let‚Äôs examine the edge attribute for weight.\n\nE(gr.ego.10)$weight\n\n [1]  2  1  1  1  1  1  2  2  2 NA NA NA NA NA\n\nE(gr.ego.10)[.inc(\"ego\")]$weight\n\n[1] NA NA NA NA NA\n\n\nThe last 4 values in the weight vector are NA. These are all of the ego-alter ties. So let‚Äôs apply a distinctive weight (3) for those ties.\n\n(E(gr.ego.10)$weight &lt;- E(gr.ego.10)$weight |&gt; \n  replace_na(3))\n\n [1] 2 1 1 1 1 1 2 2 2 3 3 3 3 3\n\n\nAll of these weights have been filled in with values of 3. Now we can visualize the two versions of ego network number 10.\n\ng1 &lt;- ggraph(gr.10, layout = \"kk\") + \n  geom_edge_link() + \n  geom_node_point(size=5, color=\"blue\") +\n  ggtitle(\"Without ego\") +\n  theme_void()\n\ng2 &lt;- ggraph(gr.ego.10, layout = \"kk\") + \n  geom_edge_link() + \n  geom_node_point(size=5, color=\"blue\") +\n  ggtitle(\"With ego\") +\n  theme_void()\n\ng1 + g2\n\n\n\n\n\n\n\n\nThe problem is that we have 288 different ego networks that need new values for missing weights. So we need a function that will apply a value of 3 to all ego-alter edges simultaneously. See below: 1) generate a weight replacement function and 2) apply that function to all graphs in the gr.list.ego object.\n\n### Weight replacement function\nweight_replace &lt;- function(gr) {\n  E(gr)$weight &lt;- E(gr)$weight |&gt; \n    replace_na(3)\n  gr\n}\n\n### Apply the function to all graphs in the list\ngr.list.ego &lt;- gr.list.ego |&gt;\n  map(weight_replace)\n\nLet‚Äôs check if it worked‚Ä¶\n\nE(gr.list.ego[[\"10\"]])$weight\n\n [1] 2 1 1 1 1 1 2 2 2 3 3 3 3 3\n\n\n‚Ä¶and it did! Values of 3 replaced the previously NA weights for the ego-alter ties in the number 10 ego network.\nNote, though, that this is an issue for all ego attributes as well. Let‚Äôs check out the SEX attribute.\n\nV(gr.list.ego[[\"10\"]])$SEX\n\n[1]  2  2  1  2  2 NA\n\n\nThe last value, which refers to the ego attribute is NA. We will need a special function for this, because instead of applying a constant value (3), it will be necessary to apply a unique value for each ego based on what is in the ego attribute file.\nWith a little help from ChatGPT, I constructed the following function. With it, we can apply all of the values from the ego attribute file to the vertex attributes embedded within each ego network in the gr.list.ego object.\nThe function 1) identifies the appropriate row based on matching ego_id, 2) identifies the last entry in the vector of attributes (because ego is always the last vertex in these objects), and 3) applies the appropriate value in the ego attribute to the attribute vector within the graph list object. The final portion of the code assigns all of the relevant attribute names to a vector (‚Äúego_attributes‚Äù), which it then feeds into the function and applies across the list via the imap command.\n\n# function that applies ego attribute to all egos\nadd_ego_attributes &lt;- function(gr, ego_id, ego_df, attributes) {\n  ego_row &lt;- ego_df[ego_df$ego_id == ego_id, ]\n  ego_index &lt;- length(V(gr))\n  \n  for (attr in attributes) {\n    gr &lt;- set_vertex_attr(gr, name = attr, index = ego_index, value = ego_row[[attr]])\n  }\n  \n  return(gr)\n}\n\n# apply function across all vertex attributes\nego_attributes &lt;- c(\"AGE\", \"EDUC\", \"SEX\", \"RACE\", \"PARTYID\", \"RELIG\")\ngr.list.ego &lt;- imap(gr.list.ego, ~ add_ego_attributes(.x, .y, ego, ego_attributes))\n\nIf this worked, then the NA values should be replaced with correct values from the ego attribute file.\n\nV(gr.list.ego[[\"10\"]])$AGE\n\n[1] 25 25 39 33 30 26\n\nV(gr.list.ego[[\"10\"]])$EDUC\n\n[1]  3  3  3  4  4 14\n\nego[3,1:3]\n\n  ego_id AGE EDUC\n3     10  26   14\n\n\nIndeed, the NAs have been replaced by the appropriate values.\n\n\n12.1.2 Visualizing ego networks\nNow that the correct values are in place, we can add attribute information to the network graphs. We‚Äôll start with a graph of the number 10 network that includes ego, showing the gender of the nodes. Note that the gr.ego.10 object needs to be recreated now that we have added the new attribute information to the orginal list.\n\ngr.ego.10 &lt;- gr.list.ego[[\"10\"]]\n\nggraph(gr.ego.10, layout = \"kk\") + \n  geom_edge_link() + \n  geom_node_label(aes(label = name, color = as.factor(SEX)), size=5) + \n  labs(color = \"Gender\") +\n  scale_color_discrete(labels = c(\"Men\", \"Women\")) +\n  theme_void()\n\n\n\n\n\n\n\n\nHere we see an interesting pattern, whereby ego number 10 is a man who listed one other man confidant along with four women confidants.\nNext let‚Äôs examine the edge weights in the network without ego.\n\nggraph(gr.10, layout = \"kk\") + \n  geom_edge_link(aes(width = weight), show.legend = F) + \n  geom_node_label(aes(label = name), size=5) + \n  theme_void()\n\n\n\n\n\n\n\n\nEgo is not represented in the graph, only relationships among alters. Thicker lines indicate especially close relationships, whereas thinner lines represent simply knowing one another.\nOne final representation to show is communities, which relies on algorithms to detect optimal groups based on modularity (if this is unfamiliar to you, check out my tutorial on community detection). Below I use the Louvain algorithm to identify modular groups. But this time, I will present the network for ego number 80.\n\ngr.80 &lt;- gr.list[[\"80\"]]\n\nlouvain &lt;- cluster_louvain(gr.80)\nV(gr.80)$louvain &lt;- membership(louvain)\n\nggraph(gr.80, layout = \"kk\") + \n  geom_edge_link() + \n  geom_node_label(aes(label = name, color = as.factor(louvain)), size=5, show.legend = F) + \n  theme_void()\n\n\n\n\n\n\n\n\nThese results show two different modular groups. Ego is connected to all of these alters, but the clique between &lt;801,802,803&gt; is not directly connected to &lt;804,805&gt;.",
    "crumbs": [
      "Extensions",
      "<span class='chapter-number'>12</span>¬† <span class='chapter-title'>Ego network analysis</span>"
    ]
  },
  {
    "objectID": "egonet_analysis.html#adding-network-metrics",
    "href": "egonet_analysis.html#adding-network-metrics",
    "title": "12¬† Ego network analysis",
    "section": "12.2 Adding network metrics",
    "text": "12.2 Adding network metrics\n\n12.2.1 Ego attributes\nStatistical analysis of ego networks can be conducted at three different levels: ego attributes, alter composition, and edge structure. These are what we call nested data structures: within each ego is a set of alters and within each group of alters is a set of relationships.\nThese three levels can be analyzed separately or combined. Below I present an example of a combined analysis whereby alter composition and edge structures are aggregated to the ego level. In other words, we‚Äôll keep the data file at the ego level (with each row representing a unique ego) and add summary information about alters and alter ties to each row.\nLet‚Äôs start by creating a new data matrix called e.attribute. Let‚Äôs recode ego attributes for gender (SEX) and race (RACE) into dummy variables (i.e., binary variables).\n\nego.attribute &lt;- ego |&gt; \n  mutate(FEMALE = case_when(SEX == 1 ~ 0,SEX == 2 ~ 1)) |&gt; \n  mutate(NWHITE = if_else(RACE == 1, 0, 1)) |&gt; \n  select(ego_id,FEMALE,NWHITE)\n \ntable(ego.attribute$FEMALE)\n\n\n  0   1 \n128 160 \n\ntable(ego.attribute$NWHITE)\n\n\n  0   1 \n227  61 \n\n\n\n\n12.2.2 Alter composition\nNext let‚Äôs examine alter attribute summaries for ego number 10. Let‚Äôs estimate this ego‚Äôs proportion women alters and the average alter education.\n\n# extract the alter information for ego number 10\nalter.10 &lt;- alterlong |&gt;\n  filter(ego_id==10)\n\n# summarize each attribute\nmean(alter.10$SEX == 2) # proportion women\n\n[1] 0.8\n\nmean(alter.10$EDUC, na.rm = TRUE) # average education\n\n[1] 3.4\n\n\nThese results show that 80 percent of ego number 10‚Äôs alters are women and their average education is 3.4 (which is in the middle between high school graduate (3) and some college(4)).\nThis information can be combined into a single row of data.\n\nalter.10 |&gt;\n  summarise(prop.fem = mean(SEX == 2), \n            mean.educ = mean(EDUC))\n\n# A tibble: 1 √ó 2\n  prop.fem mean.educ\n     &lt;dbl&gt;     &lt;dbl&gt;\n1      0.8       3.4\n\n\nAnd more helpfully, this information can be summarized for all egos.\n\n# apply to the entire set of attributes\na.summary &lt;- alterlong |&gt; \n    group_by(ego_id) |&gt; \n    summarise(prop.fem = mean(SEX == 2), \n              mean.educ = mean(EDUC))\nhead(a.summary)\n\n# A tibble: 6 √ó 3\n  ego_id prop.fem mean.educ\n   &lt;dbl&gt;    &lt;dbl&gt;     &lt;dbl&gt;\n1      3     0.5       5.5 \n2      5     0.75      6   \n3     10     0.8       3.4 \n4     12     1         4.5 \n5     16     0.5       8   \n6     30     0         6.33\n\n\n\n\n12.2.3 Edge structure\nFinally, we can summarize network features for each alter based on the edges between alters. Again, we can start with estimates from a single ego network.\n\nedge_density(gr.10)\n\n[1] 0.9\n\ncomponents(gr.10)$no\n\n[1] 1\n\ncentr_degree(gr.10)$centralization\n\n[1] 0.1\n\n\nDensity in this ego network is equal to .9, which indicates that 90% of all possible ties are present. The components indicates that there is one single connected component among the alters. (Running this on the network for ego number 80 would reveal two different components. See above.) Finally, the degree centralization score is .1, which suggests that this graph lacks hierarchy (it is not centered around a ‚Äústar‚Äù alter).\nFor the purpose of analysis, it will be necessary to obtain these estimates for all egos. This will require the use of the map function. Below I demonstrate how this is achieved for a single metric (edge_density).\n\nhead(map_dbl(gr.list, edge_density))\n\n        3         5        10        12        16        30 \n0.8333333 0.8333333 0.9000000 0.0000000 0.0000000 1.0000000 \n\n\nNext let‚Äôs generate a single row of network metrics for a single ego network.\n\ntibble(dens = edge_density(gr.10),\n       components(gr.10)$no,\n       deg.centr = centr_degree(gr.10)$centralization)\n\n# A tibble: 1 √ó 3\n   dens `components(gr.10)$no` deg.centr\n  &lt;dbl&gt;                  &lt;dbl&gt;     &lt;dbl&gt;\n1   0.9                      1       0.1\n\n\nLet‚Äôs bring this all together by estimating these edge characteristics for all of the ego networks an combining them into a data frame.\n\ne.summary &lt;- gr.list |&gt;\n  map_dfr(~ tibble(dens = edge_density(gr.10),\n                   components(gr.10)$no,\n                   deg.centr = centr_degree(gr.10)$centralization),\n          .id = \"ego_id\")\n\n# make ego_id a numeric variable in the \ne.summary$ego_id &lt;- as.numeric(e.summary$ego_id)\n\nNow we can combine all three levels of data into a single summary file for each ego.\n\n# join the attribute and edge structure summaries with the ego data\nego.attribute &lt;- ego.attribute |&gt; \n  left_join(a.summary, by = \"ego_id\") |&gt; \n  left_join(e.summary, by = \"ego_id\")\n\ncolnames(ego.attribute) &lt;- c(\"ego_id\",\"female\",\"nwhite\",\"prop.fem\",\"mean.educ\",\n                             \"density\",\"components\",\"centralization\")\n\nglimpse(ego.attribute)\n\nRows: 288\nColumns: 8\n$ ego_id         &lt;dbl&gt; 3, 5, 10, 12, 16, 30, 35, 36, 46, 54, 57, 59, 61, 62, 6‚Ä¶\n$ female         &lt;dbl&gt; 0, 1, 0, 1, 0, 0, 1, 1, 0, 0, 0, 1, 0, 0, 1, 0, 1, 1, 1‚Ä¶\n$ nwhite         &lt;dbl&gt; 1, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1‚Ä¶\n$ prop.fem       &lt;dbl&gt; 0.5000000, 0.7500000, 0.8000000, 1.0000000, 0.5000000, ‚Ä¶\n$ mean.educ      &lt;dbl&gt; 5.500000, 6.000000, 3.400000, 4.500000, 8.000000, 6.333‚Ä¶\n$ density        &lt;dbl&gt; 0.9, 0.9, 0.9, 0.9, 0.9, 0.9, 0.9, 0.9, 0.9, 0.9, 0.9, ‚Ä¶\n$ components     &lt;dbl&gt; 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1‚Ä¶\n$ centralization &lt;dbl&gt; 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, ‚Ä¶",
    "crumbs": [
      "Extensions",
      "<span class='chapter-number'>12</span>¬† <span class='chapter-title'>Ego network analysis</span>"
    ]
  },
  {
    "objectID": "egonet_analysis.html#bivariate-analyses",
    "href": "egonet_analysis.html#bivariate-analyses",
    "title": "12¬† Ego network analysis",
    "section": "12.3 Bivariate analyses",
    "text": "12.3 Bivariate analyses\nWith a dataset like this, it is possible to conduct various statistical analyses. Below I show a simple analysis of variance (ANOVA) test to demonstrate one possibility.\n\nego.attribute$female &lt;- factor(ego.attribute$female, labels = c(\"Male\", \"Female\"))\n\nsummary(aov(prop.fem ~ female, data = ego.attribute))\n\n             Df Sum Sq Mean Sq F value   Pr(&gt;F)    \nfemale        1  3.284   3.284   45.83 7.32e-11 ***\nResiduals   286 20.495   0.072                     \n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nsummary(aov(mean.educ ~ female, data = ego.attribute))\n\n             Df Sum Sq Mean Sq F value Pr(&gt;F)\nfemale        1    2.6   2.554   1.418  0.235\nResiduals   286  515.1   1.801               \n\nsummary(aov(density ~ female, data = ego.attribute))\n\n             Df    Sum Sq   Mean Sq F value Pr(&gt;F)\nfemale        1 4.000e-29 4.007e-29   1.251  0.264\nResiduals   286 9.161e-27 3.203e-29               \n\nsummary(aov(components ~ female, data = ego.attribute))\n\n             Df    Sum Sq   Mean Sq F value Pr(&gt;F)\nfemale        1 3.700e-29 3.699e-29   1.251  0.264\nResiduals   286 8.457e-27 2.957e-29               \n\nsummary(aov(centralization ~ female, data = ego.attribute))\n\n             Df    Sum Sq   Mean Sq F value Pr(&gt;F)\nfemale        1 9.600e-32 9.630e-32   1.251  0.264\nResiduals   286 2.201e-29 7.697e-32               \n\n\nThe results suggest that the gender of ego is only significantly associated with one of the network metrics: proportion women alters. This is unsurprising given what we know about gender homophily ‚Äì i.e., people tend to associate with others who are similar based on their gender.\nBelow we can estimate those differences more precisely.\n\naggregate(prop.fem ~ female, data = ego.attribute, mean)\n\n  female  prop.fem\n1   Male 0.4333333\n2 Female 0.6482292\n\n\nOn average, women report that nearly 65 percent of their confidants are also women, compared to 43 percent of men who say the same. Below presents a box plot visualization of these results.\n\nboxplot(prop.fem ~ female, data = ego.attribute,\n        names = c(\"Male egos\", \"Female egos\"),\n        ylab = \"Proportion Female in Ego Network\",\n        main = \"Gender and Ego Network Composition\")\n\n\n\n\n\n\n\n\nThese are simple bivariate analyses. More complex analyses based on multivariate and multilevel analyses are also possible with egocentric network data. Please check out the references below for more details and examples of these approaches.",
    "crumbs": [
      "Extensions",
      "<span class='chapter-number'>12</span>¬† <span class='chapter-title'>Ego network analysis</span>"
    ]
  },
  {
    "objectID": "egonet_analysis.html#references",
    "href": "egonet_analysis.html#references",
    "title": "12¬† Ego network analysis",
    "section": "12.4 References",
    "text": "12.4 References\nThis tutorial was built on insights and code from Raffaele Vacca. Please see his textbook (https://raffaelevacca.github.io/egocentric-r-book/) for a more detailed discussion of ego networks.\nIf you are interested in some of the substantive issues associated with the GSS ‚Äúimportant matters‚Äù network data, check out the following resources.\nBearman, Peter, and Paolo Parigi. 2004. ‚ÄúCloning Headless Frogs and Other Important Matters: Conversation Topics and Network Structure.‚Äù Social Forces 83(2):535‚Äì57.\nFischer, Claude S. 2009. ‚ÄúThe 2004 GSS Finding of Shrunken Social Networks: An Artifact?‚Äù American Sociological Review 74(4):657‚Äì69.\nMcPherson, Miller, Lynn Smith-Lovin, and Matthew E. Brashears. 2006. ‚ÄúSocial Isolation in America: Changes in Core Discussion Networks over Two Decades.‚Äù American Sociological Review 71(3):353‚Äì75.\nSmall, Mario Luis. 2017. Someone to Talk To. Oxford University Press.\nSmith, Jeffrey A., Miller McPherson, and Lynn Smith-Lovin. 2014. ‚ÄúSocial Distance in the United States: Sex, Race, Religion, Age, and Education Homophily among Confidants, 1985 to 2004.‚Äù American Sociological Review 79(3):432‚Äì56.",
    "crumbs": [
      "Extensions",
      "<span class='chapter-number'>12</span>¬† <span class='chapter-title'>Ego network analysis</span>"
    ]
  },
  {
    "objectID": "intro_sna.html",
    "href": "intro_sna.html",
    "title": "1¬† Introduction to Social Network Analysis",
    "section": "",
    "text": "1.1 What is Social Network Analysis?\nSocial network analysis (SNA) refers to the study of relationships between people or groups of people. Relationships are important to study for lots of reasons. For example‚Ä¶",
    "crumbs": [
      "Introduction",
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Introduction to Social Network Analysis</span>"
    ]
  },
  {
    "objectID": "intro_sna.html#what-is-social-network-analysis",
    "href": "intro_sna.html#what-is-social-network-analysis",
    "title": "1¬† Introduction to Social Network Analysis",
    "section": "",
    "text": "They can help us to understand how things like information, ideas, and diseases spread across societies.\nThey can tell us about which people are the most popular, most powerful, and most healthy.\nThey can reveal how people form subgroups or clusters of individuals.\n\n\n1.1.1 Plan for the Book\nThis book is designed as an introduction to social network analysis. This is an exciting method, but it can also be very complex statistically and very challenging in terms of software coding. For many years, we have been teaching social network analysis across multiple levels of college coursework ‚Äì from first semester college freshmen to advanced PhD students. We think that social network analysis can be easy to understand and apply. It does not require advanced statistical knowledge nor an extensive background in coding. Our goal is to break down the ideas and the procedures into an easily digestible way so that people who are learning about SNA for the first time can quickly understand and gain many useful skills.\nHow do we accomplish this? By keeping things simple.\n\nRather than utilizing a dizzying array of different packages for conducting SNA, we instead rely almost entirely on igraph. That way, you can focus on working with one set of objects rather than having to move across multiple sets.\nWe make heavy use of network visualizations in order to illustrate the key concepts and procedures. We use, almost exclusively, one set of plotting tools: ggraph. This package is preferred over others because the coding logic is based on the widely used ggplot suite of visualizations, so working in ggraph will be easy for folks who are already familiar with ggplot and will offer highly transferable skills for newcomers.\nWe structure the book by first taking a deep dive into standard one mode, holistic networks. That way readers can keep this common form of network data in mind while working through the foundational concepts. Once this knowledge is established, we move on to extensions of the one mode framework, with demonstrations of working with and analyzing two-mode, ego-centric, text, and dynamic networks.\n\nFurthermore, we have created a series of web applications that can be used to practice the procedures presented in the book. No coding is required. Just point-and-click to recreate the visualizations and analyses. We have one app for each form of data and we have populated these apps with the example datasets presented in the book (as well as a few others that are not discussed).\nWhile our main goal is to make SNA accessible to new learners, this book also has much value for more advanced students. In fact, much of the content included here has been used as part of the curriculum for our PhD classes on SNA. So while this book emphasizes the logic of SNA, it also makes explicit reference to the statistics that underlie these procedures. We also point readers to advanced sources for further study.\nMoreover, advanced students will benefit from recreating the analyses directly in R and RStudio. Throughout the book, we present and carefully annotate our code so that you can see and understand how we manipulate the data, generate the visualizations, and conduct the analyses. Our code, along with the data, can be used to reproduce everything that is shown here. You can check out the ‚ÄúR and RStudio setup and resources‚Äù chapter in the appendix for details.",
    "crumbs": [
      "Introduction",
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Introduction to Social Network Analysis</span>"
    ]
  },
  {
    "objectID": "network_viz.html",
    "href": "network_viz.html",
    "title": "3¬† Network Visualization",
    "section": "",
    "text": "3.1 Visualizing Networks with ggraph\nThis chapter demonstrates network visualization procedures and strategies using the ggraph package. ggraph was designed to align with the coding principles used for the ggplot set of graphing functions in R.\nAs an illustration, we will use network data from the high tech managers study. Let‚Äôs begin by bringing igraph, ggraph, and intronets into our library.\nlibrary(igraph)\nlibrary(ggraph)\nlibrary(intronets)",
    "crumbs": [
      "Introduction",
      "<span class='chapter-number'>3</span>¬† <span class='chapter-title'>Network Visualization</span>"
    ]
  },
  {
    "objectID": "network_viz.html#loading-the-high-tech-managers-data",
    "href": "network_viz.html#loading-the-high-tech-managers-data",
    "title": "3¬† Network Visualization",
    "section": "3.2 Loading the high tech managers data",
    "text": "3.2 Loading the high tech managers data\nNow let‚Äôs load and examine the high tech managers data. These data were collected by David Krackhardt in the mid-1980s by surveying the managers of a small technology firm in California. (The CEO of the company is also included as one of the managers.) This dataset is especially good to illustrate network visualization because it is small and contains many vertex attributes.\n\nload_nets(\"hi_tech.rda\")\n\nThe network data files contain three different relations among 21 managers in this high tech firm: friendships, advice relations, and direct reporting relationships. We‚Äôll work with the friendships, which were collected by asking each manager, ‚ÄúWho is your friend?‚Äù\n\nhtf\n\nIGRAPH 19e59e2 DN-- 21 102 -- \n+ attr: name (v/c), age (v/n), tenure (v/n), level (v/n), dept (v/n)\n+ edges from 19e59e2 (vertex names):\n [1] X1 -&gt;X2  X1 -&gt;X4  X1 -&gt;X8  X1 -&gt;X12 X1 -&gt;X16 X2 -&gt;X1  X2 -&gt;X18 X2 -&gt;X21\n [9] X3 -&gt;X14 X3 -&gt;X19 X4 -&gt;X1  X4 -&gt;X2  X4 -&gt;X8  X4 -&gt;X12 X4 -&gt;X16 X4 -&gt;X17\n[17] X5 -&gt;X2  X5 -&gt;X9  X5 -&gt;X11 X5 -&gt;X14 X5 -&gt;X17 X5 -&gt;X19 X5 -&gt;X21 X6 -&gt;X2 \n[25] X6 -&gt;X7  X6 -&gt;X9  X6 -&gt;X12 X6 -&gt;X17 X6 -&gt;X21 X8 -&gt;X4  X10-&gt;X3  X10-&gt;X5 \n[33] X10-&gt;X8  X10-&gt;X9  X10-&gt;X12 X10-&gt;X16 X10-&gt;X20 X11-&gt;X1  X11-&gt;X2  X11-&gt;X3 \n[41] X11-&gt;X4  X11-&gt;X5  X11-&gt;X8  X11-&gt;X9  X11-&gt;X12 X11-&gt;X13 X11-&gt;X15 X11-&gt;X17\n[49] X11-&gt;X18 X11-&gt;X19 X12-&gt;X1  X12-&gt;X4  X12-&gt;X17 X12-&gt;X21 X13-&gt;X5  X13-&gt;X11\n[57] X14-&gt;X7  X14-&gt;X15 X15-&gt;X1  X15-&gt;X3  X15-&gt;X5  X15-&gt;X6  X15-&gt;X9  X15-&gt;X11\n+ ... omitted several edges\n\n\nThe ‚ÄúDN‚Äù tells us this is a directed network, which means that ego may nominate an alter as a friend, but that alter may not identify ego as a friend. Also note, in the list of edges, we can see arrows (‚Äú-&gt;‚Äù) between members of a tie rather than two lines (‚Äú‚Äì‚Äù), which is another indication that this network is directed rather than undirected. Technically speaking, ties that are directed are referred to as arcs as opposed to edges, but often network researchers use the term edges to generally refer to both undirected and directed ties.\nThe numbers after the ‚ÄúDN‚Äù tell us that there are 21 vertices and 102 edges. We have several vertex attributes, including age, tenure at the company, supervisory level, and department. These are all features that can be displayed as part of our visualizations. But we will start by developing a simple graph from this network that ignores these attributes.",
    "crumbs": [
      "Introduction",
      "<span class='chapter-number'>3</span>¬† <span class='chapter-title'>Network Visualization</span>"
    ]
  },
  {
    "objectID": "network_viz.html#baseline-visualization-with-ggraph",
    "href": "network_viz.html#baseline-visualization-with-ggraph",
    "title": "3¬† Network Visualization",
    "section": "3.3 Baseline visualization with ggraph",
    "text": "3.3 Baseline visualization with ggraph\nOne of the main benefits of the ggraph package (as well as the ggplot package from which it was derived) is that it allows one to build complex graphs by adding multiple simple layers. The first portion of the command identifies the network object to graph. Then each subsequent line adds an element to the graph. In the code below, we will start by placing the nodes only.\n\nggraph(htf) +\n  geom_node_point() \n\n\n\n\n\n\n\n\nOnly the nodes are placed in the graph. Now let‚Äôs add edges to show the friendships between the nodes by adding another layer to the command.\n\nggraph(htf) +\n  geom_node_point() + \n  geom_edge_link() \n\n\n\n\n\n\n\n\nThe default background is grey, which can make it difficult to see the nodes and edges, so let‚Äôs add another layer that changes the ‚Äútheme‚Äù so that the background is white.\n\nggraph(htf) +\n  geom_node_point() + \n  geom_edge_link() +\n  theme_void()\n\n\n\n\n\n\n\n\nThis is the basic code we will use for drawing networks. We can make various adjustments to these commands in order to visualize and highlight different aspects of the network.",
    "crumbs": [
      "Introduction",
      "<span class='chapter-number'>3</span>¬† <span class='chapter-title'>Network Visualization</span>"
    ]
  },
  {
    "objectID": "network_viz.html#network-layout-basics",
    "href": "network_viz.html#network-layout-basics",
    "title": "3¬† Network Visualization",
    "section": "3.4 Network layout basics",
    "text": "3.4 Network layout basics\nOne of the most important features of these kinds of graphs is the layout. You may have noticed the warning that showed up when running the early code, indicating that ‚Äústress‚Äù is applied as the default layout. Stress is an algorithm that determines the placement of nodes on the basis of the ties between those nodes. More precisely, it is ‚Äúforce-directed‚Äù algorithm, because node placement is subject to a series of attractive and repulsive forces. Nodes repel one another, while lines between nodes operate as rubber bands that pull nodes closer together.\nForce-directed algorithms are very effective for visualizing networks. The repulsive forces keep nodes from being overlayed on top of one another, which would make then hard to see. The attractive forces bring together nodes that are tied to one another. This allows the viewer to infer social closeness in a network on the basis of geometric proximity in the graph. In other words, two nodes tend to be closer to one another in a graph if they are connected to each other and also connected to similar others. Therefore, we can assume that those two nodes exist in similar social space. This is a very intuitive aspect of these kinds of algorithms.\nTo remove the warning from the output, we can add an explicit option in the first line of the code.\n\nggraph(htf, layout = \"stress\") +\n  geom_node_point() + \n  geom_edge_link() +\n  theme_void()\n\n\n\n\n\n\n\n\nThe next chapter will offer other examples of network layouts, force-directed and otherwise. For now, we‚Äôll proceed with stress as our default layout.",
    "crumbs": [
      "Introduction",
      "<span class='chapter-number'>3</span>¬† <span class='chapter-title'>Network Visualization</span>"
    ]
  },
  {
    "objectID": "network_viz.html#common-node-and-edge-features",
    "href": "network_viz.html#common-node-and-edge-features",
    "title": "3¬† Network Visualization",
    "section": "3.5 Common node and edge features",
    "text": "3.5 Common node and edge features\nWithout adding options to the geom_node_point and geom_edge_link layers, ggraph relies on the default display features. But we can make adjustments to many of those features. For example, the code below alters the size, color, and shape of the nodes, as well as the width, color, and transparency (alpha) of the edges.\n\nggraph(htf, layout = \"stress\") +\n  geom_node_point(size = 8, color = \"red\", shape = \"square\") + \n  geom_edge_link(width = 2, color = \"grey\", alpha = .3) +\n  theme_void()\n\n\n\n\n\n\n\n\nOne thing to note here: the edges are overlayed on top of the nodes. That‚Äôs because we added the node layer first, followed by the edge layer. Let‚Äôs reverse that sequence in order to make the nodes more prominent (which is the standard approach for these kinds of graphs).\n\nggraph(htf, layout = \"stress\") +\n  geom_edge_link(width = 2, color = \"grey\", alpha = .3) +\n  geom_node_point(size = 8, color = \"red\", shape = \"square\") + \n  theme_void()",
    "crumbs": [
      "Introduction",
      "<span class='chapter-number'>3</span>¬† <span class='chapter-title'>Network Visualization</span>"
    ]
  },
  {
    "objectID": "network_viz.html#visualizaing-node-attributes",
    "href": "network_viz.html#visualizaing-node-attributes",
    "title": "3¬† Network Visualization",
    "section": "3.6 Visualizaing Node Attributes",
    "text": "3.6 Visualizaing Node Attributes\nYou can think about these kinds of changes as ‚Äúglobal‚Äù adjustments to the graph because we are applying a single standard (such as ‚Äúsquare‚Äù) to all of the elements (such as nodes) in a graph. In some instances, we might want to apply individual features of the nodes or edges to the visualization.\nTo do this, we need to indicate that we want to use an attribute from the igraph object to be applied to the visualization. This is done by adding the ‚Äúaes‚Äù (which is short for ‚Äúaesthetic‚Äù) option to one of the layers. Let‚Äôs try this by altering the color of the nodes based on the department they are in. Remember that this information is located in the vertex attribute called ‚Äúdept‚Äù.\n\nggraph(htf, layout = \"stress\") +\n  geom_edge_link(width = 2, color = \"grey\", alpha = .3) +\n  geom_node_point(aes(color = dept), size = 8, shape = \"square\") + \n  theme_void()\n\n\n\n\n\n\n\n\nNow the node colors are colored from darker blue to lighter blue as the department for each manager gets larger. ggraph treats, by default, numeric variables such as department as continuous, but in this case it would be better to view departments as categorical (or distinct units). To do that, we will need to tell R to treat department as a factor variable.\n\nggraph(htf, layout = \"stress\") +\n  geom_edge_link(width = 2, color = \"grey\", alpha = .3) +\n  geom_node_point(aes(color = as.factor(dept)), size = 8, shape = \"square\") + \n  theme_void()\n\n\n\n\n\n\n\n\nNow the visualizations show the department colors not as gradients, but as distinct. This seems helpful in this context, because this gives us a sense of the extent to which people in different departments share distinct friendship space (like the green nodes from department 2) or are more integrated with other departments (like the yellowish nodes from level 1).\nWhenever we add an aesthetic feature from the igraph object, ggraph defaults to displaying a legend for that element. To remove that feature, which we do below, we can add a ‚Äúshow.legend = FALSE‚Äù option at the end of the layer. And when the layer line gets too long, we can drop each feature down a line, make the code easier to read.\n\nggraph(htf, layout = \"stress\") +\n  geom_edge_link(width = 2, \n                 color = \"grey\", \n                 alpha = .3) +\n  geom_node_point(aes(color = as.factor(dept)), \n                  size = 8, \n                  shape = \"square\", \n                  show.legend = FALSE) + \n  theme_void()\n\n\n\n\n\n\n\n\nR automatically sets the color scheme. To manually set colors for the nodes, we can add a scale_color_manual layer to the code. See below.\n\nggraph(htf, layout = \"stress\") +\n  geom_edge_link(width = 2, \n                 color = \"grey\", \n                 alpha = .3) +\n  geom_node_point(aes(color = as.factor(dept)), \n                  size = 8, \n                  shape = \"square\", \n                  show.legend = FALSE) + \n  scale_color_manual(values = c(\"violet\", \"blue\", \"green\",\"orange\",\"red\")) +\n  theme_void()\n\n\n\n\n\n\n\n\nLet‚Äôs add other node attributes to the graph. Let‚Äôs base the shapes on the supervisory levels and the size based on their tenure. And now that we are displaying multiple attributes, let‚Äôs add the legend back in.\n\nggraph(htf, layout = \"stress\") +\n  geom_edge_link(width = 2, \n                 color = \"grey\", \n                 alpha = .3) +\n  geom_node_point(aes(color = as.factor(dept),\n                      size = tenure,\n                      shape = as.factor(level))) + \n  theme_void()\n\n\n\n\n\n\n\n\nNow let‚Äôs clean up the labels in the legend. For this we need to add a separate ‚Äúlabs‚Äù layer. To that layer, we can also add a title for the figure.\n\nggraph(htf, layout = \"stress\") +\n  geom_edge_link(width = 2, \n                 color = \"grey\", \n                 alpha = .3) +\n  geom_node_point(aes(color = as.factor(dept),\n                      size = tenure,\n                      shape = as.factor(level))) + \n  labs(title = \"Friendships Among High Tech Managers\",\n       color = \"Department\", \n       size = \"Tenure\",\n       shape = \"Level\") +\n  theme_void()",
    "crumbs": [
      "Introduction",
      "<span class='chapter-number'>3</span>¬† <span class='chapter-title'>Network Visualization</span>"
    ]
  },
  {
    "objectID": "network_viz.html#node-labeling",
    "href": "network_viz.html#node-labeling",
    "title": "3¬† Network Visualization",
    "section": "3.7 Node Labeling",
    "text": "3.7 Node Labeling\nAnother common node feature to add is to label the node by its name. For this we also add another layer for ‚Äúgeom_node_text‚Äù. Add this after the geom_node_point layer to make sure it is not covered up by the point.\n\nggraph(htf, layout = \"stress\") +\n  geom_edge_link(width = 2, \n                 color = \"grey\", \n                 alpha = .3) +\n  geom_node_point(aes(color = as.factor(dept),\n                      size = tenure,\n                      shape = as.factor(level))) + \n  geom_node_text(aes(label = name), size = 2) +\n  labs(title = \"Friendships Among High Tech Managers\",\n       color = \"Department\", \n       size = \"Tenure\",\n       shape = \"Level\") +\n  theme_void()\n\n\n\n\n\n\n\n\nAlternatively, we can replace the geom_node_point and geom_node_text lines with a single line for geom_node_label, which we do below. This makes it much easier to see the labels, but it does eliminate our ability to manipulate the shape of the node.\n\nggraph(htf, layout = \"stress\") +\n  geom_edge_link(width = 2, \n                 color = \"grey\", \n                 alpha = .3) +\n  geom_node_label(aes(label = name, \n                      color = as.factor(dept),\n                      size = tenure)) +\n  labs(title = \"Friendships Among High Tech Managers\",\n       color = \"Department\", \n       size = \"Tenure\") +\n  theme_void()",
    "crumbs": [
      "Introduction",
      "<span class='chapter-number'>3</span>¬† <span class='chapter-title'>Network Visualization</span>"
    ]
  },
  {
    "objectID": "network_viz.html#arcs",
    "href": "network_viz.html#arcs",
    "title": "3¬† Network Visualization",
    "section": "3.8 Arcs",
    "text": "3.8 Arcs\nAs noted earlier, technically these ties are arcs, not edges. The direction of the ties can be shown by using the geom_edge_arc layer.\n\nggraph(htf, layout = \"stress\") +\n  geom_edge_arc() +\n  geom_node_label(aes(label = name, \n                      color = as.factor(dept),\n                      size = tenure)) +\n  labs(title = \"Friendships Among High Tech Managers\",\n       color = \"Department\", \n       size = \"Tenure\") +\n  theme_void()\n\n\n\n\n\n\n\n\nInstead of straight lines, we get curved lines. This is needed because each dyad has the potential for two connecting lines. But which direction are the lines headed in? For that we need to add arrows. The ‚Äúlength‚Äù indicates how big the arrows are and ‚Äúclosed‚Äù fills in the arrow heads.\n\nggraph(htf, layout = \"stress\") +\n  geom_edge_arc(arrow = arrow(length = unit(3, 'mm'), type = 'closed')) +\n  geom_node_label(aes(label = name, \n                      color = as.factor(dept),\n                      size = tenure)) +\n  labs(title = \"Friendships Among High Tech Managers\",\n       color = \"Department\", \n       size = \"Tenure\") +\n  theme_void()\n\n\n\n\n\n\n\n\nOnly a few of the arrows are visible. That‚Äôs because the arrows end, by default, at the center of the label. Below we can add code that starts and ends the caps based on the label.\n\nggraph(htf, layout = \"stress\") +\n  geom_edge_arc(aes(start_cap = label_rect(node1.name, \n                                           padding = margin(2, 2, 2, 2, 'mm')), \n                    end_cap = label_rect(node2.name, \n                                         padding = margin(2, 2, 2, 2, 'mm'))),\n                arrow = arrow(length = unit(3, 'mm'), type = 'closed')) +\n  geom_node_label(aes(label = name, \n                      color = as.factor(dept),\n                      size = tenure)) +\n  labs(title = \"Friendships Among High Tech Managers\",\n       color = \"Department\", \n       size = \"Tenure\") +\n  theme_void()\n\n\n\n\n\n\n\n\nFurther, we can adjust the curvature (the ‚Äústrength‚Äù option) and color of those arcs.\n\nggraph(htf, layout = \"stress\") +\n  geom_edge_arc(aes(start_cap = label_rect(node1.name, \n                                           padding = margin(2, 2, 2, 2, 'mm')), \n                    end_cap = label_rect(node2.name, \n                                         padding = margin(2, 2, 2, 2, 'mm'))),\n                arrow = arrow(length = unit(3, 'mm'), type = 'closed'),\n                strength = .2,\n                color = \"grey\") +\n  geom_node_label(aes(label = name, \n                      color = as.factor(dept),\n                      size = tenure)) +\n  labs(title = \"Friendships Among High Tech Managers\",\n       color = \"Department\", \n       size = \"Tenure\") +\n  theme_void()\n\n\n\n\n\n\n\n\nReducing the curvature and lightening the arc colors makes the graph a bit more palatable. But the density of the network is quite high, so the visualization is a bit messy. So we might want to find another way to visualize the mutual versus non-reciprocated ties.",
    "crumbs": [
      "Introduction",
      "<span class='chapter-number'>3</span>¬† <span class='chapter-title'>Network Visualization</span>"
    ]
  },
  {
    "objectID": "network_viz.html#edge-weights",
    "href": "network_viz.html#edge-weights",
    "title": "3¬† Network Visualization",
    "section": "3.9 Edge weights",
    "text": "3.9 Edge weights\nThis is a binary (1,0) network that only shows the presence or absence of a directed tie. But we could generate edge weights to indicate whether a tie is uni-directional or bi-directional. Below is the simplest way to do this. First, we create a constant weight value of 1 for all edges in the htf network. Second, we transform the directed network into an undirected version, but sum the values for each edge by its number of arcs in the directed network. To see if this worked, we produce a table showing the weight values in the new network.\n\nE(htf)$weight &lt;- 1\nhtf_undirected &lt;- as_undirected(htf, mode = \"collapse\", \n                              edge.attr.comb = list(weight = \"sum\"))\ntable(E(htf_undirected)$weight)\n\n\n 1  2 \n56 23 \n\n\nThese results show that there are 56 non-reciprocated edges, compared with 23 reciprocated edges. Armed with this new edge attribute, we can return to the geom_edge_link layer and adjust the width based on this distinction.\n\nggraph(htf_undirected, layout = \"stress\") +\n  geom_edge_link(aes(width = weight), \n                 color = \"grey\", \n                 alpha = .3, \n                 show.legend = FALSE) +\n  geom_node_label(aes(label = name, \n                      color = as.factor(dept),\n                      size = tenure)) +\n  labs(title = \"Friendships Among High Tech Managers\",\n       color = \"Department\", \n       size = \"Tenure\") +\n  theme_void()\n\n\n\n\n\n\n\n\n‚Ä¶or with color and dashed lines.\n\nggraph(htf_undirected, layout = \"stress\") +\n  geom_edge_link(aes(linetype = as.factor(weight), \n                     color = as.factor(weight)), \n                 width = 1.5,\n                 alpha = .3,\n                 show.legend = F) +\n  geom_node_label(aes(label = name, \n                      color = as.factor(dept),\n                      size = tenure)) +\n  scale_edge_linetype_manual(name = \"Connection Type\",\n                             values = c(\"1\" = \"dashed\", \n                                        \"2\" = \"solid\"),\n                             labels = c(\"1\" = \"Unidirectional\", \n                                        \"2\" = \"Bidirectional\")) +\n  labs(title = \"Friendships Among High Tech Managers\",\n       color = \"Department\", \n       size = \"Tenure\") +\n  theme_void()\n\n\n\n\n\n\n\n\nThere are many more options for customizing your network visualizations, but here we‚Äôve covered the basics, emphasizing how to layer edge, node, and label features, as well as adding various options for incorporating node and edge attributes into the visualizations. In the next chapter, we will explore various network layouts and other more advanced customizations.",
    "crumbs": [
      "Introduction",
      "<span class='chapter-number'>3</span>¬† <span class='chapter-title'>Network Visualization</span>"
    ]
  },
  {
    "objectID": "network_viz.html#references",
    "href": "network_viz.html#references",
    "title": "3¬† Network Visualization",
    "section": "3.10 References",
    "text": "3.10 References\nFor more information on the high tech managers network‚Ä¶\n\nKrackhardt D. (1987). Cognitive social structures. Social Networks, 9, 104-134.",
    "crumbs": [
      "Introduction",
      "<span class='chapter-number'>3</span>¬† <span class='chapter-title'>Network Visualization</span>"
    ]
  },
  {
    "objectID": "netsim.html",
    "href": "netsim.html",
    "title": "10¬† Network Simulations",
    "section": "",
    "text": "10.1 Network Simulations\nData simulations are a crucial tool for constructing, sharpening, and testing theories. This is especially true for network data. Below I will present some techniques for simulating different types of networks and examining distributions from network simulations.\nFirst, let‚Äôs install several R packages.\nlibrary(intronets)\nlibrary(igraph)\nlibrary(ggraph)\nlibrary(tidyverse)\nlibrary(gridExtra)\nlibrary(patchwork)\nThe igraph package includes numerous functions that can be used to generate different networks. For example‚Ä¶\n# Built in graphs\neg &lt;- make_empty_graph(40)\nfg &lt;- make_full_graph(40)\nst &lt;- make_star(40)\ntr &lt;- make_tree(40, children = 3, mode = \"undirected\")\nrn &lt;- make_ring(40)\nlt &lt;- make_lattice(c(4,4,4))\n\npar(mar=c(0,0,2,0), mfrow = c(2, 3))\nplot(eg, vertex.size=10, vertex.label=NA,\n     main = \"Empty Graph\")\nplot(fg, vertex.size=10, vertex.label=NA, \n     main = \"Full Graph\")\nplot(st, vertex.size=10, vertex.label=NA,\n     main = \"Star Graph\")\nplot(rn, vertex.size=10, vertex.label=NA,\n     main = \"Ring Graph\")\nplot(tr, vertex.size=10, vertex.label=NA,\n     main = \"Tree Graph\")\nplot(lt, vertex.size=10, vertex.label=NA,\n     main = \"Lattice Graph\")\nAn empty graph contains only nodes (or vertices), but no lines (or edges) connecting them.\nA full graph contains every possible line connecting all nodes with one another.\nA star graph contains a central node connected to a series of ‚Äúpendant‚Äù nodes that each have a degree of 1.\nA ring graph contains nodes that all have a degree of 2 and that only connect to their nearest ‚Äúneighbors,‚Äù generating a circular graph.\nA tree graph contains no transitive triples, which occurs when nodes A, B, and C are all connected together.\nA lattice graph contains nodes that exist in a grid structure.",
    "crumbs": [
      "Analysis",
      "<span class='chapter-number'>10</span>¬† <span class='chapter-title'>Network Simulations</span>"
    ]
  },
  {
    "objectID": "netsim.html#random-graphs",
    "href": "netsim.html#random-graphs",
    "title": "10¬† Network Simulations",
    "section": "10.2 Random graphs",
    "text": "10.2 Random graphs\nIn addition to the specific types of graphs, the igraph package allows one to generate random graphs. The way to do this is to use the sample_gnp function to generate an Erd≈ës-R√©nyi random graph.\nWe can start by setting a random number seed for reproducibility. Then when writing the function, it is necessary to indicate how many nodes to include in the graph, as well as the odds of tie formation between nodes. Below I specify 40 nodes and tie formation odds at 1 tie for every 15 potential ties (or 6.67%).\nThe code below also runs the procedure twice and plots the network graphs (using ggraph) side-by-side (using patchwork).\n\nset.seed(9035768)\nr1 &lt;- sample_gnp(40, 1/15)\nr2 &lt;- sample_gnp(40, 1/15)\n\ng1 &lt;- ggraph(r1, layout = \"fr\") +\n  geom_edge_link(color = \"darkgrey\") +  \n  geom_node_point(color = \"red\", size = 4) +  \n  ggtitle(\"Random 1\") +\n  theme_void()                   \ng2 &lt;- ggraph(r2, layout = \"fr\") +\n  geom_edge_link(color = \"darkgrey\") +  \n  geom_node_point(color = \"red\", size = 4) +    \n  ggtitle(\"Random 2\") +\n  theme_void()                   \n\n### Compare and contrast\ng1 + g2\n\n\n\n\n\n\n\n\nEven though the syntax for generating these two graphs is identical, the results show two different graphs. That‚Äôs because the random graph procedure is stochastic. In other words, the outcome depends on probability. We provide the general parameters for the graph, but the ultimate features of the graph maintain a random component.\nWe will return to these random graphs later in this tutorial. But before we do, we should discuss two other forms of stochastic network simulations.",
    "crumbs": [
      "Analysis",
      "<span class='chapter-number'>10</span>¬† <span class='chapter-title'>Network Simulations</span>"
    ]
  },
  {
    "objectID": "netsim.html#small-worlds",
    "href": "netsim.html#small-worlds",
    "title": "10¬† Network Simulations",
    "section": "10.3 Small Worlds",
    "text": "10.3 Small Worlds\nThe principle of Six Degrees of Separation was first established as part of an experiment conducted by Stanley Milgram in the 1960s. He asked research subjects to send mail correspondence to their friends or acquaintances to reach a target person whom they did not know. The study suggested that people, on average, were only six connections away from any other person in the United States. This was a surprising finding indeed. With so many people in the US, why did it only take an average of 6 connections to reach a random person?\nLater research efforts by Watts and Strogatz pointed to the reason. The social networks of human beings have a unique set of characteristics. First, we have high local density, which simply means that most of the people whom we know also know each other. We tend to form cliques or clans comprised of people who all are relatively interconnected. Second, human social networks also tend to contain individuals who are connected to other individuals outside of their local ‚Äúneighborhoods.‚Äù These super connectors make the big world of social networks seem a bit smaller. Just a few of these connections across the system means that it does not take too many connections to get from one end of the network to the other.\nThis theory is formalized and can be tested as part of the Watts-Strogatz game. The tendency toward local connectivity is captured by the ‚Äúnei‚Äù option. Here we‚Äôll set that as a constant equal to 2. P is the probability of connections outside of the local neighborhood (or in network parlance, ‚Äúrewiring‚Äù). By varying the value of P, we can see how the world gets smaller. Specifically, we can focus on the diameter of the graph to see how large or small the world is. Larger diameters mean that the distance from one end of the graph to the other is greater.\n\nset.seed(9035768)\nP &lt;- .01 # low rewiring probability\nsw01 &lt;- sample_smallworld(dim=1, size=50, nei=2, p=P)\nd01 &lt;- diameter(sw01)\nP &lt;- .04 \nsw04 &lt;- sample_smallworld(dim=1, size=50, nei=2, p=P)\nd04 &lt;- diameter(sw04)\nP &lt;- .09 \nsw09 &lt;- sample_smallworld(dim=1, size=50, nei=2, p=P)\nd09 &lt;- diameter(sw09)\n\ng01 &lt;- ggraph(sw01, layout = \"circle\") +\n  geom_edge_link(color = \"darkgrey\") +  \n  geom_node_point(color = \"red\", size = 4) +    \n  ggtitle(paste(\"p = .01, diameter = \", d01)) +\n  theme_void()                   \ng04 &lt;- ggraph(sw04, layout = \"circle\") +\n  geom_edge_link(color = \"darkgrey\") +  \n  geom_node_point(color = \"red\", size = 4) +    \n  ggtitle(paste(\"p = .04, diameter = \", d04)) +\n  theme_void()                   \ng09 &lt;- ggraph(sw09, layout = \"circle\") +\n  geom_edge_link(color = \"darkgrey\") +  \n  geom_node_point(color = \"red\", size = 4) +    \n  ggtitle(paste(\"p = .09, diameter = \", d09)) +\n  theme_void()                   \n\ng01 + g04 + g09\n\n\n\n\n\n\n\n\nAs P increases, the diameter shrinks. This shows us that the ‚Äúsuper connector‚Äù feature of human social networks helps to make the world smaller.",
    "crumbs": [
      "Analysis",
      "<span class='chapter-number'>10</span>¬† <span class='chapter-title'>Network Simulations</span>"
    ]
  },
  {
    "objectID": "netsim.html#preferential-attachment",
    "href": "netsim.html#preferential-attachment",
    "title": "10¬† Network Simulations",
    "section": "10.4 Preferential attachment",
    "text": "10.4 Preferential attachment\nAnother very important theory about human social networks is preferential attachment. Consider walking into a room filled with people you have never met before. Who are you most interested in talking with? While some might choose the wallflower over in the corner, most people prefer to meet with the most popular people at the party.\nThis principle works the same for social media. The Kardashians don‚Äôt just have a few more followers than you do on Instagram, they have exponentially more followers than you. (No shame‚Ä¶me, too!) The key insight here is that connections with others follow a ‚Äúpower law‚Äù distribution. That is to say, the overwhelming majority of people have a relatively small number of ties, while a small number of people have an immense number of ties. This is all due to preferential attachment. People prefer to attach to others who already have many attachments.\nWe can illustrate the principle of preferential attachment via the Barabasi game (function = sample_pa). This function works by generating a random network in stages, adding new nodes and ties to the network in each step. When a new node enters the network, it has a choice of whom to connect with. The choice is stochastic, but new nodes express a preference for connecting with existing nodes that have more connections (i.e., higher degree).\nThe code below runs the model. First, I set the number of nodes at 500. Second, I set a value for power at 0.5, which refers to the overall strength of preferences for attachment to popular nodes. I would describe this as a medium to high level of preferencing. You should try different values to see how this alters the results. Finally, I am asking for a non-directed network.\n\npa &lt;- sample_pa(500, power = .5, directed = F)\n\nNext, let‚Äôs visualize the results. I set the size of the nodes based on the degree (number of ties). For the color, I distinguish between high degree nodes (degree &gt; 7) and all other nodes.\n\nV(pa)$deg &lt;- degree(pa)\nV(pa)$deg_cat &lt;- ifelse(V(pa)$deg &gt; 7, 2, 1)\n\nggraph(pa, layout = \"fr\") +\n  geom_edge_link(color = \"darkgrey\") +  \n  geom_node_point(aes(color = deg_cat, size = deg), show.legend = F) +    \n  ggtitle(paste(\"Preference = 0.5\")) +\n  theme_void()                   \n\n\n\n\n\n\n\n\nDo you see similarities with any of the built-in graphs we generated earlier? How about the tree network? Notice the similar branching structure with few transitive triples.\nAlso, note how the degree structure of this network corresponds to the power law ‚Äì many nodes have low degree values and a few nodes have very high degree values. In fact, let‚Äôs plot out the degree structure to demonstrate the high level of degree inequality between nodes.\n\ndeg &lt;- as.data.frame(degree(pa))\nggplot(deg, aes(x = `degree(pa)`)) +\n  geom_histogram()",
    "crumbs": [
      "Analysis",
      "<span class='chapter-number'>10</span>¬† <span class='chapter-title'>Network Simulations</span>"
    ]
  },
  {
    "objectID": "netsim.html#random-walk",
    "href": "netsim.html#random-walk",
    "title": "10¬† Network Simulations",
    "section": "10.5 Random walk",
    "text": "10.5 Random walk\nOne of the things simulations are useful for is respondent-driven sampling. Let‚Äôs say you meet someone at a party and they tell you that they are part of an exclusive group. This is interesting to you, as a social scientist, which leads to you to interview this person. The interview goes well, so you ask your informant to share with you the name and contact information of another group member. The hope is that you can sequentially interview a few members of the group to understand how the group operates, rather than having to interview all of the members.\nAs you may have guessed, a concern here is that you may not be gathering a representative sample of the group members. Who are you likely to be interviewing and who is likely to be left out? Knowing more about the structure of relationships among the group could help you answer this question.\nLet‚Äôs generate a combined ring and star network. This group contains a popular leader along with a set of weakly-connected peripheral followers.\n\ng &lt;- make_ring(10, directed = TRUE) %u%\n  make_star(11, center = 11) + edge(11, 1)\nV(g)$name &lt;- as.character(c(1:11))\n\nggraph(g) +\n  geom_edge_link(color = \"black\", \n                arrow = arrow(length = unit(3, 'mm'), \n                              type = \"closed\"),\n                end_cap = circle(3.5, 'mm')) +  \n  geom_node_point(color = \"salmon\", size = 8) +  \n  geom_node_text(aes(label = name)) +\n  theme_void()                   \n\n\n\n\n\n\n\n\nGiven this structure, we can estimate a ‚Äúrandom walk‚Äù across the network. We can start with our introduction to a peripheral individual (person 1) in the group. Then we can simulate options for who person 1 will nominate for an additional interview. Based on the graph, there are only two options. Person 1 has arrows leading to person 2 and person 11 only. Consequently, the random_walk algorithm randomly chooses either 2 or 11. Then based on that choice, the new focal actor has to make an additional choice.\nWe‚Äôll do this below on a small scale, demonstrating a random walk starting at 1 and going 5 additional steps.\n\n(w &lt;- random_walk(g, start = 1, steps = 5))\n\n+ 6/11 vertices, named, from 8377fd1:\n[1] 1  2  3  4  11 1 \n\n\nThe vector shows the random path taken across 5 steps.\nNow let‚Äôs generate a much longer random walk that includes 10000 steps. We can use the table function to observe the frequency that each node appears on the random walk. Knowing about the structure of the graph, can you guess which nodes are going to have the highest frequency?\n\nw &lt;- random_walk(g, start = 1, steps = 10000)\ntable(w)\n\nw\n   1    2    3    4    5    6    7    8    9   10   11 \n3352 1657  800  417  215  107   54   31   15    5 3348 \n\n\nNodes 1 and 11 receive that lion‚Äôs share of attention on the random walk. A close inspection of the graph object reveals why. All nodes have an option of choosing node 11 as a potential next path and once at node 11, the only path option is to travel to node 1.\nThe random walk tells us about centrality or popularity within the network. One might astutely hypothesize, for example, that a group member who is highly central to the network will appear frequently on a random walk. Below I test this idea using eigenvector centrality.\n\nec &lt;- eigen_centrality(g, directed = TRUE)$vector\ncor(table(w), ec)\n\n[1] 0.9622836\n\n\nThe correlation table shows a very high association between a node‚Äôs eigenvector centrality and their chances of being part of a random walk.",
    "crumbs": [
      "Analysis",
      "<span class='chapter-number'>10</span>¬† <span class='chapter-title'>Network Simulations</span>"
    ]
  },
  {
    "objectID": "netsim.html#network-distributions",
    "href": "netsim.html#network-distributions",
    "title": "10¬† Network Simulations",
    "section": "10.6 Network distributions",
    "text": "10.6 Network distributions\nLet‚Äôs return to the random graph models so we can consider how simulated networks can generate distributions. Previously we used the Erd≈ës-R√©nyi model to generate two different random networks. Now let‚Äôs generate 1,000 random networks!\nHold on‚Ä¶why would we want to do that? Well, generating lots of networks creates a set of distributions that can be useful for comparing observed networks to theoretical networks. While that explanation may not make much sense at this point, let‚Äôs go ahead and generate these distributions first, then we can consider their usefulness later.\nThe code below estimates 1000 random networks using the Erd≈ës-R√©nyi game function and then saves metrics for four network features: 1) density, 2) transitivity, 3) diameter, and 4) centralization (based on eigenvector centrality scores). The interpretation of these metrics means little right now. The main point is that we‚Äôre going to get a range of values for these metrics across our large set of networks.\nTo get into the weeds of the code, gnum is our counter for our looped set of code, which will run 1000 times. gdist is our data frame that starts out empty, but will get filled up as each new graph is estimated. The ‚Äúfor‚Äù statement starts the loop, which will run from 1 to 1000. During each iteration, we will estimate a random network and save each of our four metrics. Then we will line the metrics up into a temporary vector (temp) and tack it onto the bottom of the gdist data frame. The resulting data frame will contain 1000 rows and four columns for each of the network metrics.\n\ngnum &lt;- c(1:1000)\ngdist &lt;- as.data.frame(NULL)\n\nfor (i in gnum) {\n  g &lt;- sample_gnp(40, 1/15)\n  density &lt;- edge_density(g)\n  transitivity &lt;- transitivity(g)\n  diameter &lt;- diameter(g)\n  centralization &lt;- centr_eigen(g)$centralization\n  # bind the data and append to the dataframe\n  temp &lt;- cbind(density, transitivity, diameter, centralization)\n  gdist &lt;- rbind(gdist, temp)\n}",
    "crumbs": [
      "Analysis",
      "<span class='chapter-number'>10</span>¬† <span class='chapter-title'>Network Simulations</span>"
    ]
  },
  {
    "objectID": "netsim.html#graphing-network-distributions",
    "href": "netsim.html#graphing-network-distributions",
    "title": "10¬† Network Simulations",
    "section": "10.7 Graphing network distributions",
    "text": "10.7 Graphing network distributions\nUsing density plots in ggplot2, we can display the distributional features of the networks. First, I created the 4 graphs, then we can plot them side-by-side using the grid.arrange function.\n\np1 &lt;- ggplot(gdist, aes(x = density)) +\n  geom_density() +\n  geom_vline(xintercept = mean(gdist$density), color=\"red\")\np2 &lt;- ggplot(gdist, aes(x = transitivity)) +\n  geom_density() +\n  geom_vline(xintercept = mean(gdist$transitivity), color=\"red\")\np3 &lt;- ggplot(gdist, aes(x = diameter)) +\n  geom_density() +\n  geom_vline(xintercept = mean(gdist$diameter), color=\"red\")\np4 &lt;- ggplot(gdist, aes(x = centralization)) +\n  geom_density() +\n  geom_vline(xintercept = mean(gdist$centralization), color=\"red\")\n\ngrid.arrange(p1,p2,p3,p4)\n\n\n\n\n\n\n\n\nThe graphs show the variation in the features of the randomly generated networks. I added vertical lines to indicate the mean values for each distribution.\nNow we can return to the question of why these distributions are useful. Imagine your professor conducted a survey in your class to identify the extent to which students consider each other to be friends. Now let‚Äôs say you are examining a network graph of the results. Is this a typical set of relationships? Is it atypical? Are some features of the network typical and others atypical?\nIt‚Äôs difficult to know the answers to these questions without some sort of baseline. That‚Äôs how random networks can help. By generating random network distributions, we can determine the extent to which an observed network is, say, less centralized than one would expect to find in a random network. Or perhaps transitive triples are more common in an observed network relative to random networks. In these instances, the statistical features of random networks provide a baseline for comparison.\nTo illustrate, let‚Äôs examine a real world network. We gathered data on online interactions on the GitHub platform among people employed by a top software development company in the United States. Each tie represents a shared contribution to GitHub repository. How different are these networks from random networks? Let‚Äôs first install and view the GitHub data.\n\nload_nets(\"github.rda\")\nggraph(github, layout = \"fr\") +\n  geom_edge_link(color = \"darkgrey\", alpha = 0.7) +\n  geom_node_point(color = \"blue\", size = 4) +\n  theme_void()\n\n\n\n\n\n\n\n\nNow let‚Äôs estimate a series of 1000 random graphs based on this observed network. To do this, we‚Äôll need to know the number of nodes and the graph density.\n\nnrow(as.matrix(github))\n\n[1] 174\n\nedge_density(github)\n\n[1] 0.05913228\n\n\nWith this information, we can simulate the graphs, obtaining estimates for transitivity and centralization. We can set these simulated graphs to contain 174 nodes and to be around 6% (or 1 out of 17) in terms of edge density.\n\ngdist &lt;- as.data.frame(NULL)\nfor (i in gnum) {\n  g &lt;- sample_gnp(174, 1/17)\n  transitivity &lt;- transitivity(g)\n  centralization &lt;- centr_eigen(g)$centralization\n  # bind the data and append to the dataframe\n  temp &lt;- cbind(transitivity, centralization)\n  gdist &lt;- rbind(gdist, temp)\n}\n\nNow let‚Äôs obtain the actual transitivity and centralization scores from the GitHub network and compare it to the simulated distributions. I‚Äôll set the distribution mean as a red line and the observed mean as a blue line.\n\ngh_trans &lt;- transitivity(github)\ngh_cent &lt;- centr_eigen(github)$centralization\n\np1 &lt;- ggplot(gdist, aes(x = transitivity)) +\n  geom_density() +\n  geom_vline(xintercept = mean(gdist$transitivity), color=\"red\") +\n  geom_vline(xintercept = gh_trans, color=\"blue\")\np2 &lt;- ggplot(gdist, aes(x = centralization)) +\n  geom_density() +\n  geom_vline(xintercept = mean(gdist$centralization), color=\"red\") + \n  geom_vline(xintercept = gh_cent, color=\"blue\")\n\ngrid.arrange(p1,p2)\n\n\n\n\n\n\n\n\nThe results show that transitivity and centralization in the GitHub network are both far greater than what one would expect to see in a random network. See how the blue lines are far to the right of the simulated distributions.",
    "crumbs": [
      "Analysis",
      "<span class='chapter-number'>10</span>¬† <span class='chapter-title'>Network Simulations</span>"
    ]
  },
  {
    "objectID": "netsim.html#conditional-uniform-graph-cug-tests",
    "href": "netsim.html#conditional-uniform-graph-cug-tests",
    "title": "10¬† Network Simulations",
    "section": "10.8 Conditional Uniform Graph (CUG) Tests",
    "text": "10.8 Conditional Uniform Graph (CUG) Tests\nWhile it is clear to see this result visually, in some cases we might want to know if this result is statistically significant. Technically speaking, this would mean that the observed value is plus or minus 2 standard deviations away from the mean of the simulated distribution, which suggests that the values are very unlikely to be observed merely by chance.\nFor this we can turn to Conditional Uniform Graph (or CUG) tests. CUG tests are great because they allow us to compare network statistics to random graph statistics while also providing information about the extent to which the differences are statistically significant.\nThese procedures are not included in the igraph package, so we‚Äôll have to convert the GitHub igraph object to a network object and use the sna package.\n\nlibrary(sna)\nlibrary(intergraph)\n\ngh_net &lt;- asNetwork(github)\n\nThen we can use apply the CUG test to the gh_net object by simulating a series of 1000 random networks. The following code asks to compare the transitivity (‚Äúgtrans‚Äù) between the gh_net graph and the random graph distribution. The code also notes that this is an undirected ‚Äúgraph‚Äù. Finally, we condition the simulations based on density (‚Äúedges‚Äù), which means that all simulated graphs should have a density similar to the gh_net graph.\n\ncug.test(dat = gh_net, gtrans, mode = c(\"graph\"), cmode = \"edges\") \n\n\nUnivariate Conditional Uniform Graph Test\n\nConditioning Method: edges \nGraph Type: graph \nDiagonal Used: FALSE \nReplications: 1000 \n\nObserved Value: 0.633946 \nPr(X&gt;=Obs): 0 \nPr(X&lt;=Obs): 1 \n\n\nThe results show the observed value of transitivity at 0.63, which indicates that 63 percent of all possible triads in the network are complete (with ties between all three nodes). Is this a significantly high value? Yes. The Pr(X&lt;=Obs) portion of the output tells us that the probability that the observed transitivity value is greater than the random values from the simulated graphs is 1. A probability of 1 means the outcome is certain to happen.\nThe next set of code generates a similar test, but instead of transitivity asks for a comparison of centralization. In this case, we need to provide a few more details for the test to indicate a specific form of centralization (i.e., Freeman degree).\n\ncug.test(dat = gh_net, centralization, mode = c(\"graph\"), cmode = \"edges\",\n         FUN.arg = list(FUN = degree, cmode = \"freeman\")) \n\n\nUnivariate Conditional Uniform Graph Test\n\nConditioning Method: edges \nGraph Type: graph \nDiagonal Used: FALSE \nReplications: 1000 \n\nObserved Value: 0.1740825 \nPr(X&gt;=Obs): 0 \nPr(X&lt;=Obs): 1 \n\n\nHere we can see that the level of degree centralization in the graph is 0.17. Is this large or small? Is the difference statistically significant? As with transitivity, we can see that the Pr(X&lt;=Obs) value is 1, indicating that the level of centralization observed in the GitHub network is significantly greater than what one would expect to observe in a random network of similar density.\nAs you can see, random network simulation has many important uses. In addition to evaluating different types of network structures and social processes, simulations provide the basis for making statistical inferences. In fact, simulations form the basis for inference in advanced network modeling, such as exponential random graph models (or ERGMs).",
    "crumbs": [
      "Analysis",
      "<span class='chapter-number'>10</span>¬† <span class='chapter-title'>Network Simulations</span>"
    ]
  },
  {
    "objectID": "netsim.html#references",
    "href": "netsim.html#references",
    "title": "10¬† Network Simulations",
    "section": "10.9 References",
    "text": "10.9 References\nFor classic research on random networks‚Ä¶\n\nErd≈ës, P.; R√©nyi, A. (1959). ‚ÄúOn Random Graphs.‚Äù Publicationes Mathematicae. 6 (3‚Äì4): 290‚Äì297.\n\nFor more on the small world phenomenon‚Ä¶\n\nMilgram, S. 1967. ‚ÄúThe Small World Problem.‚Äù Psychology Today 2:60‚Äì67.\nWatts, D. J., and S. H. Strogatz. 1998. ‚ÄúCollective Dynamics of ‚Äòsmall-World‚Äô Networks.‚Äù Nature 393(6684):440‚Äì42.\n\nFor more on preferential attachment‚Ä¶\n\nBarab√°si, Albert-L√°szl√≥, and R√©ka Albert. 1999. ‚ÄúEmergence of Scaling in Random Networks.‚Äù Science 286(5439):509‚Äì12.\n\nFor more on GitHub interactions‚Ä¶\n\nMiddleton, Justin, Emerson Murphy-Hill, Demetrius Green, Adam Meade, Roger Mayer, David White, and Steve McDonald. 2018. ‚ÄúWhich Contributions Predict Whether Developers Are Accepted into Github Teams.‚Äù Pp. 403‚Äì13 in Proceedings of the 15th International Conference on Mining Software Repositories, MSR ‚Äô18. New York, NY, USA: Association for Computing Machinery.",
    "crumbs": [
      "Analysis",
      "<span class='chapter-number'>10</span>¬† <span class='chapter-title'>Network Simulations</span>"
    ]
  },
  {
    "objectID": "egonet_setup.html#setting-up-ego-network-data",
    "href": "egonet_setup.html#setting-up-ego-network-data",
    "title": "11¬† Ego network data setup",
    "section": "",
    "text": "How would one define the boundaries of this collective? Perhaps anyone who has read a single novel could be categorized as a fan or, alternatively, we might want to set a threshold for fandom (reading one novel may not be enough to be a ‚Äútrue‚Äù fan).\nEven if we are able to derive an agreeable set of boundary criteria, how would we access a roster of people who meet these criteria? Without a roster, it would be difficult to survey people and ask them about their interactions.\nFinally, Manga is a very popular genre of literature with fans in the hundreds of thousands if not millions. It would not be possible to provide a Manga fan with a list of all other fans from which to select other fans that they know.",
    "crumbs": [
      "Extensions",
      "<span class='chapter-number'>11</span>¬† <span class='chapter-title'>Ego network data setup</span>"
    ]
  }
]